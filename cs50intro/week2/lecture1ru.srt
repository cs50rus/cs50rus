1
00:00:00,000 --> 00:00:00,994


2
00:00:00,994 --> 00:00:03,976
[ИГРАЕТ МУЗЫКА]

3
00:00:03,976 --> 00:01:23,496


4
00:01:23,496 --> 00:01:27,907
DAVID MALAN: Всем привет, это CS50,
и очень волнительный день,

5
00:01:27,907 --> 00:01:29,990
потому что сегодня мы изучим
новый язык.

6
00:01:29,990 --> 00:01:33,020
И едва ли вы можете сказать
что это происходит с вами каждый день.

7
00:01:33,020 --> 00:01:35,810
И этот язык будет немного похож 
на это.

8
00:01:35,810 --> 00:01:37,220
Сегодня мы введем С--

9
00:01:37,220 --> 00:01:41,690
очень традиционный, очень старый
язык, который весь текстовый,

10
00:01:41,690 --> 00:01:45,230
но который может все что Scratch
и даже больше,

11
00:01:45,230 --> 00:01:47,810
однако без особого дружелюбия 
к пользователю

12
00:01:47,810 --> 00:01:49,370
к которому мы привыкли за последние дни.

13
00:01:49,370 --> 00:01:52,490
Тем не менее, хотя он выглядит чуток
непонятно на первый взгляд,

14
00:01:52,490 --> 00:01:55,280
хотя там есть всякие английские или 
похожие на английские слова,

15
00:01:55,280 --> 00:01:58,200
будьте уверены, что в течение нескольких дней,
возможно нескольких недель

16
00:01:58,200 --> 00:02:00,658
вы поймете каждую буковку на экране,

17
00:02:00,658 --> 00:02:02,520
каждую строчку кода и даже больше.

18
00:02:02,520 --> 00:02:06,157
Но я скажу, что любой курс, подобный этому,
может быть сложным, особенно

19
00:02:06,157 --> 00:02:07,490
если у вас нет никакого опыта.

20
00:02:07,490 --> 00:02:10,759
Но напоминаю, что это норма, 
обычное дело.

21
00:02:10,759 --> 00:02:13,490
2/3 слушателей CS50,-- 
вероятно и вы среди них--

22
00:02:13,490 --> 00:02:16,250
никогда не проходили никаких курсов по информатике.

23
00:02:16,250 --> 00:02:21,462
Так что, то что изображено здесь сейчас
будет в итоге понятно ровно так же как и это.

24
00:02:21,462 --> 00:02:24,170
На самом деле, даже если код 
будет выглядеть по другому-- упс.


25
00:02:24,170 --> 00:02:25,670
Даже если код 
будет выглядеть по другому,

26
00:02:25,670 --> 00:02:27,830
идеи за ним
будут точно такими же


27
00:02:27,830 --> 00:02:30,410
как на прошлой неделе на Scratch.

28
00:02:30,410 --> 00:02:33,500
Мы посмотрим на функции и условия
и Бушевские выражения, циклы,

29
00:02:33,500 --> 00:02:35,390
и другие вещи по пути.

30
00:02:35,390 --> 00:02:37,800
Но я возможно напомню о чудесном
хаке(?) из MIT

31
00:02:37,800 --> 00:02:42,350
из 1991, выражении что 
получение образования в MIT

32
00:02:42,350 --> 00:02:44,630
как будто пить из пожарного шланга.

33
00:02:44,630 --> 00:02:46,910
И в духе так называемых 
MIT хаков

34
00:02:46,910 --> 00:02:51,140
Какие то студенты реально подключили 
пожарный шланг к фонтану

35
00:02:51,140 --> 00:02:53,480
с табличкой на стене
на которой написана 
как раз эта фраза.


36
00:02:53,480 --> 00:02:56,240
И это как раз тот вид курса,
который как и многие вводные курсы,

37
00:02:56,240 --> 00:02:58,990
где вы буквальное ощущаете как 
поток информации бьет вас по лицу

38
00:02:58,990 --> 00:03:04,010
гораздо быстрее чем вы можете 
его переварить


39
00:03:04,010 --> 00:03:09,652
Но поймите, вы сможете это все усвоить
со временем

40
00:03:09,652 --> 00:03:11,360
И цель этого курса

41
00:03:11,360 --> 00:03:14,240
это дать вам тот набор концепций
и практических навыков

42
00:03:14,240 --> 00:03:16,040
который абсолютно точно понадобится
позднее.

43
00:03:16,040 --> 00:03:20,960
И в конце семестра у вас будет намного меньше
ощущения как это

44
00:03:20,960 --> 00:03:24,630
и гораздо больше как чего то
в чем вы преуспели.

45
00:03:24,630 --> 00:03:27,880
Итак без долгих разговоров, давайте
же представим этот язык по имени С.

46
00:03:27,880 --> 00:03:30,380
Итак, слева вы можете помнить 
наверное самую простую программу


47
00:03:30,380 --> 00:03:31,910
которую мы могли написать на Scratch

48
00:03:31,910 --> 00:03:35,330
И все что она делала -
заставляла кота или любой другой спрайт

49
00:03:35,330 --> 00:03:36,760
говорить "привет" на экране

50
00:03:36,760 --> 00:03:38,960
Сегодня, чтобы достигнуть
такого же результата

51
00:03:38,960 --> 00:03:42,650
мы напишем код который выглядит 
вот так, используя только клавиатуру

52
00:03:42,650 --> 00:03:44,690
и меньше графических элементов управления.

53
00:03:44,690 --> 00:03:47,910
Но давайте посмотрим почему слева
то же самое что и справа.

54
00:03:47,910 --> 00:03:50,390
Давайте разобьем это на, так сказать,
простые кусочки пазла.

55
00:03:50,390 --> 00:03:53,330
Что это делает?--

56
00:03:53,330 --> 00:03:55,815
Что это представляет из себя
в контексте программы на Scratch?

57
00:03:55,815 --> 00:03:57,440
В чем назначение этого кусочка пазла?

58
00:03:57,440 --> 00:03:58,700
ЗАЛ: Типа начинать программу

59
00:03:58,700 --> 00:03:59,850
DAVID MALAN: Да, для начала программы.

60
00:03:59,850 --> 00:04:01,892
Итак, чтобы главная часть вашей
программы сделала что то,

61
00:04:01,892 --> 00:04:05,600
вам нужно прикрепить ее к 
этому кусочку пазла с зеленым флагом.

62
00:04:05,600 --> 00:04:08,693
И мы увидим что в С это не 
настолько очевидно.

63
00:04:08,693 --> 00:04:11,360
Но пока это можно просто скопировать
 и вставить

64
00:04:11,360 --> 00:04:15,040
И в течение нескольких дней оно
обретет смысл, символ за символом.

65
00:04:15,040 --> 00:04:17,720
Int main void и потом 
открытые фигурные скобки,

66
00:04:17,720 --> 00:04:20,029
которые затем закрываются

67
00:04:20,029 --> 00:04:22,940
предполагая, что весь код который 
мы напишем сегодня

68
00:04:22,940 --> 00:04:26,240
пойдет между фигурных скобок
как в примере

69
00:04:26,240 --> 00:04:28,770
с кусочками пазла

70
00:04:28,770 --> 00:04:31,785
Так вот, даже если вам не будет понятно
что происходит сегодня, или несколько следующих дней

71
00:04:31,785 --> 00:04:34,160
поймите что функционально
это то же самое что и сказать

72
00:04:34,160 --> 00:04:38,070
"если зеленый флаг нажат,
запустите главную часть моей программы"

73
00:04:38,070 --> 00:04:40,197
Итак, что программа должна сделать
для нас?

74
00:04:40,197 --> 00:04:43,280
Наверное мы хотим начать с чего нибудь типа
 печати "Hello world", как мы делали на Scratch 

75
00:04:43,280 --> 00:04:45,030
просто напечатать hello world на экране.

76
00:04:45,030 --> 00:04:48,260
Итак, представим что вам сейчас
надо это сделать на С, С

77
00:04:48,260 --> 00:04:50,930
основан на тексте или 
клавиатурно-ориентированный язык.

78
00:04:50,930 --> 00:04:55,490
Так вот, нету глагола или функции
которая называется "сказать" в С. Вместо этого,

79
00:04:55,490 --> 00:04:57,410
она называется "print", вернее не "print".

80
00:04:57,410 --> 00:05:00,680
На самом деле зовется printf,
где f значит formatted(форматированное)

81
00:05:00,680 --> 00:05:03,860
которая позволяет печатать отформатированный
текст, как мы скоро увидим.

82
00:05:03,860 --> 00:05:07,400
Затем вы просто ставите две скобки
рядом с printf--

83
00:05:07,400 --> 00:05:09,830
открывающую скобку
и закрывающую скобку.

84
00:05:09,830 --> 00:05:14,180
И это в некотором роде похоже на эту овальную
форму, в которую мы раньше

85
00:05:14,180 --> 00:05:15,770
запихивали нашу строку.

86
00:05:15,770 --> 00:05:19,210
И на прошлой неделе мы вводили
say hello world.

87
00:05:19,210 --> 00:05:21,770
Так что буквально в С, мы напишем
"hello world"

88
00:05:21,770 --> 00:05:24,200
между этих двух скобочек.

89
00:05:24,200 --> 00:05:25,850
Но С более придирчив

90
00:05:25,850 --> 00:05:28,850
Вы не можете просто начать писать
слова между скобочек.

91
00:05:28,850 --> 00:05:32,870
В любой момент если у вас символы,
или слова, или предложения, или фразы,

92
00:05:32,870 --> 00:05:36,290
вам нужно обернуть их двойными
кавычками,

93
00:05:36,290 --> 00:05:37,090
как в данном случае.

94
00:05:37,090 --> 00:05:40,340
Так что вам нужно обернуть все
что вы хотите сказать или напечатать

95
00:05:40,340 --> 00:05:41,540
двойными кавычками здесь.

96
00:05:41,540 --> 00:05:44,480
И последняя вещь с С, о которой легко
забыть, и вы непременно ее забудете

97
00:05:44,480 --> 00:05:47,520
это то, что нужно закончить свою мысль.

98
00:05:47,520 --> 00:05:51,000
Как в сочинении на уроках английского, вы 
обычно заканчиваете предложение точкой,

99
00:05:51,000 --> 00:05:52,850
так и в С вам нужно закончить мысль.

100
00:05:52,850 --> 00:05:55,730
Но не точкой, а точкой с запятой

101
00:05:55,730 --> 00:05:57,560
в конце строчки кода.

102
00:05:57,560 --> 00:06:00,882
Но мы еще посмотрим какие типы 
строчек кода требуют закрытия

103
00:06:00,882 --> 00:06:02,840
Итак, слева у нас идея
прошлой недели.

104
00:06:02,840 --> 00:06:06,930
Справа у нас идея этой недели
и мы скоро увидим на моем компьютере,

105
00:06:06,930 --> 00:06:08,930
что функционально они идентичны.

106
00:06:08,930 --> 00:06:10,440
Они делают одно и то же.

107
00:06:10,440 --> 00:06:13,940
Так что давайте обсудим, как
мы перешли из этой программы на Scratch

108
00:06:13,940 --> 00:06:15,540
к этой программе на Scratch?

109
00:06:15,540 --> 00:06:18,770
Так что давайте посмотрим на 
последнее что хотелось сказать.

110
00:06:18,770 --> 00:06:20,840
Нам нужна последняя строчка кода,
которую я только что

111
00:06:20,840 --> 00:06:24,090
вывел на экране,
которая include stdio.h

112
00:06:24,090 --> 00:06:25,320
Так вот, что это значит?

113
00:06:25,320 --> 00:06:28,010
Получается что Scratch
очень дружелюбный к пользователю.

114
00:06:28,010 --> 00:06:30,600
Мы получили все эти разноцветные категории
с кусочками пазлов

115
00:06:30,600 --> 00:06:32,670
слева, и они все просто доступны

116
00:06:32,670 --> 00:06:35,220
с момента когда вы вообще
начали использовать Scratch.

117
00:06:35,220 --> 00:06:38,910
В С, когда вы хотите использовать какую то
функцию-- всмысле какой то кусочек паззла,

118
00:06:38,910 --> 00:06:39,790
если вы хотите--

119
00:06:39,790 --> 00:06:42,240
вам обычно нужно заранее
сказать компьютеру

120
00:06:42,240 --> 00:06:47,110
где эта функция сделана,
где она была сохранена.

121
00:06:47,110 --> 00:06:50,340
И это будет, если честно, достаточно
запутанный способ сказать,

122
00:06:50,340 --> 00:06:52,880
"Эй, компьтер, взгляни
в том файле что мы собираемся делать"

123
00:06:52,880 --> 00:06:56,640
чтобы начать вызывать stdio.h,
что бы это ни значило,

124
00:06:56,640 --> 00:06:58,933
чтобы получить доступ к этой функции.

125
00:06:58,933 --> 00:07:00,350
Опять же, огромный глоток.

126
00:07:00,350 --> 00:07:02,400
Первый из пожарных шлангов
сегодня.

127
00:07:02,400 --> 00:07:04,620
Но реально важная строка кода
нужная для сегодняшней задачи,

128
00:07:04,620 --> 00:07:07,470
это вот эта внизу.

129
00:07:07,470 --> 00:07:11,040
Так вот, как я собираюсь
писать мою первую программу на С,

130
00:07:11,040 --> 00:07:15,210
подобно тому как мы на прошлой
неделе написали программу на Scratch?

131
00:07:15,210 --> 00:07:18,540
Так вот, вспомните, что первое,
что мы сделали на Scratch

132
00:07:18,540 --> 00:07:22,950
это открыли программу,
инструментарий-- scratch.mit.edu.

133
00:07:22,950 --> 00:07:25,530
Вы можете программировать,
на Windows или Mac,

134
00:07:25,530 --> 00:07:27,510
неважно какая у вас операционка.

135
00:07:27,510 --> 00:07:30,630
Но, если честно, это становится
сложно и раздражает, когда

136
00:07:30,630 --> 00:07:32,640
приходится устанавливать и
поддерживать

137
00:07:32,640 --> 00:07:36,900
нужный софт на всех наших
персональных компьютерах.

138
00:07:36,900 --> 00:07:39,420
У всех нас установлены разные
программы, разные вещи

139
00:07:39,420 --> 00:07:41,500
и наши компьютеры все работают
несколько по разному.

140
00:07:41,500 --> 00:07:44,440
Поэтому в начальные недели CS50,
мы используем облачный инструмент--

141
00:07:44,440 --> 00:07:48,270
CS50 Sandbox, который живет
на sandbox.cs50.io.

142
00:07:48,270 --> 00:07:51,360
И вы используете именно его, чтобы решать
задачи этой недели.

143
00:07:51,360 --> 00:07:54,280
Это программное окружение в духе
Scratch,

144
00:07:54,280 --> 00:07:55,530
но не использующее Scratch.

145
00:07:55,530 --> 00:07:57,000
Тут нет никаких кусочков пазла.

146
00:07:57,000 --> 00:07:59,730
Вместо этого у нас С,
этот текстовый язык.

147
00:07:59,730 --> 00:08:01,530
который мы уже начнем сейчас.

148
00:08:01,530 --> 00:08:04,410
Итак, в этом окружении две части.

149
00:08:04,410 --> 00:08:07,350
В области сверху я просто буду писать код.

150
00:08:07,350 --> 00:08:09,250
Буквально сейчас, я
кликну на кнопку плюс,

151
00:08:09,250 --> 00:08:10,708
и создам новый файл.

152
00:08:10,708 --> 00:08:13,390
И я собираюсь начать писать код в этот
файл и сохранить его.

153
00:08:13,390 --> 00:08:16,038
И потом, в нижней части этой
утилиты находится

154
00:08:16,038 --> 00:08:18,330
то что мы будем называть
окно консоли.

155
00:08:18,330 --> 00:08:20,880
Консоль - это такой олдскульный
интерфейс

156
00:08:20,880 --> 00:08:24,780
через который вы запускаете команды,
буквально печатая их

157
00:08:24,780 --> 00:08:25,980
и нажимая Enter.

158
00:08:25,980 --> 00:08:27,330
Поэтому не как в Scratch--

159
00:08:27,330 --> 00:08:29,700
ну и вообще-то, не как в Mac OS
и не как в Windows

160
00:08:29,700 --> 00:08:32,610
где можно куда то кликнуть,
что то перетащить, взаимодействуя

161
00:08:32,610 --> 00:08:35,460
с графическим интерфейсом,
большая часть нашего программирования

162
00:08:35,460 --> 00:08:38,620
на ранних этапах будет включать
печатание команд.

163
00:08:38,620 --> 00:08:40,380
Поэтому давайте приблизим наши условия
к реальности.

164
00:08:40,380 --> 00:08:44,580
Напоминаю, что наша задача - это
без геморроя написать программу на С

165
00:08:44,580 --> 00:08:47,580
которая говорит привет миру,
что функционально то же самое,

166
00:08:47,580 --> 00:08:49,950
что и программа на Scratch слева.

167
00:08:49,950 --> 00:08:53,295
Но нам нужно сделать это
используя язык справа.

168
00:08:53,295 --> 00:08:55,170
Итак, в этом программном окружении я

169
00:08:55,170 --> 00:08:59,610
нажму на кнопку "Плюс", чтобы
создать новый файл или вкладку.

170
00:08:59,610 --> 00:09:03,090
По принятым соглашениям, я
назову файл как нибудь типа hello.c.

171
00:09:03,090 --> 00:09:05,550
Hello потому что я хочу
чтобы эта программа говорила 'hello',

172
00:09:05,550 --> 00:09:07,170
но вообще я мог бы назвать его как я хочу.

173
00:09:07,170 --> 00:09:10,920
И точка с, потому что соглашение
в этом языке С говорит,

174
00:09:10,920 --> 00:09:14,640
что надо оканчивать свои файлы,
которые содержат код буквально,

175
00:09:14,640 --> 00:09:18,740
точкой с С, типа как у вас есть
,doc или .dotx для Ворда,

176
00:09:18,740 --> 00:09:22,342
.gif для графических файлов,
и так далее.

177
00:09:22,342 --> 00:09:24,300
Поэтому я жму Create File.

178
00:09:24,300 --> 00:09:27,750
И вы видите что сейчас у меня мигает
курсор ввода на линии 1--

179
00:09:27,750 --> 00:09:31,530
оно автоматически пронумерует мои линии
для меня-- во вкладке по имени hello.c.

180
00:09:31,530 --> 00:09:33,000
Там я могу писать код.

181
00:09:33,000 --> 00:09:37,210
Итак, несмотря на то, что код,
который я сейчас напишу, весьма загадочен--

182
00:09:37,210 --> 00:09:41,400
include standard.io, int main void.

183
00:09:41,400 --> 00:09:44,220
И потом вот тут, я сделаю
printf, открыть кавычки, закрыть кавычки,

184
00:09:44,220 --> 00:09:46,650
"hello world" точка с запятой.

185
00:09:46,650 --> 00:09:50,008
Я только что написал
свою первую программу на С.

186
00:09:50,008 --> 00:09:52,050
Итак, я сейчас увеличу
верхнюю левую часть.

187
00:09:52,050 --> 00:09:54,120
Всего шесть строк кода.

188
00:09:54,120 --> 00:09:57,720
И вы видите что я включил stdio.h,
что бы это ни значило,

189
00:09:57,720 --> 00:09:59,850
int main void, что бы это ни значило.

190
00:09:59,850 --> 00:10:02,610
И реально, все мясцо этой программы
на пятой строчке--

191
00:10:02,610 --> 00:10:07,050
print, или printf для
форматирования, "hello world."

192
00:10:07,050 --> 00:10:10,050
Вспоминаем, что int main void
это похоже на тот кусочек пазла

193
00:10:10,050 --> 00:10:11,580
где зеленый флаг.

194
00:10:11,580 --> 00:10:13,980
И printf похоже на блок Say.

195
00:10:13,980 --> 00:10:16,350
И эта верхняя строчка,
она нам нужна,

196
00:10:16,350 --> 00:10:19,320
потому что компьютер не поймет
что такое printf

197
00:10:19,320 --> 00:10:22,630
пока я ему прямо не скажу включить этот файл.

198
00:10:22,630 --> 00:10:26,850
Отлично, теперь я могу
сказать что я написал какой то код.

199
00:10:26,850 --> 00:10:28,110
Как мне теперь его запустить?

200
00:10:28,110 --> 00:10:32,390
Ну, как вы запускаете
программу на компьютере?

201
00:10:32,390 --> 00:10:34,590
Что вы обычно делаете?

202
00:10:34,590 --> 00:10:36,180
Дважды щёлкаете по ней, верно?

203
00:10:36,180 --> 00:10:39,730
К сожалению, здесь нет ничего,
по чему можно было бы щёлкнуть.

204
00:10:39,730 --> 00:10:41,370
На моём экране даже никакого значка нет.

205
00:10:41,370 --> 00:10:44,100
На самом деле, как таковой пока
нет и самой программы.

206
00:10:44,100 --> 00:10:47,760
Ведь компьютеры, как мы помним,
не понимают английский язык.

207
00:10:47,760 --> 00:10:49,740
Технически, они и язык C
не понимают.

208
00:10:49,740 --> 00:10:52,440
Но тогда какой язык они вообще
знают и понимают?

209
00:10:52,440 --> 00:10:53,235
ЗАЛ: Двоичный.

210
00:10:53,235 --> 00:10:55,110
DAVID MALAN: Именно, двоичный.
Нули и единицы.

211
00:10:55,110 --> 00:10:56,943
А здесь, как мы видим,
совсем не нули и единицы.

212
00:10:56,943 --> 00:11:00,030
И, честно говоря, никому из нас
не понравился бы процесс написания кода,

213
00:11:00,030 --> 00:11:03,240
включающий в себя буквальную запись нулей
и единиц, что, в некотором смысле,

214
00:11:03,240 --> 00:11:06,450
некогда и правда представляло собой
программирование.

215
00:11:06,450 --> 00:11:09,510
Но в настоящее время существует
решение этой проблемы.

216
00:11:09,510 --> 00:11:12,660
Вот с этим, как бы загадочно оно
ни выглядело для большинства из вас,

217
00:11:12,660 --> 00:11:15,540
вы хоть как-то сможете свыкнуться,

218
00:11:15,540 --> 00:11:18,700
как только познакомитесь с синтаксисом,
правилами

219
00:11:18,700 --> 00:11:19,530
и так далее.

220
00:11:19,530 --> 00:11:22,260
Но нужно как-то преобразовать это
в нули и единицы.

221
00:11:22,260 --> 00:11:25,110
Возможно, не совсем очевидно,
как именно.

222
00:11:25,110 --> 00:11:31,110
Оказывается, что для преобразования
такого кода в нули и единицы,

223
00:11:31,110 --> 00:11:34,770
понятные компьютеру, необходимо наличие
промежуточного этапа.

224
00:11:34,770 --> 00:11:38,370
Мне нужно, чтобы на моём компьютере или
в этом облачном окружении

225
00:11:38,370 --> 00:11:43,200
была программа, которая бы взяла
мой исходный код,

226
00:11:43,200 --> 00:11:45,650
написанный на языке C, и выдала на выходе

227
00:11:45,650 --> 00:11:48,000
то, что называется машинным кодом.

228
00:11:48,000 --> 00:11:53,400
Исходный код - то, что написано на C,
Python, Java, C++ или другом языке,

229
00:11:53,400 --> 00:11:54,660
о котором вы могли слышать.

230
00:11:54,660 --> 00:11:58,170
Языке с подобным английскому синтаксисом,
на котором вы пишете программы.

231
00:11:58,170 --> 00:12:02,760
Машинный же код - это нули и единицы,
которые понимает каждый компьютер.

232
00:12:02,760 --> 00:12:05,970
Итак, для перехода от исходного кода
к машинному

233
00:12:05,970 --> 00:12:08,773
необходим некий алгоритм или,
если быть точнее,

234
00:12:08,773 --> 00:12:10,690
подпрограмма, осуществляющая преобразование.

235
00:12:10,690 --> 00:12:14,230
И такую подпрограмму мы будем называть
компилятором.

236
00:12:14,230 --> 00:12:17,790
Мы будем писать код, буквально набирая
команды с клавиатуры.

237
00:12:17,790 --> 00:12:20,160
Потом будем сохранять эти команды в файл,

238
00:12:20,160 --> 00:12:21,900
точно так же, как вы сохраняли код в Scratch.

239
00:12:21,900 --> 00:12:24,990
Но прежде, чем я смогу запустить программу,
выполнив двойной щелчок или что-то подобное,

240
00:12:24,990 --> 00:12:28,200
мне необходимо прогнать её через компилятор

241
00:12:28,200 --> 00:12:30,640
и получить результат, состоящий
из нулей и единиц.

242
00:12:30,640 --> 00:12:33,000
Так, ну и как же мне это сделать?

243
00:12:33,000 --> 00:12:35,640
Это первая из более эзотерических команд,

244
00:12:35,640 --> 00:12:38,880
но оказывается, что её
относительно просто выполнить.

245
00:12:38,880 --> 00:12:40,680
В верхней части моей среды программирования--

246
00:12:40,680 --> 00:12:43,380
опять же, код у меня тут сверху слева,

247
00:12:43,380 --> 00:12:45,780
а если прокрутить экран до самого низа,
то здесь находится

248
00:12:45,780 --> 00:12:47,322
так называемое окно терминала.

249
00:12:47,322 --> 00:12:49,530
Символ доллара - это просто
странная человеческая условность.

250
00:12:49,530 --> 00:12:51,930
Он означает что-то вроде
"введи сюда что-нибудь".

251
00:12:51,930 --> 00:12:54,540
Это ваша так называемая командная строка
или командная оболочка.

252
00:12:54,540 --> 00:12:59,700
Мигающий курсор предлагает мне
ввести команду в этой строке.

253
00:12:59,700 --> 00:13:04,740
В качестве первой команды я собираюсь
использовать команду Clang из языка C.

254
00:13:04,740 --> 00:13:09,210
Clang - это название программы,
предназначенной для компиляции кода.

255
00:13:09,210 --> 00:13:10,650
Её не я написал.

256
00:13:10,650 --> 00:13:14,100
Кто-то другой создал её и назвал Clang--
группа людей,

257
00:13:14,100 --> 00:13:14,640
если быть точным.

258
00:13:14,640 --> 00:13:18,210
Они выложили её в свободный доступ, чтобы
мы с вами могли использовать её на компьютерах

259
00:13:18,210 --> 00:13:19,990
или в такой вот изолированной среде.

260
00:13:19,990 --> 00:13:23,110
И мы можем использовать Clang для преобразования
исходного кода в машинный.

261
00:13:23,110 --> 00:13:26,940
Так что теперь я просто запущу команду
Clang hello.c.

262
00:13:26,940 --> 00:13:29,860
Я пока ещё не нажал клавишу Enter,
но в тот момент, когда я это сделаю,

263
00:13:29,860 --> 00:13:31,360
кое-что произойдёт.

264
00:13:31,360 --> 00:13:33,720
Давайте я щёлкну по этому маленькому
значку папки вот здесь,

265
00:13:33,720 --> 00:13:37,020
и вы увидите все файлы в моей
текущей, так сказать, песочнице,

266
00:13:37,020 --> 00:13:38,710
моей среде программирования.

267
00:13:38,710 --> 00:13:41,752
Файл здесь только один, потому что
единственным созданным мной файлом

268
00:13:41,752 --> 00:13:43,170
является hello.c.

269
00:13:43,170 --> 00:13:45,720
Но обратите внимание на то,
что произойдёт после нажатия Enter,

270
00:13:45,720 --> 00:13:47,940
то есть после выполнения команды Clang hello.c.

271
00:13:47,940 --> 00:13:50,610


272
00:13:50,610 --> 00:13:54,150
Определённо, появилось что-то новое,

273
00:13:54,150 --> 00:13:56,490
что-то странное и с очень глупым именем.

274
00:13:56,490 --> 00:14:02,520
Это файл a.out, но вы, возможно, догадываетесь,
что находится внутри него.

275
00:14:02,520 --> 00:14:03,842
Что там может быть?

276
00:14:03,842 --> 00:14:04,800
ЗАЛ: Машинный код.

277
00:14:04,800 --> 00:14:06,133
DAVID MALAN: Именно, машинный код.

278
00:14:06,133 --> 00:14:09,540
Вообще говоря, это вывод сборки,
но это то же самое, что машинный код.

279
00:14:09,540 --> 00:14:13,110
Внутри этого файла есть только
набор нулей и единиц,

280
00:14:13,110 --> 00:14:16,437
которые соответствуют этому коду,
но в двоичном виде,

281
00:14:16,437 --> 00:14:18,270
то есть на языке, понятном компьютеру.

282
00:14:18,270 --> 00:14:20,640
Так что я сейчас сделал буквально следующее--

283
00:14:20,640 --> 00:14:24,450
Я взял вот такой исходный код,
написанный на языке C.

284
00:14:24,450 --> 00:14:28,148
Я подал его на вход компилятора и на выходе
получил результат из нулей и единиц.

285
00:14:28,148 --> 00:14:29,940
И эти нули и единицы были автоматически

286
00:14:29,940 --> 00:14:35,113
сохранены в файл, который, по умолчанию,
называется a.out.

287
00:14:35,113 --> 00:14:37,530
Хорошо, но кто-то предложил раньше,
что для запуска программы

288
00:14:37,530 --> 00:14:40,088
на компьютере нужно просто
дважды щёлкнуть по ней.

289
00:14:40,088 --> 00:14:41,880
Но у нас тут не по чему щёлкать.

290
00:14:41,880 --> 00:14:44,940
Даже если я дважды щёлкну вот так,
результат будет странным,

291
00:14:44,940 --> 00:14:46,380
потому что компьютер не поймёт,
что нужно сделать.

292
00:14:46,380 --> 00:14:48,930
Это ведь просто нули и единицы,
они не предназначены для щелчков.

293
00:14:48,930 --> 00:14:52,598
Но зато они предназначены для выполнения
в командной строке.

294
00:14:52,598 --> 00:14:53,890
Давайте я покажу.

295
00:14:53,890 --> 00:14:54,807
Это тоже может выглядеть не очень непонятно,

296
00:14:54,807 --> 00:14:58,740
но я просто возьму и выполню команду
./a.out.

297
00:14:58,740 --> 00:15:02,190
И вот это, как бы странно оно не выглядело
на первый взгляд,

298
00:15:02,190 --> 00:15:07,890
является корректным способом указания компьютеру
"выполни a.out в текущем каталоге".

299
00:15:07,890 --> 00:15:11,010
Точка в начале команды означает буквально
"прямо здесь",

300
00:15:11,010 --> 00:15:13,260
"в текущей папке", как если бы вы дважды щёлкали

301
00:15:13,260 --> 00:15:14,730
по файлу на компьютере.

302
00:15:14,730 --> 00:15:19,650
И /a.out значит посмотреть в эту папку,
и запустить программу в файле, которая называется

303
00:15:19,650 --> 00:15:20,860
a.out.

304
00:15:20,860 --> 00:15:23,150
Поэтому давайте продолжим и нажмем Enter.

305
00:15:23,150 --> 00:15:25,980
И вуаля, hello world.

306
00:15:25,980 --> 00:15:29,610
Итак, насколько я помню, на прошлой неделе Вы были впечатлены,
когда я сделал так, чтобы кот сказал

307
00:15:29,610 --> 00:15:30,580
hello world.

308
00:15:30,580 --> 00:15:32,510
Здесь, кажется мы не в восторге

309
00:15:32,510 --> 00:15:36,360
Но hello world это моя программа на
Cи, которая делает абсолютно то же самое.

310
00:15:36,360 --> 00:15:39,870
Но конечно, она выглядит
немного глупо сейчас.

311
00:15:39,870 --> 00:15:40,950
И она выглядит немного глючно.

312
00:15:40,950 --> 00:15:44,373
В чем загвоздка, даже
если Вы не программировали никогда раньше?

313
00:15:44,373 --> 00:15:45,290
AUDIENCE: Знак доллара.

314
00:15:45,290 --> 00:15:46,748
DAVID MALAN: Да, знак доллара.

315
00:15:46,748 --> 00:15:48,660
Я не хочу сказать
hello world знак доллара,

316
00:15:48,660 --> 00:15:50,868
но знак доллара
это как артефакт, верно?

317
00:15:50,868 --> 00:15:52,482
Что это опять за знак доллара?

318
00:15:52,482 --> 00:15:53,190
АУДИТОРИЯ: Подсказка

319
00:15:53,190 --> 00:15:54,150
DAVID MALAN: Это просто подсказка.

320
00:15:54,150 --> 00:15:57,270
Он ждет другой команды, и
вот почему мой курсор мигает там.

321
00:15:57,270 --> 00:15:58,603
Но это выглядит довольно глупо, не так ли?

322
00:15:58,603 --> 00:16:01,538
Мы можем утверждать, что таково было
мое намерение, но, честно говоря, я бы солгал.

323
00:16:01,538 --> 00:16:03,330
Он не делает не совсем то, что я хотел бы,
чтобы он делал.

324
00:16:03,330 --> 00:16:05,380
И это потому что, в отличии от нуля--

325
00:16:05,380 --> 00:16:06,930
который, опять же, более удобен для пользователя--

326
00:16:06,930 --> 00:16:12,220
Си, и многие языки подобные ему, в прямом смысле
будут делать только то, что Вы скажете им делать.

327
00:16:12,220 --> 00:16:16,972
Я ни разу не сказал компьютеру
передвинуть курсор на новую строчку.

328
00:16:16,972 --> 00:16:18,180
Я не закончил эту мысль.

329
00:16:18,180 --> 00:16:20,340
Я сказал, hello, запятая,
world, и на этом все.

330
00:16:20,340 --> 00:16:23,650
На самом деле, я никогда не отправлял команду
компьютеру переместить курсор,

331
00:16:23,650 --> 00:16:24,660
но я могу.

332
00:16:24,660 --> 00:16:26,830
Итак, позвольте мне вернуться к моему коду.

333
00:16:26,830 --> 00:16:30,300
И, оказывается, что в
Си, если вы скажете компьютеру

334
00:16:30,300 --> 00:16:33,240
напечатать hello, запятая, world,
в буквальном смысле все это,

335
00:16:33,240 --> 00:16:34,620
это будет напечатано.

336
00:16:34,620 --> 00:16:36,810
Если хотите напечатать
новую строчку, вам нужно

337
00:16:36,810 --> 00:16:40,950
использовать специальную команду, специальный
символ, который называется новый символ строки,

338
00:16:40,950 --> 00:16:43,650
он выглядит следующим образом -  обратный слэш n.

339
00:16:43,650 --> 00:16:44,672
А почему так происходит?

340
00:16:44,672 --> 00:16:46,380
Ну, это действительно так,
даже несмотря на то, что вы

341
00:16:46,380 --> 00:16:49,590
можете быть намерены нажимать
Enter  и просто нажмете

342
00:16:49,590 --> 00:16:51,900
Enter так, как вы надеетесь
компьютер сделает

343
00:16:51,900 --> 00:16:54,210
даже если вы никогда не программировали
раньше, это, вероятней всего

344
00:16:54,210 --> 00:16:55,950
будет создавать
неудобства.

345
00:16:55,950 --> 00:16:57,270
Это выглядит немного странно.

346
00:16:57,270 --> 00:16:59,460
Это выглядит немного неопрятно,
когда одна строка здесь

347
00:16:59,460 --> 00:17:00,930
а вторая строка здесь.

348
00:17:00,930 --> 00:17:03,180
Так что люди решили
много лет назад,

349
00:17:03,180 --> 00:17:06,750
что будет простая
команда, бэкслэш n,

350
00:17:06,750 --> 00:17:10,170
которая говорит компьютеру
переместить эту новую строку вниз.

351
00:17:10,170 --> 00:17:11,670
Итак, позвольте мне пойти дальше и уменьшить масштаб сейчас.

352
00:17:11,670 --> 00:17:14,010
В песочнице все автоматически
сохраняется точно так же как Google Docs,

353
00:17:14,010 --> 00:17:16,589
так что вам не нужно кликать на File,
Save или что-нибудь в этом духе.

354
00:17:16,589 --> 00:17:23,440
If I go ahead now and rerun this program
./a.out Enter, it's not yet fixed.

355
00:17:23,440 --> 00:17:25,319
Let me go ahead and zoom in.

356
00:17:25,319 --> 00:17:27,210
Notice that the symptom is still there.

357
00:17:27,210 --> 00:17:28,260
Почему?

358
00:17:28,260 --> 00:17:31,050
Какую ошибку я только что сделал?

359
00:17:31,050 --> 00:17:32,700
Да, я не перекомпилировал это.

360
00:17:32,700 --> 00:17:36,120
И еще раз напомню,  компьютер будет
воспринимать вас очень, очень буквально

361
00:17:36,120 --> 00:17:38,580
now that you're programming
it to do things.

362
00:17:38,580 --> 00:17:41,340
And if you want to run the
new version of your code,

363
00:17:41,340 --> 00:17:44,880
you are literally going to
have to do something like Clang

364
00:17:44,880 --> 00:17:48,360
и затем hello.c, Enter.

365
00:17:48,360 --> 00:17:49,810
И, кажется, ничего не произошло.

366
00:17:49,810 --> 00:17:52,552
И, честно говоря, ирония в том,
когда вы не видите результатов (output),

367
00:17:52,552 --> 00:17:53,760
это обычно неплохо.

368
00:17:53,760 --> 00:17:56,340
Когда вы видите результат (output), это обычно
список, например, из пяти ошибок

369
00:17:56,340 --> 00:17:58,560
которые вы сделали или сообщения
об ошибке, которые мы скоро увидим.

370
00:17:58,560 --> 00:18:00,120
Но у нас все еще есть a.out.

371
00:18:00,120 --> 00:18:02,200
Это просто новая версия

372
00:18:02,200 --> 00:18:06,930
Так что, если я продолжу и увеличу сейчас
и сделаю это-- ./a.out, Enter--

373
00:18:06,930 --> 00:18:10,070
теперь у меня есть более впечатляющая
версия hello world.

374
00:18:10,070 --> 00:18:12,450
Теперь я немного его подкорректирую.

375
00:18:12,450 --> 00:18:14,190
Хорошо, дайте мне
буквально минутку

376
00:18:14,190 --> 00:18:18,490
и посмотрим, есть ли вопросы
по этим механикам.

377
00:18:18,490 --> 00:18:19,066
Да?

378
00:18:19,066 --> 00:18:20,440
АУДИТОРИЯ: Почему вторая строка пустая?

379
00:18:20,440 --> 00:18:21,940
DAVID MALAN: Скажите это чуть громче.

380
00:18:21,940 --> 00:18:23,640
AUDIENCE: Почему вторая строка пустая?

381
00:18:23,640 --> 00:18:24,330
DAVID MALAN: Почему вторая строка пустая?

382
00:18:24,330 --> 00:18:25,540
O, это действвительно хороший вопрос.

383
00:18:25,540 --> 00:18:29,678
Строка 2 пуста только потому, что
я решил, что стилистически

384
00:18:29,678 --> 00:18:30,720
так будет выглядеть немного лучше.

385
00:18:30,720 --> 00:18:32,553
Так же как при написании эссе,
вы можете нажать

386
00:18:32,553 --> 00:18:34,500
Enter, Enter - это просто для того, чтобы
разделить параграфы,

387
00:18:34,500 --> 00:18:36,810
так программисты часто
разделяют свой  код, просто

388
00:18:36,810 --> 00:18:39,300
чтобы сделать его немного более
читательным, чтобы он не

389
00:18:39,300 --> 00:18:41,610
выглядел как один большой массив кода.

390
00:18:41,610 --> 00:18:44,680
Но это не обязательно,
и я мог бы опустить это.

391
00:18:44,680 --> 00:18:46,880
Есть еще какие-то вопросы?

392
00:18:46,880 --> 00:18:49,036
Да?

393
00:18:49,036 --> 00:18:51,940
АУДИТОРИЯ: Можно ли переименовать a.out
таким образом, чтобы был больше, чем один

394
00:18:51,940 --> 00:18:52,898
файл в папке?

395
00:18:52,898 --> 00:18:54,315
DAVID MALAN: Это очень хороший вопрос.

396
00:18:54,315 --> 00:18:57,750
Можно ли переименовать a.out таким образом, чтобы была
больше, чем один файл или программа

397
00:18:57,750 --> 00:18:58,740
в той же самой папке?

398
00:18:58,740 --> 00:18:59,430
Конечно.

399
00:18:59,430 --> 00:19:00,990
Давайте я это сделаю прямо сейчас.

400
00:19:00,990 --> 00:19:04,350
Оказывается, что при запуске
на компьютере таких команд, как Clang,

401
00:19:04,350 --> 00:19:08,100
можно указывать не только
имя программы и имя файла.

402
00:19:08,100 --> 00:19:10,380
Вы можете добавлять дополнительные
параметры, иначе известные

403
00:19:10,380 --> 00:19:12,180
как аргументы командной строки.

404
00:19:12,180 --> 00:19:14,280
И здесь тоже есть что-то загадочное.

405
00:19:14,280 --> 00:19:19,020
Необходимо заранее знать эти аргументы,
чтобы иметь возможность их указать.

406
00:19:19,020 --> 00:19:20,640
Но оказывается, что в случае с Clang--

407
00:19:20,640 --> 00:19:22,740
если почитаете документацию,
то увидите сами--

408
00:19:22,740 --> 00:19:25,920
можно использовать аргумент "-o" для вывода.

409
00:19:25,920 --> 00:19:28,140
А далее можно задать любое имя

410
00:19:28,140 --> 00:19:31,860
для файла, в котором будет сохранён
машинный код.

411
00:19:31,860 --> 00:19:33,000
Обратите внимание на то, что сейчас произойдёт.

412
00:19:33,000 --> 00:19:35,550
Когда я нажму Enter, посмотрите
в левый верхний угол,

413
00:19:35,550 --> 00:19:37,710
где сейчас есть файлы "a.out" и "hello.c".

414
00:19:37,710 --> 00:19:40,930
Там также есть "hello".

415
00:19:40,930 --> 00:19:45,210
А сейчас я введу ./hello вместо a.out

416
00:19:45,210 --> 00:19:48,137
и получу тот же самый результат.

417
00:19:48,137 --> 00:19:50,970
Здесь я хотел бы отметить ещё кое-что.

418
00:19:50,970 --> 00:19:53,570
Хотя мы и видим графический интерфейс
вот тут,

419
00:19:53,570 --> 00:19:55,320
он тут лишь ради удобства,
потому как мы с вами

420
00:19:55,320 --> 00:19:59,310
уже привыкли к подобным интерфейсам
на компьютерах.

421
00:19:59,310 --> 00:20:04,590
Но через командную строку я могу делать
всё то же самое, что и с помощью мыши.

422
00:20:04,590 --> 00:20:07,350
Например, в этой среде программирования

423
00:20:07,350 --> 00:20:10,200
я могу ввести команду "ls" для вывода списка.

424
00:20:10,200 --> 00:20:13,800
Это краткое обозначение, потому что
несколько лет назад люди решили, что, ну,

425
00:20:13,800 --> 00:20:17,830
зачем писать "L-I-S-T", если можно просто
ввести "ls", что почти то же самое.

426
00:20:17,830 --> 00:20:22,320
Так и появилась команда "ls",
которая отображает

427
00:20:22,320 --> 00:20:26,340
список всех файлов в текущем каталоге.

428
00:20:26,340 --> 00:20:30,570
И мы видим всё то же самое--
файлы a.out, hello и hello.c.

429
00:20:30,570 --> 00:20:33,720
Возможно, вы догадываетесь,
что означает символ звёздочки

430
00:20:33,720 --> 00:20:36,060
после имён файлов a.out и hello?

431
00:20:36,060 --> 00:20:37,033
ЗАЛ: Они исполняемые.

432
00:20:37,033 --> 00:20:38,950
DAVID MALAN: Исполняемые, верно,
что означает,

433
00:20:38,950 --> 00:20:42,660
что внутри них находится машинный код,
который может быть выполнен компьютером,

434
00:20:42,660 --> 00:20:45,773
тогда как после hello.c нет звёздочки,

435
00:20:45,773 --> 00:20:47,190
потому что это исходный код.

436
00:20:47,190 --> 00:20:50,340
Так что даже визуально можно отличить
исходный код

437
00:20:50,340 --> 00:20:51,600
от машинного кода.

438
00:20:51,600 --> 00:20:54,630
А теперь предположим, что я не хочу
больше иметь файл a.out,

439
00:20:54,630 --> 00:20:56,130
потому что он называется как-то глупо.

440
00:20:56,130 --> 00:20:58,230
Так я никогда не запомню,
что это там программа.

441
00:20:58,230 --> 00:21:02,520
Ну, тогда я могу ввести другую команду,
например, "rm", и удалить a.out.

442
00:21:02,520 --> 00:21:03,660
И затем нажать Enter.

443
00:21:03,660 --> 00:21:04,980
Снова небольшая магия.

444
00:21:04,980 --> 00:21:07,540
Тут написано про удаление обычного файла a.out.

445
00:21:07,540 --> 00:21:10,890
Обратите внимание, что курсор
после вопросительного знака мигает.

446
00:21:10,890 --> 00:21:15,060
Я могу ввести "Y" или "yes",
чтобы подтвердить команду.

447
00:21:15,060 --> 00:21:17,010
Кажется, как будто ничего не произошло.

448
00:21:17,010 --> 00:21:20,730
Но как мне проверить, какие файлы теперь
существуют в этом каталоге?

449
00:21:20,730 --> 00:21:24,790
Я просто снова введу "ls", и теперь
у меня тут только эти два файла.

450
00:21:24,790 --> 00:21:27,450
Так что мы видим, что нам доступно
множество разных команд.

451
00:21:27,450 --> 00:21:34,140
Например, такие, как "ls" и "rm".

452
00:21:34,140 --> 00:21:36,690
Есть команда "mkdir" для создания каталога,

453
00:21:36,690 --> 00:21:38,683
есть "rmdir" для его удаления.

454
00:21:38,683 --> 00:21:41,100
Когда вам нужно будет узнать или
использовать какую-то из команд,

455
00:21:41,100 --> 00:21:43,080
мы обязательно сообщим об этом
в условии задания.

456
00:21:43,080 --> 00:21:46,320
А пока запомните: всё, что вы можете
делать с помощью мыши

457
00:21:46,320 --> 00:21:50,610
и графического пользовательского интерфейса,
вы можете делать и через командную строку.

458
00:21:50,610 --> 00:21:53,640
Ладно, давайте пойдём дальше

459
00:21:53,640 --> 00:21:55,950
и сделаем кое-что более интересное.

460
00:21:55,950 --> 00:21:58,350
Вернёмся к исходному виду.

461
00:21:58,350 --> 00:22:02,000
Итак, пока что всё, что мы сделали —
это вывели на экран фразу "Hello, world".

462
00:22:02,000 --> 00:22:04,620
Но как вы помните, вторая программа,
которую мы писали на прошлой неделе,

463
00:22:04,620 --> 00:22:06,450
была чуть более динамичной и интерактивной.

464
00:22:06,450 --> 00:22:10,200
Помните, что делала наша вторая программа
в Scratch на прошлой неделе?

465
00:22:10,200 --> 00:22:12,400
ЗАЛ: Запрашивала у пользователя имя.

466
00:22:12,400 --> 00:22:14,692
DAVID MALAN: Точно, спрашивала имя.

467
00:22:14,692 --> 00:22:17,550
И мы отвечали "hello, David",
или "hello, Brian", в зависимости

468
00:22:17,550 --> 00:22:19,133
от того, кто запустил программу.

469
00:22:19,133 --> 00:22:21,300
Та программа выглядела примерно так.

470
00:22:21,300 --> 00:22:25,590
Эти две строчки кода соединялись с блоком
"когда нажат зелёный флажок".

471
00:22:25,590 --> 00:22:28,170
Вот этот синий блок сверху был функцией,

472
00:22:28,170 --> 00:22:32,940
которая возвращала значение, ответ.

473
00:22:32,940 --> 00:22:35,170
Она возвращала то, что вводил пользователь.

474
00:22:35,170 --> 00:22:38,130
И это было полезно, потому что затем
мы использовали ответ пользователя

475
00:22:38,130 --> 00:22:42,600
для объединения (или конкатенации)
со словом "hello".

476
00:22:42,600 --> 00:22:45,160
И далее мы выводили полученный результат.

477
00:22:45,160 --> 00:22:46,255
А как сделать то же самое в языке C?

478
00:22:46,255 --> 00:22:48,630
Что ж, именно с этого момента
всё будет резко усложняться.

479
00:22:48,630 --> 00:22:51,570
Но опять же, процесс будет подчинён
определённым правилам и шаблонам,

480
00:22:51,570 --> 00:22:54,190
которые постепенно будут становиться
всё понятнее.

481
00:22:54,190 --> 00:22:57,990
В языке C (по крайней мере, в песочнице
курса CS50) ближайшим аналогом

482
00:22:57,990 --> 00:23:03,810
функции запроса из Scratch является функция
под названием get_string (получить строку).

483
00:23:03,810 --> 00:23:06,180
Строка в программировании —
это просто обозначение

484
00:23:06,180 --> 00:23:09,750
слова, фразы или предложения.

485
00:23:09,750 --> 00:23:14,470
То есть это текст, а не число
или данные другого типа.

486
00:23:14,470 --> 00:23:19,680
Итак, get_string — ближайший аналог
функции запроса.

487
00:23:19,680 --> 00:23:22,830
В скобках, которые соответствуют полю вот тут,

488
00:23:22,830 --> 00:23:24,840
можно задать какую-то фразу,

489
00:23:24,840 --> 00:23:27,673
скажем, вопрос, который пользователь
увидит на экране--

490
00:23:27,673 --> 00:23:30,217
например, "как вас зовут",
обязательно в кавычках.

491
00:23:30,217 --> 00:23:31,050
А зачем, собственно, нужны кавычки?

492
00:23:31,050 --> 00:23:34,050
Чуть ранее я сказал, что каждый раз,
когда вы передаёте строку--

493
00:23:34,050 --> 00:23:36,450
слово, фразу, буквы алфавита--

494
00:23:36,450 --> 00:23:38,460
вы должны заключать её в двойные кавычки

495
00:23:38,460 --> 00:23:40,380
с обеих сторон.

496
00:23:40,380 --> 00:23:44,994
А это что за странное заклинание,
обратная косая черта и "n" ("\n")?

497
00:23:44,994 --> 00:23:45,786
ЗАЛ: Переход на новую строку.

498
00:23:45,786 --> 00:23:47,970
DAVID MALAN: Верно, оно просто
переводит курсор на новую строку.

499
00:23:47,970 --> 00:23:48,540
Зачем?

500
00:23:48,540 --> 00:23:50,207
Просто потому, что так немного красивее.

501
00:23:50,207 --> 00:23:51,000
Я не обязан этого делать.

502
00:23:51,000 --> 00:23:54,370
И действительно, мгновение назад, мой
компьютер ожидал от меня ответа: Да или Нет

503
00:23:54,370 --> 00:23:56,780
и он не переместил курсор
на новую строку.

504
00:23:56,780 --> 00:23:59,470
Это произошло потому что программист
решил не делать этого.

505
00:23:59,470 --> 00:24:02,120
Но я продолжу с переносом строки.

506
00:24:02,120 --> 00:24:07,150
Когда я запросил имя пользователя
с помощью функции get_string,

507
00:24:07,150 --> 00:24:08,680
мне нужно что-то с этим сделать.

508
00:24:08,680 --> 00:24:12,220
И чтобы реализовать это в языке С вы 
буквально заводите переменную

509
00:24:12,220 --> 00:24:15,837
которая хранит
значения.

510
00:24:15,837 --> 00:24:18,670
Я назову переменную answer,
точно так же как в Scratch.

511
00:24:18,670 --> 00:24:21,040
Но в языке С вы можете назвать 
её как угодно.

512
00:24:21,040 --> 00:24:22,565
Я могу назвать её xyz.

513
00:24:22,565 --> 00:24:25,690
Все эти имена не очень наглядны, 
поэтому я назову её answer (ответ).

514
00:24:25,690 --> 00:24:27,100
Вы можете использовать любое слово.

515
00:24:27,100 --> 00:24:28,990
Но в С все немного по другому.

516
00:24:28,990 --> 00:24:34,480
С - олдскульный язык, поэтому вы должны
явно указать тип значения,

517
00:24:34,480 --> 00:24:37,630
которое вы получаете, и, соответственно,
храните в этой переменной.

518
00:24:37,630 --> 00:24:40,040
Поэтому слева от 
имени переменной

519
00:24:40,040 --> 00:24:43,810
я должен сказать компьютеру, что
тип значения, который мне нужно хранить

520
00:24:43,810 --> 00:24:45,010
будет строкой.

521
00:24:45,010 --> 00:24:49,180
Скоро мы узнаем, что
существуют и другие типы значений.

522
00:24:49,180 --> 00:24:53,860
Есть цифры и прочие, но сейчас
мы просто будем хранить строку.

523
00:24:53,860 --> 00:24:56,760
Но мы кое-что упустили в 
этой строчке кода.

524
00:24:56,760 --> 00:24:57,700
Зрители: точка с запятой.

525
00:24:57,700 --> 00:24:58,600
DAVID MALAN: точка с запятой, верно?

526
00:24:58,600 --> 00:25:00,392
Конец мысли,
и это была не маленькая мысль,

527
00:25:00,392 --> 00:25:02,200
и точка с заятой завершает эту мысль.

528
00:25:02,200 --> 00:25:04,700
Знак "равно" в этом случае
отличается от привычного нам в алгебре.

529
00:25:04,700 --> 00:25:07,750
Если вы вспомните математику,
вы скажите, что Х равен Y.

530
00:25:07,750 --> 00:25:11,440
Когда X равен Y, то это буквально означает,
что X - это тоже самое, что и Y.

531
00:25:11,440 --> 00:25:14,740
Но в языках программирования,
знак "равно"

532
00:25:14,740 --> 00:25:17,990
как правило означает 
перемещение справа налево.

533
00:25:17,990 --> 00:25:20,560
Этот знак "равно" 
не подразумевает равенство.


534
00:25:20,560 --> 00:25:24,070
Он обозначает "присваивание", 
или "оператор присваивания".

535
00:25:24,070 --> 00:25:27,200
Перемести что-либо справа
в левую часть.

536
00:25:27,200 --> 00:25:31,600
Таким образом, если функция get_string,
точно так же как функция ask,

537
00:25:31,600 --> 00:25:35,140
спрашивает у пользователя его имя
и возвращает значение,

538
00:25:35,140 --> 00:25:37,930
то вы помещаете это имя
в переменную,

539
00:25:37,930 --> 00:25:40,192
которая называется answer.
Справа налево.

540
00:25:40,192 --> 00:25:42,650
Как мы и написали эту
строку справа налево,

541
00:25:42,650 --> 00:25:45,710
вы должны думать о выполнении этой команды
как справа налево.

542
00:25:45,710 --> 00:25:48,310
Итак, на текущий момент,
у нас есть

543
00:25:48,310 --> 00:25:52,960
где-то в памяти компьютера так называемая
переменная - ответ пользователя

544
00:25:52,960 --> 00:25:54,130
на вопрос какое у него имя.

545
00:25:54,130 --> 00:25:55,540
Что мы хотим с этим сделать?

546
00:25:55,540 --> 00:25:58,093
В языке С нет функции join,
поэтому нам

547
00:25:58,093 --> 00:26:00,010
придется сделать это
немного иначе.

548
00:26:00,010 --> 00:26:03,613
В С есть функция аналогичная функции say.
Как эта функция называется?

549
00:26:03,613 --> 00:26:04,340
Зрители: Printf.

550
00:26:04,340 --> 00:26:05,173
DAVID MALAN: Printf.

551
00:26:05,173 --> 00:26:08,440
Printf - это функция, которую мы испольуем 
когда хотим что-то сказать или вывести

552
00:26:08,440 --> 00:26:09,320
на экране.

553
00:26:09,320 --> 00:26:10,993
Поэтому я продолжу, используя printf.

554
00:26:10,993 --> 00:26:13,660
И я буду использовать скобки, 
потому что скобки означают:

555
00:26:13,660 --> 00:26:18,670
здесь идут данные, называемые в программировании
аргументами или параметрами.

556
00:26:18,670 --> 00:26:21,100
Для нас это  
синонимы.

557
00:26:21,100 --> 00:26:23,350
И сейчас это всё немного 
неправильно, да?

558
00:26:23,350 --> 00:26:29,180
Потому что я не хочу просто вывести
кавычки, привет, запятая, ответ, кавычки.

559
00:26:29,180 --> 00:26:29,680
Почему?

560
00:26:29,680 --> 00:26:34,480
Почему будет неверно сделать
кавычки, привет, запятая, ответ, кавычки?

561
00:26:34,480 --> 00:26:35,155
Что вы сказали?

562
00:26:35,155 --> 00:26:36,400
Зрители: Это только выведет на экран answer.

563
00:26:36,400 --> 00:26:39,323
DAVID MALAN: Верно, этим мы буквально
скажем привет, запятая, answer. Верно?

564
00:26:39,323 --> 00:26:40,490
А это не то, что мы хотим.

565
00:26:40,490 --> 00:26:41,530
Мы не хотим сказать "привет answer"

566
00:26:41,530 --> 00:26:43,450
Мы хотим сказать: Привет, Дэвид 
или Привет, Брайан.

567
00:26:43,450 --> 00:26:45,280
Или привет любой, кто играет в эту программу.

568
00:26:45,280 --> 00:26:49,900
То есть я должен как то присоединить слово 
"привет" к тому, что введёт пользователь.

569
00:26:49,900 --> 00:26:53,335
То, как это делается с помощью printf,
немного отличается от Scratch.

570
00:26:53,335 --> 00:26:55,550
Мы будем использовать так называемый плейсхолдер.

571
00:26:55,550 --> 00:26:57,550
Вы буквально пишете
предложение или фразу,

572
00:26:57,550 --> 00:27:00,220
которую хотите сказать 
или вывести на экран,

573
00:27:00,220 --> 00:27:03,340
но заранее не знаете
значение этой фразы,

574
00:27:03,340 --> 00:27:08,570
поэтому вы используете плейсхолдер с помощью
знака процента и s, обозначающую string (строка).

575
00:27:08,570 --> 00:27:11,320
И это потому, что я пишу
программу сегодня.

576
00:27:11,320 --> 00:27:13,840
Я понятия не имею кто будет 
пользоваться ей завтра.

577
00:27:13,840 --> 00:27:15,910
Поэтому я хочу использовать
плейсхолдер,

578
00:27:15,910 --> 00:27:19,400
чтобы если кто-то запустит эту программу
завтра или в любой другой день,

579
00:27:19,400 --> 00:27:21,070
его имя вставлялось динамически.

580
00:27:21,070 --> 00:27:23,410
Сегодня я, конечно же, 
не знаю их имён.

581
00:27:23,410 --> 00:27:26,350
Поэтому кавычки, привет, запятая,
процент, s, кавычки.

582
00:27:26,350 --> 00:27:30,130
%s - это всего лишь плейсхолдер
для чего угодно, что я хочу вставить в это место.

583
00:27:30,130 --> 00:27:32,590
Бэкслеш n, конечно же,
означает переход на новую строку.

584
00:27:32,590 --> 00:27:35,590
Единственное, что в этой строке новое - 
это %s.

585
00:27:35,590 --> 00:27:39,490
Далее, оказыватся, что функции в С,
так же как в Scratch,

586
00:27:39,490 --> 00:27:40,990
могут не принимать аргументы.

587
00:27:40,990 --> 00:27:42,550
Или они могут принять один аргумент.

588
00:27:42,550 --> 00:27:44,650
Или они могут принять два или более аргументов.

589
00:27:44,650 --> 00:27:49,310
И если они могут принять два и более аргументов,
вы просто перечисляете их через запятую.

590
00:27:49,310 --> 00:27:50,450
Так работает printf.

591
00:27:50,450 --> 00:27:53,200
Вы знали бы это только если 
вас этому научили,

592
00:27:53,200 --> 00:27:55,720
или вы прочитали документацию.
Таким образом, вы можете

593
00:27:55,720 --> 00:27:59,560
передать одну строку
в качестве ввода:

594
00:27:59,560 --> 00:28:00,910
кавычки, что-либо, кавычки.

595
00:28:00,910 --> 00:28:03,010
Но если вы используете здесь
плейсхолдер,

596
00:28:03,010 --> 00:28:06,520
вы говорите компьютеру, 
что именно нужно подставить, добавляя запятую, 

597
00:28:06,520 --> 00:28:10,570
затем имя переменной, которую хотите
вставить.

598
00:28:10,570 --> 00:28:14,120
Эти две строчки кода эквивалентны
этим строчкам здесь.

599
00:28:14,120 --> 00:28:15,870
Но хотя на первый взгляд, 
может показаться,

600
00:28:15,870 --> 00:28:17,620
что это немного загадочно,
вы просто 

601
00:28:17,620 --> 00:28:19,480
разберете это до конца 
на отдельные компоненты

602
00:28:19,480 --> 00:28:23,020
справа налево и затем 
снаружи внутрь, 

603
00:28:23,020 --> 00:28:28,150
вы обычно можете сделать вывод даже о том, 
что делает новый код, который вы никогда 

604
00:28:28,150 --> 00:28:29,860
раньше не видели.

605
00:28:29,860 --> 00:28:33,880
Есть ли вопросы по этим 
двум строкам Scratch или по C?

606
00:28:33,880 --> 00:28:34,594
Да?

607
00:28:34,594 --> 00:28:36,570
АУДИТОРИЯ: Можно ли добавлять [неразборчиво]?

608
00:28:36,570 --> 00:28:40,220
...

609
00:28:40,220 --> 00:28:41,220
DAVID MALAN: Безусловно.

610
00:28:41,220 --> 00:28:42,450
Можно ли добавлять другие переменные?

611
00:28:42,450 --> 00:28:46,290
Если бы я имел больше переменных в этой
программе, благодаря большему количеству строк кода,

612
00:28:46,290 --> 00:28:49,740
Я мог бы написать: запятая, что-то
еще, запятая, что-то еще, запятая.

613
00:28:49,740 --> 00:28:52,620
И я бы просто взял один плейсхолдер
из этого выражения

614
00:28:52,620 --> 00:28:56,340
в кавычках для всех переменных,
которые я хочу подключить.

615
00:28:56,340 --> 00:28:57,670
И они будут идти слева направо.

616
00:28:57,670 --> 00:29:00,510
Итак, если бы я имел два %s здесь, 
то 

617
00:29:00,510 --> 00:29:01,890
первый бы шел после первой запятой.

618
00:29:01,890 --> 00:29:04,481
А второй шел бы после второй запятой.

619
00:29:04,481 --> 00:29:06,485
АУДИТОРИЯ: Так вам нужен %s [НЕРАЗБОРЧИВО]

620
00:29:06,485 --> 00:29:07,360
DAVID MALAN: Верно.

621
00:29:07,360 --> 00:29:10,962
Вам нужен %s после каждого плейсхолдера,
который вы хотите подключить если это срока.

622
00:29:10,962 --> 00:29:13,420
И мы собираемся увидеть остальные 
плейсхолдеры через мгновение.

623
00:29:13,420 --> 00:29:14,720
Хороший вопрос.

624
00:29:14,720 --> 00:29:16,464
Еще вопросы?

625
00:29:16,464 --> 00:29:17,230
Нет?

626
00:29:17,230 --> 00:29:18,440
Ах да, сзади.

627
00:29:18,440 --> 00:29:20,705
АУДИТОРИЯ: Есть ли другие способы 
конкатенации строк?

628
00:29:20,705 --> 00:29:23,080
DAVID MALAN: Есть ли другие способы 
конкатенации строк?

629
00:29:23,080 --> 00:29:26,533
Короткий ответ - да, много 
способов, но все они непростые.

630
00:29:26,533 --> 00:29:29,200
Мы займемся этим, вообще-то,
через пару недель.

631
00:29:29,200 --> 00:29:33,290
Printf, на данный момент, безусловно
самый простой способ сделать это.

632
00:29:33,290 --> 00:29:34,175
Еще вопросы?

633
00:29:34,175 --> 00:29:36,550
И если я когда-нибудь пропущу
ваши руки, то это из-за яркого света.

634
00:29:36,550 --> 00:29:37,510
Просто призови меня.

635
00:29:37,510 --> 00:29:38,200
Сюда.

636
00:29:38,200 --> 00:29:40,550
Ок, вы трое.

637
00:29:40,550 --> 00:29:41,571
Вон там справа.

638
00:29:41,571 --> 00:29:43,890
АУДИТОРИЯ: [НЕРАЗБОРЧИВО]

639
00:29:43,890 --> 00:29:44,640
DAVID MALAN: Уверен.

640
00:29:44,640 --> 00:29:45,420
Что такое строка?

641
00:29:45,420 --> 00:29:50,530
Строка это последовательность нулей
или других символов в двойных кавычках.

642
00:29:50,530 --> 00:29:54,060
Иными словами, это слово, фраза, 
предложение, абзац - ноль

643
00:29:54,060 --> 00:29:58,883
или больше символов, в алфавитном 
порядке, в двойных ковычках.

644
00:29:58,883 --> 00:29:59,550
Еще вопросы?

645
00:29:59,550 --> 00:30:01,100
Да?

646
00:30:01,100 --> 00:30:07,083
АУДИТОРИЯ: Что произойдет, если \n
окажется за пределами кавычек?

647
00:30:07,083 --> 00:30:08,500
DAVID MALAN: Действительно хороший вопрос.

648
00:30:08,500 --> 00:30:11,270
Что произойдет, если \n
окажется за пределами кавычек?

649
00:30:11,270 --> 00:30:12,210
Что ж, позвольте мне попробовать сделать это.

650
00:30:12,210 --> 00:30:14,210
И, честно говоря, это 
правильный подход.

651
00:30:14,210 --> 00:30:17,250
В любое время, двигаясь вперед, у вас будут 
возникать те же самые  инстинктивные вопросы,

652
00:30:17,250 --> 00:30:17,880
просто попробуйте это.

653
00:30:17,880 --> 00:30:19,770
Вы не сможете причинить времд компьютеру.

654
00:30:19,770 --> 00:30:22,170
Так что позвольте мне пойти вперед
и просто случайно, если хотите,

655
00:30:22,170 --> 00:30:24,510
ввести \n вне кавычек,

656
00:30:24,510 --> 00:30:25,978
ваш вопрос именно об этом, я полагаю.

657
00:30:25,978 --> 00:30:27,520
Окей, давайте посмотрим что произойдет.

658
00:30:27,520 --> 00:30:29,490
Так что я сейчас пойду и 
запущу Clang.

659
00:30:29,490 --> 00:30:31,470
Теперь я знаю, как сделать
нужное мне имя,

660
00:30:31,470 --> 00:30:34,380
поэтому воспользуюсь 
этим знанием: -o hello.

661
00:30:34,380 --> 00:30:36,720
И теперь я пойду 
дальше и говорю hello.c,

662
00:30:36,720 --> 00:30:38,940
который, я думаю, будет сломан.

663
00:30:38,940 --> 00:30:41,910
И в самом деле, что-то, 
действительно тут сломано.

664
00:30:41,910 --> 00:30:43,420
Давайте посмотрим в чем ошибка.

665
00:30:43,420 --> 00:30:48,210
И это тоже немного загадочно, 
но текст ошибки такой: hello.c двоеточие 5 двоеточие 26.

666
00:30:48,210 --> 00:30:49,240
Что здесь происходит?

667
00:30:49,240 --> 00:30:50,370
Давайте я уменьшу это.

668
00:30:50,370 --> 00:30:53,110
После любой сделаной ошибки в вашем коде
на подобии этой, 

669
00:30:53,110 --> 00:30:57,870
Clang попытается помочь вам выяснить
где эта ошибка или баг находятся.

670
00:30:57,870 --> 00:31:02,760
Надпись "colon 5" в hello.c означает
что вашу ошибку стоит искать в строке 5

671
00:31:02,760 --> 00:31:07,930
Далее, видите, там написана ошибка - ожидается
что круглые скобки будут закрыты прямо здесь.

672
00:31:07,930 --> 00:31:11,500
Так что это немного странно, потому что нет,
я не хочу закрывать скобки,

673
00:31:11,500 --> 00:31:12,000
Я думаю.

674
00:31:12,000 --> 00:31:13,170
Я хочу начать с новой строчки.

675
00:31:13,170 --> 00:31:16,080
Так что система не в состоянии
сказать вам, эй

676
00:31:16,080 --> 00:31:18,450
этот \n должен быть 
внутри кавычек

677
00:31:18,450 --> 00:31:21,780
Но это может в конечном счете помочь вам
выяснить где находится ошибка.

678
00:31:21,780 --> 00:31:24,000
И так, она где-то тут 
рядом, и в какой-то момент

679
00:31:24,000 --> 00:31:26,850
ваша собственная память или гугление
помогут вам понять,

680
00:31:26,850 --> 00:31:29,717
что да, это должно быть
снаружи кавычек.

681
00:31:29,717 --> 00:31:30,300
Хороший вопрос.

682
00:31:30,300 --> 00:31:31,883
Был ли там еще третий вопрос?

683
00:31:31,883 --> 00:31:32,430
Да?

684
00:31:32,430 --> 00:31:32,930
Нет?

685
00:31:32,930 --> 00:31:33,480
OK.

686
00:31:33,480 --> 00:31:37,860
Итак, давайте перейдем к нескольким
другим функциям

687
00:31:37,860 --> 00:31:39,360
которые мы также можем сделать - 

688
00:31:39,360 --> 00:31:42,630
а именно, реализуем ту же самую программу,
которая у меня только что была.

689
00:31:42,630 --> 00:31:45,600
Позвольте мне продолжить и закрыть этот
файл, а затем создать новый,

690
00:31:45,600 --> 00:31:49,173
скажем, string.c, потому что я сейчас
эксперементирую со строками.

691
00:31:49,173 --> 00:31:50,590
И я собираюсь начать как и раньше - 

692
00:31:50,590 --> 00:31:55,260
с #include <stdio.h> 
int main(void)

693
00:31:55,260 --> 00:32:01,470
А потом я собираюсь пойти дальше и 
сказать string answer равно get_string,

694
00:32:01,470 --> 00:32:07,020
скобка открывается, кавычка, 
как тебя зовут, знак вопроса, \n, кавычка, скобка и ;

695
00:32:07,020 --> 00:32:09,448
И в качестве отступления, все, 
что я печатал на клавиатуре сегодня,

696
00:32:09,448 --> 00:32:11,490
позже мы разместим на сайте курса.

697
00:32:11,490 --> 00:32:15,010
Так что нет необходимости набирать 
каждый маленький символ, если вы не хотите.

698
00:32:15,010 --> 00:32:18,448
И затем я продолжаю и пишу printf,
открываю ковычки, hello answer. 

699
00:32:18,448 --> 00:32:20,490
Не answer, потому что мы 
утверждали, что это плохо.

700
00:32:20,490 --> 00:32:22,440
Он буквально скажет "answer".


701
00:32:22,440 --> 00:32:24,750
Я хочу сделать плейсхолдер, процент и s.

702
00:32:24,750 --> 00:32:29,920
И теперь обратный слеш n,
запятая, answer, точка с запятой.

703
00:32:29,920 --> 00:32:32,910
Так что я думаю я перевел
код со слайда

704
00:32:32,910 --> 00:32:37,920
в мое программное окружение, он теперь
в файле, по имени string.c.

705
00:32:37,920 --> 00:32:39,300
Так что давайте я уменьшу.

706
00:32:39,300 --> 00:32:41,790
И если я хочу скомпилировать
программу, превратить ее

707
00:32:41,790 --> 00:32:46,795
из исходного кода в машинный код,
что мне нужно тут написать?

708
00:32:46,795 --> 00:32:47,295
Clang.

709
00:32:47,295 --> 00:32:50,150


710
00:32:50,150 --> 00:32:51,210
string.c.

711
00:32:51,210 --> 00:32:53,590
Но он даст мне программу,
которая по умолчанию зовется

712
00:32:53,590 --> 00:32:56,030
a.out, что не очень то понятно.

713
00:32:56,030 --> 00:32:58,670
Так что давайте я сделаю
-o string, чтобы моя программа

714
00:32:58,670 --> 00:33:00,230
называлась string.

715
00:33:00,230 --> 00:33:02,090
Но я могу ее назвать как хочу.

716
00:33:02,090 --> 00:33:04,975
Я могу назвать ее
"программа два", если мне угодно.

717
00:33:04,975 --> 00:33:06,350
Так что давайте нажмем Enter.

718
00:33:06,350 --> 00:33:10,220
И боже мой, ошибок больше
чем строчек кода,

719
00:33:10,220 --> 00:33:12,320
что немного тревожно.

720
00:33:12,320 --> 00:33:15,530
И это второй уровень, где вы
должны расслабиться, так что это значит

721
00:33:15,530 --> 00:33:17,113
что компьютер чего то не понял, верно?

722
00:33:17,113 --> 00:33:20,480
Вы не можете быть так плохи в программировании,
чтобы сделать больше ошибок чем строчек кода

723
00:33:20,480 --> 00:33:21,860
который вы написали.

724
00:33:21,860 --> 00:33:25,370
Так что реально компьютер просто
запутался где то,

725
00:33:25,370 --> 00:33:28,670
и начинает спотыкаться о собственные
ноги, говоря образно.

726
00:33:28,670 --> 00:33:31,910
Он не знает где ошибка, и начинает
неправильно интерпретировать правильный код

727
00:33:31,910 --> 00:33:33,020
как неправильный.

728
00:33:33,020 --> 00:33:38,100
Так что нужно начинать всегда с первой
ошибки.

729
00:33:38,100 --> 00:33:41,450
Вы могли заметить, что я уже проскроллил
на самый верх вывода команды

730
00:33:41,450 --> 00:33:44,570
которую я напечатал, вот тут, где
подсвечено.

731
00:33:44,570 --> 00:33:47,270
Сфокусируйтесь на первой ошибке,
может остальные

732
00:33:47,270 --> 00:33:50,985
просто "фантомные" ошибки.

733
00:33:50,985 --> 00:33:53,360
Так что давайте приблизим
эту часть экрана

734
00:33:53,360 --> 00:33:55,700
и посмотрим что мы можем с ней сделать.

735
00:33:55,700 --> 00:33:59,420
Команда которую я запустил:
Clang -o string string.c.

736
00:33:59,420 --> 00:34:02,480
И это значит что мой входной параметр
это исходный код в string.c.

737
00:34:02,480 --> 00:34:06,500
Я хочу чтобы вывод был машинным кодом
в файл по имени string.

738
00:34:06,500 --> 00:34:09,409
Итак, ошибка начинается в
string.c на пятой строчке,

739
00:34:09,409 --> 00:34:11,540
и это очень знакомое нам место.

740
00:34:11,540 --> 00:34:13,820
Использование неопределенного идентификатора string.

741
00:34:13,820 --> 00:34:19,960
Вы имели в виду-- ожидается-- stdin?

742
00:34:19,960 --> 00:34:21,280
Не, я не это имел в виду.

743
00:34:21,280 --> 00:34:22,600
Я имел в виду string в этом случае.

744
00:34:22,600 --> 00:34:25,159
И вот здесь, тоже,
компьютер запутался,

745
00:34:25,159 --> 00:34:28,179
и даже зеленое сообщение с помощью,
не очень то помогает.

746
00:34:28,179 --> 00:34:29,679
Нет, я хочу string.

747
00:34:29,679 --> 00:34:31,270
Я не хочу стандартный in.

748
00:34:31,270 --> 00:34:34,060
Но причина для ошибки
в том, что технически

749
00:34:34,060 --> 00:34:37,420
во всяком случае, сейчас,
нет такой вещи как string,

750
00:34:37,420 --> 00:34:41,699
S-T-R-I-N-G в Си. Это реально
иллюстративный пример, который

751
00:34:41,699 --> 00:34:44,949
мы будет использовать пару недель, пока, отвечая
на ваш вопрос,

752
00:34:44,949 --> 00:34:48,340
мы не покажем, что реально происходит
"под капотом" у компьютера,

753
00:34:48,340 --> 00:34:51,130
и то что происходит, чтобы
имплементировать string.

754
00:34:51,130 --> 00:34:56,620
Так вот, string это штука,
которую курс CS50 вам дает

755
00:34:56,620 --> 00:35:01,570
в файле под названием CS50.h

756
00:35:01,570 --> 00:35:06,355
Так же как файл под названием
стандартный I/O--

757
00:35:06,355 --> 00:35:10,330
где I/O значит ввод(input)/вывод(output),
типа печатать строчку, получить строчку из ввода.

758
00:35:10,330 --> 00:35:16,060
Как здесь, в файле stdio.h,
где обьявлен printf,

759
00:35:16,060 --> 00:35:19,420
все функции, которые я буду
использовать в этой программе,

760
00:35:19,420 --> 00:35:25,000
типа get_string, они хранятся
в файле CS50.h

761
00:35:25,000 --> 00:35:28,150
Так что моя ошибка просто подняла
проблему, когда я компилировал этот код,

762
00:35:28,150 --> 00:35:30,640
компьютер не имел
никакого понятия что такое string.

763
00:35:30,640 --> 00:35:34,870
И не понимает-- мы увидим это
что такое get_string.

764
00:35:34,870 --> 00:35:37,570
Так что давайте я перекомпилирую
это сейчас.

765
00:35:37,570 --> 00:35:46,130
Я печатаю Clang -o string string.c
и приближаю.

766
00:35:46,130 --> 00:35:46,630
Отлично.

767
00:35:46,630 --> 00:35:47,820
Enter.

768
00:35:47,820 --> 00:35:49,930
OK, выполняется.

769
00:35:49,930 --> 00:35:51,100
Все еще баг.

770
00:35:51,100 --> 00:35:53,230
Тут ошибка, потому что красный
цвет не может

771
00:35:53,230 --> 00:35:54,850
значить ничего хорошего, в этом контексте.

772
00:35:54,850 --> 00:35:56,590
Ну да, точно, это ошибка.

773
00:35:56,590 --> 00:35:58,940
Но их число намного меньше.

774
00:35:58,940 --> 00:36:02,080
Так что время последнего набора команд,
про который мы поговорим сейчас.

775
00:36:02,080 --> 00:36:04,240
Обратите внимание, что нам говорит сообщение об ошибке.

776
00:36:04,240 --> 00:36:07,450
После того как я запустил Clang -o
string string.c, тут

777
00:36:07,450 --> 00:36:09,490
все еще проблема в моей функции main.

778
00:36:09,490 --> 00:36:11,170
Какая проблема?

779
00:36:11,170 --> 00:36:13,480
Неопределенная ссылка на get_string.

780
00:36:13,480 --> 00:36:18,490
Так что получается, когда вы используете
библиотеку CS50, вам нужно сделать две вещи.

781
00:36:18,490 --> 00:36:21,100
В исходниках, вы должны сказать
компьютеру

782
00:36:21,100 --> 00:36:23,800
включить этот файл
CS50.h, где, снова,

783
00:36:23,800 --> 00:36:26,860
функции подобные get_string
и слово string

784
00:36:26,860 --> 00:36:28,870
уже созданы для вас.

785
00:36:28,870 --> 00:36:32,170
Но когда вы компилируете код,
вам нужно, наверное немного избыточно,

786
00:36:32,170 --> 00:36:37,060
но по другим причинам, сказать компьютеру
чтобы он добавил весь этот код

787
00:36:37,060 --> 00:36:40,600
который сотрудники CS50 написали, чтобы
создать get_string и string

788
00:36:40,600 --> 00:36:44,110
и другие функции, подобные им.

789
00:36:44,110 --> 00:36:50,530
Поэтому я напишу Clang
-o string string.c, точно как только что,

790
00:36:50,530 --> 00:36:54,400
но надо дать компьютеру эту
специальную инструкцию

791
00:36:54,400 --> 00:36:56,410
чтобы слинковать с CS50.

792
00:36:56,410 --> 00:36:59,320
И вы поймете зачем, в течение
следующих двух недель

793
00:36:59,320 --> 00:37:02,620
Но пока это просто -l для линкования и CS50.

794
00:37:02,620 --> 00:37:04,720
И все вот это говорит
компьютеру, что

795
00:37:04,720 --> 00:37:10,550
единицы и нули моей программы, должны
придти из string.c прямо

796
00:37:10,550 --> 00:37:11,050
сюда.

797
00:37:11,050 --> 00:37:12,400
Это мой исходный код.

798
00:37:12,400 --> 00:37:16,780
Но сотрудники CS50, годы назад,
также написали код для Си, чтобы

799
00:37:16,780 --> 00:37:19,420
дать вам функции get_string
и другие, чтобы

800
00:37:19,420 --> 00:37:22,390
у вас были переменные, такие как строки.

801
00:37:22,390 --> 00:37:27,070
Нули и единицы из библиотеки CS50
хранятся где-то в облаке,

802
00:37:27,070 --> 00:37:29,920
и их нужно как-то связать
вместе с вашими.

803
00:37:29,920 --> 00:37:34,000
Подобно тому, как ваш код находится
в этом файле, наш код находится в другом.

804
00:37:34,000 --> 00:37:37,330
Указание компьютеру включить его
в ваш исходный код

805
00:37:37,330 --> 00:37:40,980
и связать его с помощью данной команды —
всего лишь магический способ сказать:

806
00:37:40,980 --> 00:37:46,930
"соедини мой код с кодом из CS50 в одну
программу, которую я могу запустить".

807
00:37:46,930 --> 00:37:49,180
Так. Всё это, если честно,
начинает становиться

808
00:37:49,180 --> 00:37:53,170
крайне сложным. Я бы даже сказал,
неоправданно сложным.

809
00:37:53,170 --> 00:37:56,200
Поэтому есть способ получше.

810
00:37:56,200 --> 00:38:00,310
Оказывается, что для компиляции кода

811
00:38:00,310 --> 00:38:01,720
вам не нужно запоминать команду "-o".

812
00:38:01,720 --> 00:38:03,935
Как и команду "-l CS50".

813
00:38:03,935 --> 00:38:07,060
Вам не нужна ни одна из этих команд,
разве что понимание основной идеи.

814
00:38:07,060 --> 00:38:12,130
Вместо этого вы можете сказать: "создай
программу под названием "string" — и всё.

815
00:38:12,130 --> 00:38:15,970
Весь этот вывод будет
сгенерирован автоматически,

816
00:38:15,970 --> 00:38:18,610
когда вы дадите компьютеру
команду на сборку программы.

817
00:38:18,610 --> 00:38:24,130
И программа сборки (make) сама разберётся,
какие аргументы командной строки нужно использовать,

818
00:38:24,130 --> 00:38:26,800
какое имя присвоить файлу,
с какими библиотеками

819
00:38:26,800 --> 00:38:29,650
или чужими кусочками кода необходимо
связать программу.

820
00:38:29,650 --> 00:38:32,500
Таким образом, чтобы скомпилировать
программу,

821
00:38:32,500 --> 00:38:36,460
вам достаточно буквально сказать "сделай" (make)
и указать имя программы.

822
00:38:36,460 --> 00:38:38,680
Но выглядеть это должно не как "make string.c",

823
00:38:38,680 --> 00:38:41,260
а как "make" и имя программы.

824
00:38:41,260 --> 00:38:43,180
Make, то есть внешняя программа,
сама поймёт,

825
00:38:43,180 --> 00:38:46,630
что вы имели в виду что-то с именем string.c.

826
00:38:46,630 --> 00:38:48,910
Можно вернуться назад и проделать это
для программы hello.

827
00:38:48,910 --> 00:38:50,770
Make hello.

828
00:38:50,770 --> 00:38:53,150
Ой, я так и не исправил старую ошибку.

829
00:38:53,150 --> 00:38:56,660
Давайте-ка я открою файл hello.c

830
00:38:56,660 --> 00:38:59,740
и исправлю это для потомков.

831
00:38:59,740 --> 00:39:02,110
Сохраню файл или включу автосохранение.

832
00:39:02,110 --> 00:39:03,310
А теперь — make hello.

833
00:39:03,310 --> 00:39:06,100
И вуаля — всё то же самое.

834
00:39:06,100 --> 00:39:06,820
Да?

835
00:39:06,820 --> 00:39:09,543
ЗАЛ: Является ли make стандартной
программой?

836
00:39:09,543 --> 00:39:10,960
DAVID MALAN: Очень хороший вопрос.

837
00:39:10,960 --> 00:39:13,300
Является ли make стандартной
или же она специфична для CS50?

838
00:39:13,300 --> 00:39:16,280
Нет, она не специфична для CS50.

839
00:39:16,280 --> 00:39:19,460
Это стандартное средство,
которое есть на компьютерах,

840
00:39:19,460 --> 00:39:21,410
как правило под управлением ОС Unix или Linux.

841
00:39:21,410 --> 00:39:24,020
И действительно, инструмент песочницы,
который мы используем,

842
00:39:24,020 --> 00:39:26,480
сам по себе является компьютером в облаке,
хотя у него

843
00:39:26,480 --> 00:39:30,960
есть только эти два окна, вкладки сверху
и окно терминала снизу.

844
00:39:30,960 --> 00:39:32,960
Выполнив вход в песочницу "CS50 Sandbox",
вы получаете доступ

845
00:39:32,960 --> 00:39:36,620
к собственному серверу в облаке
под управлением операционной системы Linux.

846
00:39:36,620 --> 00:39:41,600
А Clang, make и прочие инструменты, которые
мы используем, такие как ls и rm,

847
00:39:41,600 --> 00:39:43,700
все существуют в операционной системе.

848
00:39:43,700 --> 00:39:46,580
Они совсем не специфичны для CS50.

849
00:39:46,580 --> 00:39:47,768
Спрашивайте.

850
00:39:47,768 --> 00:39:51,235
ЗАЛ: Получается, программа hello
будет машинным кодом, а не [НЕРАЗБОРЧИВО]?

851
00:39:51,235 --> 00:39:52,110
DAVID MALAN: Правильно.

852
00:39:52,110 --> 00:39:53,520
Hello — это машинный код.

853
00:39:53,520 --> 00:39:55,756
Hello.c — это исходный код.

854
00:39:55,756 --> 00:39:57,244
ЗАЛ: То есть [НЕРАЗБОРЧИВО]?

855
00:39:57,244 --> 00:40:00,915


856
00:40:00,915 --> 00:40:01,790
DAVID MALAN: Верно.

857
00:40:01,790 --> 00:40:06,110
Make — умная программа, предназначенная
для облегчения нашей жизни.

858
00:40:06,110 --> 00:40:11,210
Если выполнить команду "make hello",
она будет искать файл с именем hello.c.

859
00:40:11,210 --> 00:40:14,450
И если найдёт — создаст программу
с именем "hello",

860
00:40:14,450 --> 00:40:16,630
превратив исходный код в, соответственно, машинный.

861
00:40:16,630 --> 00:40:17,267
У вас вопрос?

862
00:40:17,267 --> 00:40:18,698
ЗАЛ: [НЕРАЗБОРЧИВО].

863
00:40:18,698 --> 00:40:22,498


864
00:40:22,498 --> 00:40:23,540
DAVID MALAN: Не совсем.

865
00:40:23,540 --> 00:40:27,770
Программа make ранее входила в состав
операционных систем семейства Linux,

866
00:40:27,770 --> 00:40:29,150
а также семейства Mac OS.

867
00:40:29,150 --> 00:40:31,160
В настоящее время она есть и в
составе систем семейства Windows.

868
00:40:31,160 --> 00:40:34,040
Программу make запускают
путём ввода её имени,

869
00:40:34,040 --> 00:40:37,147
а не двойным щелчком по значку.

870
00:40:37,147 --> 00:40:37,730
Хороший вопрос.

871
00:40:37,730 --> 00:40:38,882
Да-да?

872
00:40:38,882 --> 00:40:39,854
ЗАЛ: [НЕРАЗБОРЧИВО]?

873
00:40:39,854 --> 00:40:43,755


874
00:40:43,755 --> 00:40:44,880
DAVID MALAN: Это тоже хороший вопрос.

875
00:40:44,880 --> 00:40:46,610
Хранится ли программа make
на вашем компьютере

876
00:40:46,610 --> 00:40:47,930
или на облачной машине?

877
00:40:47,930 --> 00:40:49,350
Второе. В облаке.

878
00:40:49,350 --> 00:40:52,100
На данном этапе семестра и в течение
первых нескольких недель

879
00:40:52,100 --> 00:40:55,310
всё, что мы будем делать, будет находиться
в облачной стандартизированной среде

880
00:40:55,310 --> 00:40:58,670
под названием "CS50 Sandbox",
а чуть позже — в среде "CS50 Lab".

881
00:40:58,670 --> 00:41:02,780
Но эта среда призвана представлять собой
обычный компьютер на Linux,

882
00:41:02,780 --> 00:41:04,210
Mac OS или другой системе.

883
00:41:04,210 --> 00:41:05,960
Однако программное обеспечение всё равно
немного отличается,

884
00:41:05,960 --> 00:41:09,470
поэтому мы ориентируемся на Linux
как на крайне популярную систему

885
00:41:09,470 --> 00:41:12,140
среди разработчиков программного обеспечения.

886
00:41:12,140 --> 00:41:15,265
Ладно, давайте теперь посмотрим на пару
других равнозначностей, затем —

887
00:41:15,265 --> 00:41:18,015
сравнений, а после приступим к написанию
более интересных программ,

888
00:41:18,015 --> 00:41:19,220
чем банальные "hello world".

889
00:41:19,220 --> 00:41:22,400
Здесь ещё раз приведено
краткое описание способа

890
00:41:22,400 --> 00:41:25,070
преобразования исходного кода
в машинный

891
00:41:25,070 --> 00:41:28,580
с помощью программы Clang и
аргумента командной строки,

892
00:41:28,580 --> 00:41:33,322
специального параметра, -o hello,
который позволяет задать имя для файла.

893
00:41:33,322 --> 00:41:35,780
Поверьте мне, никто и никогда
не запомнит эту команду.

894
00:41:35,780 --> 00:41:37,905
А даже если вы это сделаете, печатать её
каждый раз очень утомительно.

895
00:41:37,905 --> 00:41:40,250
Именно поэтому существуют такие программы,
как make, которые

896
00:41:40,250 --> 00:41:42,142
автоматизируют весь этот процесс.

897
00:41:42,142 --> 00:41:43,850
Но делают-то они всё то же самое--

898
00:41:43,850 --> 00:41:46,700
компилируют исходный код в машинный.

899
00:41:46,700 --> 00:41:48,500
Для последующего запуска программы
мы вводим

900
00:41:48,500 --> 00:41:50,920
точку, которая соответствует
текущему каталогу,

901
00:41:50,920 --> 00:41:54,140
потому что, как мы увидим далее, на сервере
может быть множество каталогов, а затем hello,

902
00:41:54,140 --> 00:41:55,510
то есть имя программы.

903
00:41:55,510 --> 00:41:58,760
Хорошо, давайте разберём пару
других особенностей Scratch

904
00:41:58,760 --> 00:42:00,510
и то, как они будут выглядеть в Си,

905
00:42:00,510 --> 00:42:04,560
а затем начнём реализовывать на Си
более сложные программы.

906
00:42:04,560 --> 00:42:07,130
Рассмотрим вот такой пример.
Какой тип функционала

907
00:42:07,130 --> 00:42:11,450
он демонстрировал в Scratch?

908
00:42:11,450 --> 00:42:13,300
Что он позволял делать?

909
00:42:13,300 --> 00:42:14,260
ЗАЛ: Это переменная.

910
00:42:14,260 --> 00:42:16,000
DAVID MALAN: Это был
пример переменной.

911
00:42:16,000 --> 00:42:18,167
И эта переменная, в данном случае,
называлась counter (счётчик).

912
00:42:18,167 --> 00:42:21,130
Мы инициализировали её-- то есть,
установили её равной-- нулём.

913
00:42:21,130 --> 00:42:24,220
В Си (справа на экране), чтобы
добиться того же результата,

914
00:42:24,220 --> 00:42:27,190
нужно написать буквально следующее:
переменная (например,

915
00:42:27,190 --> 00:42:30,490
counter, но в целом это может быть
любое имя) равна нулю.

916
00:42:30,490 --> 00:42:33,198
Как мы помним, знак равенства —
это оператор присваивания.

917
00:42:33,198 --> 00:42:34,990
Поэтому то, что находится справа
от него, будет

918
00:42:34,990 --> 00:42:37,210
скопировано в то, что находится слева.

919
00:42:37,210 --> 00:42:41,200
Однако этого недостаточно, потому что
когда вы объявляете переменную

920
00:42:41,200 --> 00:42:44,230
и говорите: "Эй, компьютер, мне нужно
немного места для кое-какого значения",

921
00:42:44,230 --> 00:42:47,950
вы должны явно указать компьютеру
тип этой переменной.

922
00:42:47,950 --> 00:42:52,000
Мы знаем, что строки — это переменные,
хранящие набор слов.

923
00:42:52,000 --> 00:42:55,000
Но в данном случае мы хотим
хранить число.

924
00:42:55,000 --> 00:42:58,390
Поэтому в Си такой тип чисел называется
int или integer.

925
00:42:58,390 --> 00:43:00,070
I-N-T — для краткости.

926
00:43:00,070 --> 00:43:02,147
Кстати, в этой строке кода
кое-чего не хватает.

927
00:43:02,147 --> 00:43:02,980
ЗАЛ: Точки с запятой.

928
00:43:02,980 --> 00:43:03,610
DAVID MALAN: Да, точки с запятой.

929
00:43:03,610 --> 00:43:04,840
Иначе мысль не завершена.

930
00:43:04,840 --> 00:43:05,830
Что это всё значит?

931
00:43:05,830 --> 00:43:10,270
Эй, компьютер, дай мне переменную
с целочисленным типом (типом int).

932
00:43:10,270 --> 00:43:15,280
Назови её counter и помести в неё
нулевое значение

933
00:43:15,280 --> 00:43:19,970
по умолчанию. Оказывается, мы можем
делать и другие вещи с переменными.

934
00:43:19,970 --> 00:43:23,460
Например, вот так в Scratch
у нас реализовано приращение.

935
00:43:23,460 --> 00:43:27,080
Мы изменяем значение счётчика на единицу,
прибавляя 1 к переменной.

936
00:43:27,080 --> 00:43:28,510
А как сделать это в Си?

937
00:43:28,510 --> 00:43:30,800
В Си это выглядело бы примерно так.

938
00:43:30,800 --> 00:43:35,110
С точки зрения алгебры выглядит
немного парадоксально,

939
00:43:35,110 --> 00:43:38,110
потому что как может значение counter
быть равным counter + 1?

940
00:43:38,110 --> 00:43:39,560
Только вот это не равенство.

941
00:43:39,560 --> 00:43:41,780
Это присваивание справа налево.

942
00:43:41,780 --> 00:43:43,780
То есть, с левой стороны у нас counter.

943
00:43:43,780 --> 00:43:45,190
Имя переменной.

944
00:43:45,190 --> 00:43:47,500
С правой стороны — counter + 1,

945
00:43:47,500 --> 00:43:49,390
чему бы это выражение ни было равно.

946
00:43:49,390 --> 00:43:53,260
И мы копируем значение counter + 1
в переменную counter.

947
00:43:53,260 --> 00:43:56,420
У меня тут опять чего-то не хватает.
Точки с запятой.

948
00:43:56,420 --> 00:44:00,580
Но в этом примере мне уже
не нужно писать int.

949
00:44:00,580 --> 00:44:05,200
На этом этапе предполагается,
что counter существует

950
00:44:05,200 --> 00:44:08,020
и что я использовал подобную
предыдущей строку кода

951
00:44:08,020 --> 00:44:10,270
в каком-то другом месте программы.

952
00:44:10,270 --> 00:44:13,330
Ведь это разовое указание для компьютера:
"дай мне переменную с именем counter

953
00:44:13,330 --> 00:44:14,950
и позволь мне хранить в ней значения int".

954
00:44:14,950 --> 00:44:17,110
Данная строка кода предполагает,
что counter уже существует

955
00:44:17,110 --> 00:44:20,410
и что нам больше не нужно
ничего говорить про int.

956
00:44:20,410 --> 00:44:22,060
Мы это указываем всего один раз.

957
00:44:22,060 --> 00:44:24,040
Так, нам всё ещё нужна точка с запятой.

958
00:44:24,040 --> 00:44:26,680
Но если честно, это крайне типичная
операция в программировании.

959
00:44:26,680 --> 00:44:28,930
В смысле, приращение значения переменной.

960
00:44:28,930 --> 00:44:31,280
И оказывается, что сделать это можно
разными способами.

961
00:44:31,280 --> 00:44:33,520
Можно вместо этого сделать вот так--

962
00:44:33,520 --> 00:44:36,250
counter плюс-равно 1, точка с запятой.

963
00:44:36,250 --> 00:44:37,800
Это буквально то же самое.

964
00:44:37,800 --> 00:44:39,550
А если и это для вас слишком длинно,

965
00:44:39,550 --> 00:44:42,910
вы можете написать так:
counter плюс-плюс, точка с запятой,

966
00:44:42,910 --> 00:44:44,500
и это по-прежнему всё та же операция.

967
00:44:44,500 --> 00:44:47,650
В программировании такие вещи
называются синтаксическим сахаром.

968
00:44:47,650 --> 00:44:51,110
Они не добавляют уникального функционала,
который нельзя было бы реализовать иначе.

969
00:44:51,110 --> 00:44:53,800
Но они зачастую делают код более
красивым и лаконичным.

970
00:44:53,800 --> 00:44:56,680
Поэтому чаще пишут именно так.

971
00:44:56,680 --> 00:44:58,430
Хорошо, давайте рассмотрим
другой пример.

972
00:44:58,430 --> 00:45:01,750
Как это называлось в Scratch?

973
00:45:01,750 --> 00:45:03,980
Точно, условие. Решение,
которое нужно принять.

974
00:45:03,980 --> 00:45:06,310
Если что-то истинно — сделай это.

975
00:45:06,310 --> 00:45:08,720
В Си это выглядит следующим образом.

976
00:45:08,720 --> 00:45:11,260
Если x меньше y (в скобках)--

977
00:45:11,260 --> 00:45:15,300
да, они не очень похожи на вот эту
зелёную угловатую фигуру, но в Си

978
00:45:15,300 --> 00:45:16,780
мы используем скобки.

979
00:45:16,780 --> 00:45:20,380
Итак, если x меньше y (скобка
открывается, скобка закрывается),

980
00:45:20,380 --> 00:45:21,970
то — выполнить следующее.

981
00:45:21,970 --> 00:45:25,720
И так же, как этот жёлто-оранжевый
кусочек паззла как будто

982
00:45:25,720 --> 00:45:29,920
обнимает фиолетовый кусочек,
эта открывающая фигурная скобка

983
00:45:29,920 --> 00:45:32,830
и эта закрывающая фигурная скобка,
так сказать,

984
00:45:32,830 --> 00:45:36,050
готовы "обнять" или инкапсулировать
одну или несколько строк кода.

985
00:45:36,050 --> 00:45:37,090
Что это может быть за строка?

986
00:45:37,090 --> 00:45:42,640
Например, что-то такое--
printf, x меньше y, обратная косая черта, n.

987
00:45:42,640 --> 00:45:47,080
И снова новый синтаксис, но
фигурные скобки мы уже видели

988
00:45:47,080 --> 00:45:48,490
в контексте функции main.

989
00:45:48,490 --> 00:45:52,280
А круглые скобки мы видели,
когда говорили про входные значения.

990
00:45:52,280 --> 00:45:54,520
Так что это просто своего рода
шаблон языка Си, который

991
00:45:54,520 --> 00:45:58,530
мы будем использовать при каждой
операции с условием.

992
00:45:58,530 --> 00:46:01,000
Ладно, в Scratch мы видели вот такое--

993
00:46:01,000 --> 00:46:04,300
если x меньше y, то
вывести на экран "x меньше, чем y".

994
00:46:04,300 --> 00:46:06,730
Иначе вывести "x не меньше, чем y".

995
00:46:06,730 --> 00:46:11,380
В Си такая конструкция выглядит почти
так же, разве что добавляется блок else,

996
00:46:11,380 --> 00:46:15,010
и в итоге у нас два набора фигурных скобок,
готовых "обнять"

997
00:46:15,010 --> 00:46:16,600
код между ними.

998
00:46:16,600 --> 00:46:19,660
А затем нам остаётся буквально
"вставить" наши переводы в printf,

999
00:46:19,660 --> 00:46:25,060
написав printf, "x меньше, чем y", или же
printf, "x не меньше, чем y".

1000
00:46:25,060 --> 00:46:28,450
Заметьте, в этом примере
только две точки с запятой

1001
00:46:28,450 --> 00:46:33,430
Нет необходимости заканчивать условия
точками с запятой

1002
00:46:33,430 --> 00:46:37,690
Точки с запятой заканчивают функции
или строки, включающие функции

1003
00:46:37,690 --> 00:46:39,850
Как правило, 

1004
00:46:39,850 --> 00:46:42,490
вам не нужны точки с запятой

1005
00:46:42,490 --> 00:46:43,870
после каждой строчки кода.

1006
00:46:43,870 --> 00:46:45,855
Они необходимы после какого-то действия.

1007
00:46:45,855 --> 00:46:48,730
Вы начнете понимать этот паттерн,
даже если это

1008
00:46:48,730 --> 00:46:50,560
не слишком очевидно в начале.

1009
00:46:50,560 --> 00:46:52,260
А что насчет этого,

1010
00:46:52,260 --> 00:46:55,090
If, else if, else if.

1011
00:46:55,090 --> 00:46:58,900
Заметьте, мы переиспользуем
if блок от if-else и другой

1012
00:46:58,900 --> 00:47:00,250
if блок вот тут.

1013
00:47:00,250 --> 00:47:02,500
Оказывается, в Си это
даже немножко легче.

1014
00:47:02,500 --> 00:47:04,120
Можно буквально сказать вот так --

1015
00:47:04,120 --> 00:47:07,060
Если икс меньше, чем игрек, выполни
код внутри этих фигурных скобок

1016
00:47:07,060 --> 00:47:10,220
Иначе, если икс больше, чем игрек,
выполни блок в этих фигурных скобках

1017
00:47:10,220 --> 00:47:14,160
Иначе, если икс равен игрек, 
выполни этот блок.

1018
00:47:14,160 --> 00:47:16,050
И что мы хотим делать в каждом из случаев?

1019
00:47:16,050 --> 00:47:20,560
Вывести на экран сообщение 
в соответствии с каждым случаем

1020
00:47:20,560 --> 00:47:23,220
Но есть один интересный момент.

1021
00:47:23,220 --> 00:47:26,550
Выглядит как опечатка

1022
00:47:26,550 --> 00:47:28,278
Да, двойной знак равно

1023
00:47:28,278 --> 00:47:29,070
Но это не баг!

1024
00:47:29,070 --> 00:47:29,940
Это не ошибка.

1025
00:47:29,940 --> 00:47:35,070
Почему я здесь использую двойной
знак равно, а не одинарный,

1026
00:47:35,070 --> 00:47:36,990
как в Scratch?

1027
00:47:36,990 --> 00:47:37,980
Давайте посмотрим сюда.

1028
00:47:37,980 --> 00:47:38,687
Да?

1029
00:47:38,687 --> 00:47:42,335
Зал: [НЕРАЗБОРЧИВО].

1030
00:47:42,335 --> 00:47:43,210
DAVID MALAN: Именно.

1031
00:47:43,210 --> 00:47:46,420
Я уже говорил что один знак равенства
означает присвоение справа

1032
00:47:46,420 --> 00:47:47,140
налево.

1033
00:47:47,140 --> 00:47:49,120
И, если честно,
это такая ситуация

1034
00:47:49,120 --> 00:47:50,590
когда мы сами себя загнали в угол

1035
00:47:50,590 --> 00:47:53,050
Мы уже используем знак 
равенства для присвоения

1036
00:47:53,050 --> 00:47:56,570
Однажды кто-то осознал, 
как мы теперь сравним

1037
00:47:56,570 --> 00:47:57,808
равно ли одно другому?!

1038
00:47:57,808 --> 00:47:59,350
Мы же уже использовали 
символ сравнения

1039
00:47:59,350 --> 00:48:01,510
Так что люди решили,
десятки лет назад,

1040
00:48:01,510 --> 00:48:05,200
что мы просто будем использовать
два знака равно для сравнения

1041
00:48:05,200 --> 00:48:07,690
это так называемый
оператор равенства.

1042
00:48:07,690 --> 00:48:09,633
Один знак равенства
это просто присвоение.

1043
00:48:09,633 --> 00:48:12,550
Это одна из самых частых
ошибок у новичков,

1044
00:48:12,550 --> 00:48:15,730
особенно если раньше вы использовали
Scratch и другие подобные языки.

1045
00:48:15,730 --> 00:48:18,880
Так что просто нужно со временем
наработать мышечную память.

1046
00:48:18,880 --> 00:48:22,030
Совершите эту ошибку несколько раз
и привыкнете писать правильно.

1047
00:48:22,030 --> 00:48:24,010
Хорошо, оказывается, 
что наша программа,

1048
00:48:24,010 --> 00:48:26,530
более-менее правильная -- 
точнее, этот код, в целом верный

1049
00:48:26,530 --> 00:48:30,340
сделает это, это или это
-- И я думаю, что это

1050
00:48:30,340 --> 00:48:31,960
все возможные ситуации

1051
00:48:31,960 --> 00:48:37,090
Если у вас два целых числа, икс и игрек,
икс может быть равен игреку,

1052
00:48:37,090 --> 00:48:38,530
больше или меньше.

1053
00:48:38,530 --> 00:48:42,490
Однако один из этих вопросов
задавать не обязательно

1054
00:48:42,490 --> 00:48:45,400
Здесь три булевых выражения,

1055
00:48:45,400 --> 00:48:49,098
Икс меньше игрека, икс больше игрека
Икс равен игреку.

1056
00:48:49,098 --> 00:48:50,890
Булево выражение, как вы помните, 
это вопрос,

1057
00:48:50,890 --> 00:48:56,170
который может иметь только ответ да/нет,
истина/ложь или один/ноль.

1058
00:48:56,170 --> 00:48:59,560
Но мне не нужно задавать 
все тра вопроса, не так ли?

1059
00:48:59,560 --> 00:49:00,920
Я видел вашу руку

1060
00:49:00,920 --> 00:49:01,654
Итак, почему нет?

1061
00:49:01,654 --> 00:49:05,920
ЗАЛ: Потому что если
икс меньше [НЕРАЗБОРЧИВО]..

1062
00:49:05,920 --> 00:49:09,975


1063
00:49:09,975 --> 00:49:10,850
DAVID MALAN: Именно.

1064
00:49:10,850 --> 00:49:14,570
Этот третий вопрос, это булево
выражение, равен ли икс игреку,

1065
00:49:14,570 --> 00:49:16,700
оно просто не нужно.

1066
00:49:16,700 --> 00:49:19,655
Если икс не больше 
и не меньше игрека,

1067
00:49:19,655 --> 00:49:22,280
Это просто очевидно,
что единственный возможный случай - 

1068
00:49:22,280 --> 00:49:24,020
что икс равен игреку.

1069
00:49:24,020 --> 00:49:28,550
Так что мы можем упростить 
и код в Scratch, и код в Си

1070
00:49:28,550 --> 00:49:31,978
Оставив только else
здесь, внизу.

1071
00:49:31,978 --> 00:49:33,770
В течении следующих недель
мы будем говорить

1072
00:49:33,770 --> 00:49:36,230
о разных качествах кода.

1073
00:49:36,230 --> 00:49:38,480
Корректности,
делает ли он то, что должен

1074
00:49:38,480 --> 00:49:42,770
Но так же о качестве кода, 
работает ли он настолько эффективно,

1075
00:49:42,770 --> 00:49:45,530
насколько возможно, настолько быстро,
насколько возможно, есть ли способ

1076
00:49:45,530 --> 00:49:49,160
использовать меньше памяти,
меньше процессорного времени,

1077
00:49:49,160 --> 00:49:50,420
меньше ресурсов компьютера?

1078
00:49:50,420 --> 00:49:54,047
И этот пример - лишь намек
на возможности оптимизации

1079
00:49:54,047 --> 00:49:55,880
Хорошо, еще парочка сравнений

1080
00:49:55,880 --> 00:49:58,070
Прежде чем мы продолжим писать код

1081
00:49:58,070 --> 00:49:59,397
Как насчет этого?

1082
00:49:59,397 --> 00:50:02,480
В Scratch, мы называли это циклом
который делает что-то снова,

1083
00:50:02,480 --> 00:50:03,740
И снова, и снова.

1084
00:50:03,740 --> 00:50:08,120
Цикл в Си реализован 
несколько по другому,

1085
00:50:08,120 --> 00:50:09,080
вот так.

1086
00:50:09,080 --> 00:50:11,480
Самое близкое к слову 

1087
00:50:11,480 --> 00:50:14,820
forever в Scratch - 
это слово while, пока.

1088
00:50:14,820 --> 00:50:17,900
Это та же самая идея
повтора снова и снова

1089
00:50:17,900 --> 00:50:20,330
Это просто слово,
которое люди когда-то давно выбрали.

1090
00:50:20,330 --> 00:50:22,280
But you don't just say while.

1091
00:50:22,280 --> 00:50:26,090
Нужно не только сказать while 
и что вы хотите сделать,

1092
00:50:26,090 --> 00:50:29,910
но нужно и булево выражение.

1093
00:50:29,910 --> 00:50:32,540
Так что в Си, если хотите
создать бесконечный цикл,

1094
00:50:32,540 --> 00:50:36,090
нужно буквально сказать что-то, 
что точно будет истинно

1095
00:50:36,090 --> 00:50:40,850
Нужно задать вопрос, единственным 
ответом на который будет да, истинно, один.

1096
00:50:40,850 --> 00:50:42,980
Все эти ответы эквивалентны
для программиста

1097
00:50:42,980 --> 00:50:46,130
Так что же можно использовать
в качестве булевого выражения,

1098
00:50:46,130 --> 00:50:49,990
которое всегда верно,
чтобы сделать что-то бесконечно?

1099
00:50:49,990 --> 00:50:51,173
ЗАЛ: Пять равно пяти.

1100
00:50:51,173 --> 00:50:53,340
DAVID MALAN: Равно ли пять пяти,
все так!

1101
00:50:53,340 --> 00:50:55,220
Равно ли четыре четырем,

1102
00:50:55,220 --> 00:50:56,930
Будет ли два больше одного,

1103
00:50:56,930 --> 00:50:59,030
Или один меньше двух.

1104
00:50:59,030 --> 00:51:01,640
Есть бесконечное множество 
булевых выражений, 

1105
00:51:01,640 --> 00:51:03,800
которые - логически - всегда верны

1106
00:51:03,800 --> 00:51:07,070
Однако кратчайший путь - это 
буквально сказать true, истинно.

1107
00:51:07,070 --> 00:51:09,050
выглядит немного странно,
но это, наверное,

1108
00:51:09,050 --> 00:51:12,440
самое простое, что можно спросить, 
потому что истинно, по определению

1109
00:51:12,440 --> 00:51:16,520
всегда истинно,
и false, ложно, всегда ложно.

1110
00:51:16,520 --> 00:51:19,310
Так что я могу просто сказать "истинно"

1111
00:51:19,310 --> 00:51:24,008
чтобы создать бесконечный цикл, 
который будет делать что-то бесконечно.

1112
00:51:24,008 --> 00:51:26,300
Хорошо, давайте познакомимся
с новым типом цикла

1113
00:51:26,300 --> 00:51:28,192
Это был цикл, который
делал что-то 50 раз.

1114
00:51:28,192 --> 00:51:30,275
Это несколько сложнее,

1115
00:51:30,275 --> 00:51:32,360
и нам нужно сделать кое-что

1116
00:51:32,360 --> 00:51:35,120
Если я хочу сделать что-то 50 раз, 

1117
00:51:35,120 --> 00:51:37,850
Почему бы мне не создать переменную
и не назвать ее counter, счетчик,

1118
00:51:37,850 --> 00:51:40,760
- Но я могу назвать ее как угодно - 
и присвоить ноль.

1119
00:51:40,760 --> 00:51:42,980
Так, знаете что?

1120
00:51:42,980 --> 00:51:44,510
Counter - это слишком длинно.

1121
00:51:44,510 --> 00:51:46,490
Большинство программистов,
когда считают,

1122
00:51:46,490 --> 00:51:49,557
используют букву i (как integer, целое),
такое соглашение.

1123
00:51:49,557 --> 00:51:51,140
Но вообще можно назвать как угодно

1124
00:51:51,140 --> 00:51:53,810
Так что я напишу
int i равно нулю.

1125
00:51:53,810 --> 00:51:56,990
И сделаю следующее.

1126
00:51:56,990 --> 00:51:59,840
Пока это условие верно,
давайте я 

1127
00:51:59,840 --> 00:52:01,790
проверю условие, снова и снова

1128
00:52:01,790 --> 00:52:06,170
Пока i меньше пятидесяти,
напечатай hello world.

1129
00:52:06,170 --> 00:52:09,300
Я могу просто напечатать hello world.

1130
00:52:09,300 --> 00:52:12,260
Но мы еше не закончили с логикой

1131
00:52:12,260 --> 00:52:14,330
Я присвоил переменной ноль

1132
00:52:14,330 --> 00:52:18,380
Я буду снова и снова проверять условие,
если i меньше пятидесяти

1133
00:52:18,380 --> 00:52:21,530
Но если я хочу, чтобы это работало
какую еще строку мне надо добавить

1134
00:52:21,530 --> 00:52:24,360
в этот код?

1135
00:52:24,360 --> 00:52:25,916
Да?

1136
00:52:25,916 --> 00:52:27,810
ЗАл: Нужно увеличить i на один

1137
00:52:27,810 --> 00:52:29,530
DAVID MALAN: Да, нужно 
прирастить i, верно?

1138
00:52:29,530 --> 00:52:30,770
Даже если вы не помните синтаксис,

1139
00:52:30,770 --> 00:52:33,130
это нормально -- 
все, что нужно,

1140
00:52:33,130 --> 00:52:35,090
это просто такая строчка кода.

1141
00:52:35,090 --> 00:52:38,710
Вот что мы делаем:
Присвоить i значение 0 

1142
00:52:38,710 --> 00:52:41,120
И делать следующее,
пока i меньше 50

1143
00:52:41,120 --> 00:52:42,430
Итак, i меньше 50?

1144
00:52:42,430 --> 00:52:45,200
Конечно, ведь 0 меньше 50!

1145
00:52:45,200 --> 00:52:46,660
Так что напечатаем hello world.

1146
00:52:46,660 --> 00:52:48,820
И затем, как вы предложили
надо увеличить i

1147
00:52:48,820 --> 00:52:51,290
Nfr xnj ntgthm i равно i + 1.

1148
00:52:51,290 --> 00:52:53,980
Так что теперь i равно единице.

1149
00:52:53,980 --> 00:52:57,430
И теперь код работает так, как 
работал наш псевдокод на прошлой неделе

1150
00:52:57,430 --> 00:53:00,220
и мы возвращаемся к этой строке

1151
00:53:00,220 --> 00:53:04,010
На прошлой неделе, мы буквально
говорили, перейти на строку три

1152
00:53:04,010 --> 00:53:09,460
Здесь, это происходит автоматически
Си вот так интерпретирует этот код

1153
00:53:09,460 --> 00:53:10,720
в фигурных скобках.

1154
00:53:10,720 --> 00:53:12,980
И я могу это упростить
следующим образом.

1155
00:53:12,980 --> 00:53:14,568
Можно написать i++.

1156
00:53:14,568 --> 00:53:17,110
Не так опрятно, как в Scratch,
где вы просто говорили

1157
00:53:17,110 --> 00:53:18,760
повторить 50 раз

1158
00:53:18,760 --> 00:53:22,630
Используя принципы из прошлой недели,
теперь перенесенные в Си,

1159
00:53:22,630 --> 00:53:24,760
вы можете создавать собственный код

1160
00:53:24,760 --> 00:53:27,610
который делает что-то
заданное количество раз

1161
00:53:27,610 --> 00:53:30,430
Но есть еще один способ сделать это,

1162
00:53:30,430 --> 00:53:33,850
есть более удобный способ 
делать что-то заданное количество раз

1163
00:53:33,850 --> 00:53:36,430
Можно сделать то же самое с помощью
цикла for

1164
00:53:36,430 --> 00:53:38,710
Цикл for выглядит вот так:

1165
00:53:38,710 --> 00:53:43,180
Цикл for делает что-то, например
печатает hello world, снова и снова,

1166
00:53:43,180 --> 00:53:44,740
но делает это по другому.

1167
00:53:44,740 --> 00:53:48,580
Он заключает в одной строчке
кода ту самую логику,

1168
00:53:48,580 --> 00:53:50,020
которую мы только что реализовали

1169
00:53:50,020 --> 00:53:52,362
После for надо поставить скобки

1170
00:53:52,362 --> 00:53:54,070
и внутри этих скобок написать

1171
00:53:54,070 --> 00:53:56,740
создать переменную counter, счетчик

1172
00:53:56,740 --> 00:53:58,180
и присвоить ей значение ноль

1173
00:53:58,180 --> 00:53:59,410
Слишком длинно

1174
00:53:59,410 --> 00:54:00,760
Пусть будет просто i.

1175
00:54:00,760 --> 00:54:04,540
Это идентично тому, 
что мы только что сделали

1176
00:54:04,540 --> 00:54:09,190
Но цикл for приниает три аргумента

1177
00:54:09,190 --> 00:54:10,000
в этих скобках

1178
00:54:10,000 --> 00:54:12,520
Это немного непривычно

1179
00:54:12,520 --> 00:54:15,790
Второй аргумент - это булево выражение

1180
00:54:15,790 --> 00:54:20,380
которое будет проверено снова и снова,
является ли i меньше 50?

1181
00:54:20,380 --> 00:54:22,900
И последний аргумент
котррый есть в for

1182
00:54:22,900 --> 00:54:27,410
это третий аргумент, где
вы можете изменить переменную

1183
00:54:27,410 --> 00:54:32,830
Так что если i равно i + 1 или,
короче говоря, i += 1,

1184
00:54:32,830 --> 00:54:36,700
или даже, еще короче,
i++, я теперь сократил

1185
00:54:36,700 --> 00:54:40,210
то, что раньше требовало четырех строк,

1186
00:54:40,210 --> 00:54:42,440
сделал гораздо короче.

1187
00:54:42,440 --> 00:54:43,660
И оба способа корректные.

1188
00:54:43,660 --> 00:54:45,800
Оба способа делают одно и то же.

1189
00:54:45,800 --> 00:54:49,580
Не смотря на то, что цикл for 
менее очевиден

1190
00:54:49,580 --> 00:54:52,090
из-за этих трех аргументов,

1191
00:54:52,090 --> 00:54:54,265
он приводит к тому же результату.

1192
00:54:54,265 --> 00:54:56,890
Вы будете это делать в течение 
следующих недель,

1193
00:54:56,890 --> 00:54:58,510
снова и снова.

1194
00:54:58,510 --> 00:55:02,830
Это просто более короткий способ
достижения той же цели.

1195
00:55:02,830 --> 00:55:06,940
Какие-нибудь вопросы?

1196
00:55:06,940 --> 00:55:09,990


1197
00:55:09,990 --> 00:55:15,180
Хорошо, давайте посмотрим на еще кое-что

1198
00:55:15,180 --> 00:55:18,510
Оказывается в Си,
есть множество типов данных

1199
00:55:18,510 --> 00:55:20,210
Помимо строк и целых чисел

1200
00:55:20,210 --> 00:55:22,260
Познакомимся с ними и
начнем использовать

1201
00:55:22,260 --> 00:55:26,320
Есть bool, булево значение, которое
может быть только нулем или единицей

1202
00:55:26,320 --> 00:55:29,620
мы его уже использовали
в цикле while (true)

1203
00:55:29,620 --> 00:55:34,140
Есть char, или character, который 
представляет один и только один символ

1204
00:55:34,140 --> 00:55:34,920


1205
00:55:34,920 --> 00:55:39,390
Например буква Y или N,
если вы задаете вопрос Да / Нет.

1206
00:55:39,390 --> 00:55:42,720
Есть int, конечно, integer, 
или просто целое число

1207
00:55:42,720 --> 00:55:44,940
Строка, представляющая текст
заключенный в кавычки

1208
00:55:44,940 --> 00:55:47,670
Обычно больше, чем тип char

1209
00:55:47,670 --> 00:55:49,650
Есть и другие типы

1210
00:55:49,650 --> 00:55:50,700
int и long.

1211
00:55:50,700 --> 00:55:52,890
Итак, int обычно определенного размера

1212
00:55:52,890 --> 00:55:55,260
int может содержать число 
ограниченного размера.

1213
00:55:55,260 --> 00:55:58,110
Обычно, int может содержать число
до четырех миллиардов

1214
00:55:58,110 --> 00:56:00,610
и для некоторых случаев 
это совершенно недостаточно

1215
00:56:00,610 --> 00:56:03,330
Крупные компании, такие как
Facebook, Microsoft или Google

1216
00:56:03,330 --> 00:56:06,240
хранят много данных
с числами больше четырех миллиардов

1217
00:56:06,240 --> 00:56:10,030
Поэтому так же существует тип long, который
использует больше бит для хранения чисел.

1218
00:56:10,030 --> 00:56:12,640
Поэтому он может хранить гораздо большие числа

1219
00:56:12,640 --> 00:56:14,940
float необходим для чисел с плавающей точкой

1220
00:56:14,940 --> 00:56:18,390
так называют действительные числа,
более известные как дробные

1221
00:56:18,390 --> 00:56:23,130
А double - то же, что и float,
но с большим количеством чисел

1222
00:56:23,130 --> 00:56:24,790
после точки

1223
00:56:24,790 --> 00:56:26,370
Примерно как и long

1224
00:56:26,370 --> 00:56:28,950
А какие еще возможности дает 
нам библиотека CS50?

1225
00:56:28,950 --> 00:56:31,320
Не только функцию get_string,

1226
00:56:31,320 --> 00:56:35,567
Но и другие, например get_int,
get_float, get_double или get_char.

1227
00:56:35,567 --> 00:56:37,650
Все эти функции
запрашивают у человека ответ

1228
00:56:37,650 --> 00:56:42,360
некое необходимое значение.

1229
00:56:42,360 --> 00:56:44,540
Теперь о плейсхолдерах:

1230
00:56:44,540 --> 00:56:48,090
Функция Printf, напоминаю, использует 
плейсхолдер %s для строки.

1231
00:56:48,090 --> 00:56:50,580
Есть плейсхолдеры и для 
других типов данных

1232
00:56:50,580 --> 00:56:53,520
Если нужно вывести целое число,
мы используем %i.

1233
00:56:53,520 --> 00:56:55,920
Для десятичной дроби - 

1234
00:56:55,920 --> 00:56:57,350
используем %f.

1235
00:56:57,350 --> 00:57:00,390
Есть плейсхолдеры и для других типов

1236
00:57:00,390 --> 00:57:02,430
Но мы пока встречали только эти

1237
00:57:02,430 --> 00:57:05,010
И теперь, с точки зрения
математики

1238
00:57:05,010 --> 00:57:07,290
Мы легко можем делать
множество вычислений.

1239
00:57:07,290 --> 00:57:09,540
И мы сделаем пару примеров,

1240
00:57:09,540 --> 00:57:13,320
используя символы, которые вы напечатаете.

1241
00:57:13,320 --> 00:57:18,603
Итак, давайте напишем нашу собственную программу.

1242
00:57:18,603 --> 00:57:21,270
Мы можем использовать любые из этих
функций: get_int или get_float

1243
00:57:21,270 --> 00:57:22,240
и так далее.

1244
00:57:22,240 --> 00:57:24,990
Но перед этим, давайте сделаем 
пятиминутный перерыв

1245
00:57:24,990 --> 00:57:26,865
потому что это действительно как
пить из пожарного шланга

1246
00:57:26,865 --> 00:57:30,570
Печеньки уже ожидают нас в лобби,
мы продолжим через пять минут.

1247
00:57:30,570 --> 00:57:36,420
Итак, мы снова здесь, давайте продолжим
но уже не просто сравнивая

1248
00:57:36,420 --> 00:57:39,090
Си со Scratch, но
действительно напишем код

1249
00:57:39,090 --> 00:57:42,960
из Scratch но на языке Си.
Пора начать

1250
00:57:42,960 --> 00:57:46,050
нарабатывать мышечную память,
котора поможет

1251
00:57:46,050 --> 00:57:49,860
начинать с пустых файлов
и заполнять их

1252
00:57:49,860 --> 00:57:54,090
вашими идеями, реализованными на Си.

1253
00:57:54,090 --> 00:57:57,660
Все примеры, над которыми мы будем работать

1254
00:57:57,660 --> 00:57:59,670
Уже доступны онлайн,

1255
00:57:59,670 --> 00:58:02,580
так что вы можете скачать их
с нашего веб-сайта

1256
00:58:02,580 --> 00:58:05,632
В прекрасном разделе, подготовленном
Брайаном, вы можете изучить их получше

1257
00:58:05,632 --> 00:58:07,590
И позднее вы можете

1258
00:58:07,590 --> 00:58:11,020
вы можете создать такие программы
самостоятельно

1259
00:58:11,020 --> 00:58:16,140
Сейчас самое главное - это понимание идей

1260
00:58:16,140 --> 00:58:18,270
и развитие мышечной памяти.

1261
00:58:18,270 --> 00:58:21,947
Итак, я создам новую программу int.c,

1262
00:58:21,947 --> 00:58:24,780
целью которой будет получение числа
от пользователя,

1263
00:58:24,780 --> 00:58:28,530
как мы уже делали ранее со строкой

1264
00:58:28,530 --> 00:58:30,630
Как и раньше,

1265
00:58:30,630 --> 00:58:32,410
мне необходимо подключить знакомые файлы

1266
00:58:32,410 --> 00:58:35,012
Я добавлю CS50.h

1267
00:58:35,012 --> 00:58:37,830
чтобы получить доступ к 
strings и get_string

1268
00:58:37,830 --> 00:58:40,800
get_int, get_float и другим возможностям.

1269
00:58:40,800 --> 00:58:43,890
Так же я подключу stdio.h
чтобы иметь возможность использовать printf

1270
00:58:43,890 --> 00:58:45,780
Так что мы сможем увидеть ответы.

1271
00:58:45,780 --> 00:58:48,600
Я сделаю это, снова скажу, на сегодня

1272
00:58:48,600 --> 00:58:51,150
и пару следующих недель,
это просто скопированный код.

1273
00:58:51,150 --> 00:58:54,090
Это примерно соответствует 
"Когда нажат зеленый флаг"

1274
00:58:54,090 --> 00:58:57,240
Но мы увидим, буквально через пару недель,
почему конкретно мы пишем здесь int

1275
00:58:57,240 --> 00:58:59,235
и почему пишем void.

1276
00:58:59,235 --> 00:59:01,110
Здесь, я сделаю примерно так:

1277
00:59:01,110 --> 00:59:03,360
В этот раз, мне нужна не строка, 
но целое число,

1278
00:59:03,360 --> 00:59:08,320
Так что давайте используем get_int,
например, спросим возраст

1279
00:59:08,320 --> 00:59:10,860
Я могу набрать это довольно быстро

1280
00:59:10,860 --> 00:59:13,650
потому что у меня наработана
мышечная память на программирование с Си

1281
00:59:13,650 --> 00:59:16,150
Но если мы внимательно на это посмотрим,

1282
00:59:16,150 --> 00:59:19,540
это просто другая функция get_int,
из той же библиотеки CS50 library

1283
00:59:19,540 --> 00:59:20,800
которая получит для нас число

1284
00:59:20,800 --> 00:59:22,550
Это подсказка, которую
пользователь увидит,

1285
00:59:22,550 --> 00:59:25,862
и я перенесу курсор на новую строку 
при помощи /n

1286
00:59:25,862 --> 00:59:27,570
И что бы они не набрали,

1287
00:59:27,570 --> 00:59:31,350
будет скопировано справа налево,
в переменную age, возраст,

1288
00:59:31,350 --> 00:59:34,140
и это будет целое число.

1289
00:59:34,140 --> 00:59:37,717
А здесь я подсчитаю, сколько дней, 
минимум, исполнилось пользователю

1290
00:59:37,717 --> 00:59:40,050
Я сделаю это примерно так:

1291
00:59:40,050 --> 00:59:41,490
Мне нужно целое число, 

1292
00:59:41,490 --> 00:59:42,780
назовем переменную days, дни

1293
00:59:42,780 --> 00:59:45,602
и затем просто умножим на 365.

1294
00:59:45,602 --> 00:59:47,310
Есть разные арифметические операции,

1295
00:59:47,310 --> 00:59:49,830
например, плюс и минус

1296
00:59:49,830 --> 00:59:53,850
умножение, деление, 
и даже получение остатка от деления

1297
00:59:53,850 --> 00:59:58,680
Так что в строке 7
мы просто умножаем age на 365.

1298
00:59:58,680 --> 01:00:02,800
и переносим это новое значение справа
налево, в переменную days.

1299
01:00:02,800 --> 01:00:04,800
А теперь я выведу это значение на экран

1300
01:00:04,800 --> 01:00:09,090
Выведем что-нибудь такое: printf,
"ваш возраст — не менее", символ %--

1301
01:00:09,090 --> 01:00:13,620
тут не s, потому что это не строка,
а i — для целого числа--

1302
01:00:13,620 --> 01:00:15,900
дней, обратная косая черта, n.

1303
01:00:15,900 --> 01:00:18,190
Это ещё не всё, потому что
у нас тут заполнитель.

1304
01:00:18,190 --> 01:00:23,580
Что ещё мне нужно поместить в скобки
на восьмой строке?

1305
01:00:23,580 --> 01:00:27,990
Именно. Поэтому: запятая, days, если мне
нужно использовать именно это значение.

1306
01:00:27,990 --> 01:00:29,377
И я ещё кое-что пропустил.

1307
01:00:29,377 --> 01:00:30,210
ЗАЛ: Точку с запятой.

1308
01:00:30,210 --> 01:00:32,127
DAVID MALAN: Точку с запятой
в конце строки.

1309
01:00:32,127 --> 01:00:33,503
Надеюсь, теперь всё верно.

1310
01:00:33,503 --> 01:00:35,670
Но скорее всего, поначалу
в своих программах

1311
01:00:35,670 --> 01:00:37,150
вы будете видеть море ошибок.

1312
01:00:37,150 --> 01:00:41,040
Так, make int — самый быстрый
способ компиляции этого кода.

1313
01:00:41,040 --> 01:00:41,850
Жмём Enter.

1314
01:00:41,850 --> 01:00:43,860
Отлично, длинная белая надпись —
это хорошо.

1315
01:00:43,860 --> 01:00:47,490
Пока в выводе отсутствуют красный,
жёлтый или другие цвета, означающие

1316
01:00:47,490 --> 01:00:49,590
предупреждения или ошибки, всё в порядке.

1317
01:00:49,590 --> 01:00:53,910
Я очищу экран и просто запущу
эту программу: ./int.

1318
01:00:53,910 --> 01:00:56,150
Предположим, ваш возраст — 50.

1319
01:00:56,150 --> 01:01:00,422
Ну, в днях это будет как минимум 18,250.

1320
01:01:00,422 --> 01:01:03,630
Но позвольте мне использовать эту возможность
для создания не только правильного, каким,

1321
01:01:03,630 --> 01:01:06,690
я полагаю, этот код и является,
но ещё и хорошего кода.

1322
01:01:06,690 --> 01:01:11,580
Вполне нормально хранить значение
возраста в переменной age.

1323
01:01:11,580 --> 01:01:13,950
И так же нормально иметь
вторую переменную с именем

1324
01:01:13,950 --> 01:01:19,300
days, где хранится значение,
равное age, умноженному на 365.

1325
01:01:19,300 --> 01:01:22,530
Но строго говоря, мне не нужна
эта дополнительная строка кода.

1326
01:01:22,530 --> 01:01:26,520
Я мог бы написать age * 365 прямо здесь.

1327
01:01:26,520 --> 01:01:27,660
Этим Си и хорош.

1328
01:01:27,660 --> 01:01:32,370
Как и в Scratch, здесь можно составлять
большие идеи из нескольких маленьких

1329
01:01:32,370 --> 01:01:33,090
кусочков.

1330
01:01:33,090 --> 01:01:35,550
А если уж совсем сходить с ума,

1331
01:01:35,550 --> 01:01:38,040
заметьте, что я могу выделить
весь этот вызов

1332
01:01:38,040 --> 01:01:42,000
функции, так сказать, полностью
избавиться от переменной age,

1333
01:01:42,000 --> 01:01:49,330
и просто вставить его сюда,
умножив на 365.

1334
01:01:49,330 --> 01:01:53,190
Но таким образом мы начинаем
перегибать палку.

1335
01:01:53,190 --> 01:01:55,342
Да, всё написанное верно, потому что мне,
строго говоря,

1336
01:01:55,342 --> 01:01:56,550
не нужна переменная, так?

1337
01:01:56,550 --> 01:01:58,020
Я могу передавать-- как мы видели
на прошлой неделе--

1338
01:01:58,020 --> 01:02:00,870
выход одной функции на вход другой,

1339
01:02:00,870 --> 01:02:02,540
просто вкладывая их друг в друга.

1340
01:02:02,540 --> 01:02:05,040
Но если подумать, в данный момент
эта строка кода

1341
01:02:05,040 --> 01:02:08,080
стала настолько длинной, что
её очень трудно читать.

1342
01:02:08,080 --> 01:02:10,830
И вот это как раз пример того,
когда из соображений читаемости

1343
01:02:10,830 --> 01:02:13,210
лучше вернуть предыдущий вариант,

1344
01:02:13,210 --> 01:02:16,950
потому что он позволяет читать код
скорее сверху вниз, чем слева направо.

1345
01:02:16,950 --> 01:02:18,900
Это проектное решение.

1346
01:02:18,900 --> 01:02:21,000
Вы можете быть согласны или несогласны,

1347
01:02:21,000 --> 01:02:24,420
в том числе и с вашим наставником.

1348
01:02:24,420 --> 01:02:28,770
Выбор здесь стоит между написанем
хорошего и плохого кода,

1349
01:02:28,770 --> 01:02:30,300
ну или хорошего и более хорошего кода.

1350
01:02:30,300 --> 01:02:33,000
Почти как в сочинении по английскому
или любому другому языку:

1351
01:02:33,000 --> 01:02:36,030
работа одного человека может
понравиться вам больше,

1352
01:02:36,030 --> 01:02:36,730
чем работа другого.

1353
01:02:36,730 --> 01:02:40,140
Так что со временем мы начнём
ценить эти нюансы.

1354
01:02:40,140 --> 01:02:41,310
А что насчёт действительных чисел?

1355
01:02:41,310 --> 01:02:45,758
Давайте я быстренько напишу другую
программу под названием float.c.

1356
01:02:45,758 --> 01:02:47,550
И в ней мы будем использовать дробные

1357
01:02:47,550 --> 01:02:50,800
значения, соответствующие
действительным числам.

1358
01:02:50,800 --> 01:02:54,150
Так, теперь заголовочные файлы:
include CS50.h, include stdio.h.

1359
01:02:54,150 --> 01:02:57,840


1360
01:02:57,840 --> 01:03:02,003
Затем int main void и фигурные скобки.

1361
01:03:02,003 --> 01:03:02,920
А теперь сделаем вот что.

1362
01:03:02,920 --> 01:03:04,680
Давайте посчитаем стоимость чего-нибудь.

1363
01:03:04,680 --> 01:03:10,290
Пишем: int price, равно, get float,
какова цена, например.

1364
01:03:10,290 --> 01:03:11,450
Точка с запятой.

1365
01:03:11,450 --> 01:03:13,660
А теперь применим кое-какие вычисления.

1366
01:03:13,660 --> 01:03:18,120
Напишем, например: "общая сумма составляет".

1367
01:03:18,120 --> 01:03:21,330
И далее посчитаем, например, общую
стоимость с учётом налогов.

1368
01:03:21,330 --> 01:03:24,353
В штате Массачусетс налог с продаж
составляет 6.25%.

1369
01:03:24,353 --> 01:03:26,520
Напишем небольшую программу,
учитывающую его.

1370
01:03:26,520 --> 01:03:30,540
Общая сумма составляет-- не %s,
потому что это не строка.

1371
01:03:30,540 --> 01:03:33,190
И не %i, потому что это не целое число.

1372
01:03:33,190 --> 01:03:37,990
Для действительного числа это будет %f.

1373
01:03:37,990 --> 01:03:39,350
Кстати, я тут облажался.

1374
01:03:39,350 --> 01:03:41,860
Случайно сделал эту ошибку.

1375
01:03:41,860 --> 01:03:44,997
Я не хочу хранить цену в переменной
типа int, если вычисляю её как float.

1376
01:03:44,997 --> 01:03:47,080
Если я получаю действительное число
с десятичной точкой,

1377
01:03:47,080 --> 01:03:49,310
то мне и хранить его следует
как действительное число.

1378
01:03:49,310 --> 01:03:52,480
Опять же, каждому формату соответствует
свой заполнитель

1379
01:03:52,480 --> 01:03:53,787
в зависимости от контекста.

1380
01:03:53,787 --> 01:03:55,120
Теперь я сделаю следующее.

1381
01:03:55,120 --> 01:03:56,995
Если я хочу подставить переменную
price, мне нужно

1382
01:03:56,995 --> 01:04:05,230
написать price * 1.0625, что соответствует
добавлению 106.25%--

1383
01:04:05,230 --> 01:04:08,770
или, иначе говоря, умножению цены
на 106.25%,

1384
01:04:08,770 --> 01:04:11,203
и теперь мы видим общую сумму
с налогом.

1385
01:04:11,203 --> 01:04:13,120
Хорошо, давайте скомпилируем
этот код.

1386
01:04:13,120 --> 01:04:14,980
Make float, Enter.

1387
01:04:14,980 --> 01:04:17,320
Сообщений об ошибках нет,
уже неплохо.

1388
01:04:17,320 --> 01:04:18,730
./float.

1389
01:04:18,730 --> 01:04:19,990
"Какова цена"?

1390
01:04:19,990 --> 01:04:23,170
Ну, как насчёт $100?

1391
01:04:23,170 --> 01:04:25,180
Кажется, результат чересчур точный.

1392
01:04:25,180 --> 01:04:29,932
Общая сумма составляет $106.250000.

1393
01:04:29,932 --> 01:04:33,130
Это всё потому, что компьютер,
как мы помним,

1394
01:04:33,130 --> 01:04:35,440
использует определённое количество бит
для хранения значений.

1395
01:04:35,440 --> 01:04:40,120
И он, оказывается, способен
показывать вот столько знаков

1396
01:04:40,120 --> 01:04:41,140
после десятичной точки.

1397
01:04:41,140 --> 01:04:42,830
Но что если нам столько не нужно?

1398
01:04:42,830 --> 01:04:46,660
Оказывается, для этого существуют
кое-какие хитрости.

1399
01:04:46,660 --> 01:04:48,910
Instead of doing percent
f, I can actually

1400
01:04:48,910 --> 01:04:52,360
сделать процент точка 2f, которую,
опять же, вы могли знать только

1401
01:04:52,360 --> 01:04:55,570
если встречали раньше,
или видели ее в книжке или справке.

1402
01:04:55,570 --> 01:04:59,150
Это покажет мне две цифры после
точки.

1403
01:04:59,150 --> 01:05:02,560
Так что, если я рекомпилирую код
и сделаю ./float,

1404
01:05:02,560 --> 01:05:07,720
заметьте, если цена 100 долларов, теперь
моя сумма немного более читаема--

1405
01:05:07,720 --> 01:05:09,790
106.25.

1406
01:05:09,790 --> 01:05:11,953
Если кратко, это f в printf
So in short, this is the f in printf.

1407
01:05:11,953 --> 01:05:13,870
Так же как вы можете
что то напечатать на экране,

1408
01:05:13,870 --> 01:05:19,380
вы можете форматировать это,
сказав printf сколько символов после точки
показать.

1409
01:05:19,380 --> 01:05:20,810
Давайте я попробую кое что еще.

1410
01:05:20,810 --> 01:05:23,470
Давайте я скопирую начало
этого кода,

1411
01:05:23,470 --> 01:05:24,940
просто чтобы ускориться.

1412
01:05:24,940 --> 01:05:27,190
Чтобы я смог сделать программу
которая называется parity.c.

1413
01:05:27,190 --> 01:05:30,343
"Parity" это прикольный способ
сказать четное ли число.

1414
01:05:30,343 --> 01:05:32,260
И я просто скопировал и
вставил

1415
01:05:32,260 --> 01:05:35,708
подготовительный код, но не
главную функцию.

1416
01:05:35,708 --> 01:05:38,500
Но давайте спросим число у пользователя.

1417
01:05:38,500 --> 01:05:39,540
И назовем его n.

1418
01:05:39,540 --> 01:05:41,620
И мы используем get_int чтобы получить значение.

1419
01:05:41,620 --> 01:05:44,620
И мы просто спросим человека,
каково значение n?

1420
01:05:44,620 --> 01:05:49,540
И я просто скажу n двоеточие пробел
чтобы запросить какое нибудь число.

1421
01:05:49,540 --> 01:05:51,460
Потом я задам вопрос.

1422
01:05:51,460 --> 01:05:55,570
И я хочу написать "even" если
число четное или "odd"
I want to ultimately print out
even if the number is even or odd

1423
01:05:55,570 --> 01:05:56,830
если нечетное.

1424
01:05:56,830 --> 01:06:02,650
Вы можете представить как это сделать
очень утомительным образом, например
если n = 1,

1425
01:06:02,650 --> 01:06:06,130
я напишу "odd".

1426
01:06:06,130 --> 01:06:12,340
И если n = 2, я могу написать "even".

1427
01:06:12,340 --> 01:06:16,190
И потом если я хочу поддерживать
номер три, тогде если n--

1428
01:06:16,190 --> 01:06:17,440
это довольно глупо, не так ли?

1429
01:06:17,440 --> 01:06:18,880
Я могу делать это вечно.

1430
01:06:18,880 --> 01:06:21,632
Но по крайней мере
мы видим паттерн, верно?

1431
01:06:21,632 --> 01:06:24,340
Один, потом три, потом пять,
конечно, будут нечетными,

1432
01:06:24,340 --> 01:06:26,990
а два, четыре и шесть будут
четными, и так далее.

1433
01:06:26,990 --> 01:06:29,240
Выглядит так, как будто можно
это вычислить математически.

1434
01:06:29,240 --> 01:06:30,970
И есть очень распространенный
способ это сделать--

1435
01:06:30,970 --> 01:06:32,500
мы можем щас его воспроизвести.

1436
01:06:32,500 --> 01:06:39,070
Если n делится на 2, и остаток,
например, 0,

1437
01:06:39,070 --> 01:06:42,850
мы сделаем вывод что номер
четный.

1438
01:06:42,850 --> 01:06:45,430
Вот этот значок процента -
это новая конструкция.

1439
01:06:45,430 --> 01:06:46,090
Это не плюс.

1440
01:06:46,090 --> 01:06:47,440
Это не минус.

1441
01:06:47,440 --> 01:06:49,240
Не умножение и не деление.

1442
01:06:49,240 --> 01:06:53,150
Это операция остатка от деления.

1443
01:06:53,150 --> 01:06:59,470
И это значит поделить на 2, и
если у ответа остаток 0,

1444
01:06:59,470 --> 01:07:02,670
вы можете заключить, по определению
четности, что номер четный.

1445
01:07:02,670 --> 01:07:04,100
И я выведу это на экран.

1446
01:07:04,100 --> 01:07:08,320
В противном случае-- Я могу сделать else if
n процент 2 равно равно 1

1447
01:07:08,320 --> 01:07:11,380
а значит имеет остаток 1,
и сказать нечетное.

1448
01:07:11,380 --> 01:07:15,405
Но как вы заметили раньше,
это не нужно.

1449
01:07:15,405 --> 01:07:18,280
Что я могу сделать вмето этого -
структурировать программу чуть лучше,

1450
01:07:18,280 --> 01:07:19,600
более эффективной?

1451
01:07:19,600 --> 01:07:20,248
Да?

1452
01:07:20,248 --> 01:07:22,440
АУДИТОРИЯ: Ты можешь просто
использовать else и все будет отлично.

1453
01:07:22,440 --> 01:07:22,770
DAVID MALAN: Да.

1454
01:07:22,770 --> 01:07:24,687
Поэтому если мы говорим о
целых числах, я могу

1455
01:07:24,687 --> 01:07:28,360
заключить, что, если это не четное,
это нечетное, по определению.

1456
01:07:28,360 --> 01:07:30,510
И здесь, мы можем
просто сделать четные и нечетные.

1457
01:07:30,510 --> 01:07:33,510
Так что эта программа, будет
выглядеть вот так при запуске.

1458
01:07:33,510 --> 01:07:35,400
Make parity.

1459
01:07:35,400 --> 01:07:36,630
Скомпилировалось нормально.

1460
01:07:36,630 --> 01:07:38,880
И я запускаю ее с помощью ./parity.

1461
01:07:38,880 --> 01:07:40,290
Вводим 50.

1462
01:07:40,290 --> 01:07:40,950
Четное.

1463
01:07:40,950 --> 01:07:42,510
Вводим 49.

1464
01:07:42,510 --> 01:07:43,380
Нечетное.

1465
01:07:43,380 --> 01:07:44,850
Доказательство на примере.

1466
01:07:44,850 --> 01:07:48,060
Не то чтобы железно доказано, но я могу
предположить что будет работать верно,

1467
01:07:48,060 --> 01:07:49,480
основываясь на этих двух примерах.

1468
01:07:49,480 --> 01:07:49,980
Верно?

1469
01:07:49,980 --> 01:07:52,938
АУДИТОРИЯ: [НЕРАЗБОРЧИВО] пользователь
не понял наш комментарий что ответ

1470
01:07:52,938 --> 01:07:54,332
float а не целое число?

1471
01:07:54,332 --> 01:07:55,790
DAVID MALAN: Извините, еще раз?

1472
01:07:55,790 --> 01:07:58,207
АУДИТОРИЯ: Что если пользователь
не понимает, что ему надо сделать?

1473
01:07:58,207 --> 01:08:02,783
Например просто введу что
нибудь, 1 и 1/2 [НЕРАЗБОРЧИВО].

1474
01:08:02,783 --> 01:08:04,200
DAVID MALAN: Очень хороший вопрос.

1475
01:08:04,200 --> 01:08:06,950
Одна из причин почему мы показываем
в первые недели курса

1476
01:08:06,950 --> 01:08:10,700
функции в библиотеке CS50 типа
get_string и get_int и get_float

1477
01:08:10,700 --> 01:08:14,960
потому что они заставляют пользователя
действовать как вы этого ожиадете и ваше приложение

1478
01:08:14,960 --> 01:08:17,149
не падает от неправильно введенных данных.

1479
01:08:17,149 --> 01:08:20,180
Так что, предположим пользователь
немного тормозит и вводит,

1480
01:08:20,180 --> 01:08:22,939
мой номер это 1.5.

1481
01:08:22,939 --> 01:08:27,854
Get_int задаст им тот же вопрос
еще раз и еще раз и еще раз

1482
01:08:27,854 --> 01:08:28,729
пока до них не дойдет.

1483
01:08:28,729 --> 01:08:31,819
Если вы введете "apple", он
спросит вас снова.

1484
01:08:31,819 --> 01:08:34,880
И когда вы введете целое число,
только тогда оно заработает.

1485
01:08:34,880 --> 01:08:37,540
Это одна из вещей которые идут
с бибилотекой CS50,

1486
01:08:37,540 --> 01:08:39,410
чтобы мы могли сосредоточиться
на идеях, а не

1487
01:08:39,410 --> 01:08:44,270
на проверках на ошибки, или подозрительных
действиях пользователя.

1488
01:08:44,270 --> 01:08:46,670
Окей, что еще
мы можем сделать, с

1489
01:08:46,670 --> 01:08:49,279
возможностью выражать условия?

1490
01:08:49,279 --> 01:08:52,010
Так, давайте я открою исходники,
которые принес с собой.

1491
01:08:52,010 --> 01:08:54,109
Вместо того чтобы печатать
все с нуля,

1492
01:08:54,109 --> 01:08:56,618
я просто открою conditions1.c.

1493
01:08:56,618 --> 01:08:58,660
Это приложение которое
уже было написано.

1494
01:08:58,660 --> 01:09:00,920
И видите, у нас есть
какие другие строчки там,

1495
01:09:00,920 --> 01:09:03,643
эти серые линии,
которые начинаются со слеш слеш.

1496
01:09:03,643 --> 01:09:05,810
Вы могли не заметить, но в Scratch,
у вас была штука,

1497
01:09:05,810 --> 01:09:06,979
которая называлась "комментарии".

1498
01:09:06,979 --> 01:09:09,050
Они как будто маленькие липкие
бумажки которые вы можете добавить

1499
01:09:09,050 --> 01:09:10,550
и не делают ничего функционально.

1500
01:09:10,550 --> 01:09:13,825
Это просто заметки для себя самого,
коллеги или преподавателя

1501
01:09:13,825 --> 01:09:15,950
Вот что такое комментарий
в языках программирования

1502
01:09:15,950 --> 01:09:19,310
Так то все, что начинается с
двойного слэша, это просто примечание

1503
01:09:19,310 --> 01:09:21,873
И это напоминание о том,
что делает эта строка кода

1504
01:09:21,873 --> 01:09:24,040
Это напоминание вашим коллегам,

1505
01:09:24,040 --> 01:09:27,380
или вашему преподавателю,

1506
01:09:27,380 --> 01:09:30,520
что именно оно должно делать, 
даже если оно это не делает

1507
01:09:30,520 --> 01:09:32,090
и тут ошибка, баг.

1508
01:09:32,090 --> 01:09:35,840
Так что в этих примерах 
я начал комментировать свой код

1509
01:09:35,840 --> 01:09:37,580
Но эти строчки фактически равны

1510
01:09:37,580 --> 01:09:40,250
Я получу доступ к библиотеке CS50

1511
01:09:40,250 --> 01:09:43,010
И эта библиотека - это 
просто файл с кодом

1512
01:09:43,010 --> 01:09:45,080
который кто-то написал для нас

1513
01:09:45,080 --> 01:09:47,960
И еще мне нужен доступ к standard I/O,
библиотеке, которая содержит

1514
01:09:47,960 --> 01:09:50,430
printf и многие другие вещи

1515
01:09:50,430 --> 01:09:54,170
Заметьте, здесь x = get_int для того, 

1516
01:09:54,170 --> 01:09:56,390
чтобы получить число от пользователя
и сохранить в переменной х

1517
01:09:56,390 --> 01:09:59,840
Теперь я попрошу ввести второе число,
и назову его просто игрек

1518
01:09:59,840 --> 01:10:01,400
снова с помощью get_int

1519
01:10:01,400 --> 01:10:03,840
И теперь я могу сравнить эти числа

1520
01:10:03,840 --> 01:10:07,790
Вот полная версия программы, подобной той,
что мы делали в Scracth

1521
01:10:07,790 --> 01:10:11,450
Мы уже знаем, что икс может быть
меньше игрека, больше игрека 

1522
01:10:11,450 --> 01:10:15,290
или равен игреку

1523
01:10:15,290 --> 01:10:19,080
так что мы уже видели подобный код раньше

1524
01:10:19,080 --> 01:10:22,340
Теперь мы видим, что,
чтобы этот код заработал,

1525
01:10:22,340 --> 01:10:25,640
нам нужно получить числа от пользователя

1526
01:10:25,640 --> 01:10:28,520
еще нужно подобие того зеленого
флага из Scratсh

1527
01:10:28,520 --> 01:10:31,115
А также эквивалент этих инструкций

1528
01:10:31,115 --> 01:10:33,575
так что получится полная правильно 
собранная программа.

1529
01:10:33,575 --> 01:10:35,450
И еще, для ясности, хотя я уже сделал это,

1530
01:10:35,450 --> 01:10:38,710
если я хочу запустить эту программу,
что я должен сделать?

1531
01:10:38,710 --> 01:10:41,770
Вызвать conditions.c.

1532
01:10:41,770 --> 01:10:45,030
Итак, сначала make conditions

1533
01:10:45,030 --> 01:10:45,530
Извините

1534
01:10:45,530 --> 01:10:48,140
О, это довольно поучительный момент

1535
01:10:48,140 --> 01:10:49,670
Почему не сработало?

1536
01:10:49,670 --> 01:10:54,020
Невозможно выполнить,
"no rule to make target conditions"

1537
01:10:54,020 --> 01:10:55,130
Что это вообще значит?

1538
01:10:55,130 --> 01:10:58,700
Сегодня я скачал кое-что сюда

1539
01:10:58,700 --> 01:11:02,630
Папку, названную src1, S-R-C означает
"source", исходники, так говорят программисты

1540
01:11:02,630 --> 01:11:06,140
И я скачал эту папку сюда.

1541
01:11:06,140 --> 01:11:08,540
Потому что в этой папке 
все необходимые примеры

1542
01:11:08,540 --> 01:11:12,050
Не только то, что я сам написал,
но и код других людей

1543
01:11:12,050 --> 01:11:15,920
К сожалению, весь этот код
находится в папке src1.

1544
01:11:15,920 --> 01:11:18,920
На вашем компьютере, если вы хотите
открыть папку, вы сделаете то же, что и я

1545
01:11:18,920 --> 01:11:22,100
Кликните дважды на иконку и - 
вуаля, папка открыта

1546
01:11:22,100 --> 01:11:25,880
Но в терминале, текстовом окружении,
так сделать нельзя

1547
01:11:25,880 --> 01:11:29,840
Если я наберу ls, мы увидим все файлы, 
которые я создал сегодня

1548
01:11:29,840 --> 01:11:32,120
float, hello и int.

1549
01:11:32,120 --> 01:11:34,520
Обратите внимание, вот это папка

1550
01:11:34,520 --> 01:11:36,145
Об этом говорит этот знак в конце, слэш

1551
01:11:36,145 --> 01:11:38,270
Он просто говроит: эй, человек, 

1552
01:11:38,270 --> 01:11:40,250
это папка, это же так очевидно!

1553
01:11:40,250 --> 01:11:44,150
Так же как звездочка здесь означает
машинный код, который можно запустить

1554
01:11:44,150 --> 01:11:47,270
Мне нужно перейти в эту папку,
но кликнуть дважды я не могу

1555
01:11:47,270 --> 01:11:49,700
Если я кликну дважды,
ничего не произойдет

1556
01:11:49,700 --> 01:11:53,650
Однако, я могу набрать cd пробел src1.

1557
01:11:53,650 --> 01:11:55,760
cd означает change directory, 
сменить папку

1558
01:11:55,760 --> 01:11:57,200
Нажму энтер

1559
01:11:57,200 --> 01:11:59,990
И если я теперь наберу ls,
я увижу гораздо больше файлов,

1560
01:11:59,990 --> 01:12:03,110
это файлы с сайта курса,

1561
01:12:03,110 --> 01:12:05,180
которые я загрузил сегодня

1562
01:12:05,180 --> 01:12:08,037
И если набрать команду pwd

1563
01:12:08,037 --> 01:12:10,370
Это предоставит и другую информацию

1564
01:12:10,370 --> 01:12:12,050
Но мы расскажем об этом в следующих уроках

1565
01:12:12,050 --> 01:12:16,160
Итак, мы находимся в папке src1

1566
01:12:16,160 --> 01:12:17,840
которая находится в корневой папке

1567
01:12:17,840 --> 01:12:21,140
Теперь, с некоторыми шансами,
вы запутались, где мы находимся

1568
01:12:21,140 --> 01:12:23,150
Не уверен? Просто набери cd.

1569
01:12:23,150 --> 01:12:25,950
Это переместит нас обратно 
в основную папку,

1570
01:12:25,950 --> 01:12:28,430
неважно, где мы находились до этого

1571
01:12:28,430 --> 01:12:30,470
Наберите ls и увидите, что 
мы снова в начале

1572
01:12:30,470 --> 01:12:32,570
Не знаете, где вы - 
наберите cd и Enter,

1573
01:12:32,570 --> 01:12:34,430
И вы снова в начале

1574
01:12:34,430 --> 01:12:37,610
Итак, давайте откроем эту программу,
но перед этим запустим ее

1575
01:12:37,610 --> 01:12:40,190
Я открою программу agree.c

1576
01:12:40,190 --> 01:12:44,520
Спрячу код на мгновение 
и соберу ее

1577
01:12:44,520 --> 01:12:47,360
Итак, снова: cd src1, Enter.

1578
01:12:47,360 --> 01:12:49,800
И теперь make agree.

1579
01:12:49,800 --> 01:12:51,500
Кажется, получилось

1580
01:12:51,500 --> 01:12:55,700
И если я наберу ./agree, эта 
программа задаст мне вопрос

1581
01:12:55,700 --> 01:12:56,523
Вы согласны?

1582
01:12:56,523 --> 01:12:58,940
Не очень понятно, что именно
я должен набрать,

1583
01:12:58,940 --> 01:13:01,220
Но, догадываюсь, yes

1584
01:13:01,220 --> 01:13:04,370
Так что я нажму y как yes and Enter.

1585
01:13:04,370 --> 01:13:06,050
Кажется, я согласился.

1586
01:13:06,050 --> 01:13:07,490
Если я перезапущу программу,

1587
01:13:07,490 --> 01:13:11,900
./agree and нажму n
В этот раз - Не согласен

1588
01:13:11,900 --> 01:13:12,650
Но знаете что?

1589
01:13:12,650 --> 01:13:13,942
Все даже лучше!

1590
01:13:13,942 --> 01:13:18,650
Если я снова запущу ./agree и введу
заглавную Y, Enter, это тоже сработает

1591
01:13:18,650 --> 01:13:20,130
Как это происходит?

1592
01:13:20,130 --> 01:13:21,770
Давайте посмотрим на код

1593
01:13:21,770 --> 01:13:25,190
Начало файла вполне обычное

1594
01:13:25,190 --> 01:13:27,650
Подключим эти два файла, int main void.

1595
01:13:27,650 --> 01:13:30,320
Но теперь я использую get_char,
и сохраняю мой ответ 

1596
01:13:30,320 --> 01:13:33,710
в переменной c, хотя можно было 
назвать и по другому

1597
01:13:33,710 --> 01:13:36,350
Обратите внимание на новый синтаксис

1598
01:13:36,350 --> 01:13:41,300
Что здесь выглядит незнакомым?

1599
01:13:41,300 --> 01:13:43,910
Какие символы притягивают взгляд?

1600
01:13:43,910 --> 01:13:45,200
Да, вертикальная полоса

1601
01:13:45,200 --> 01:13:48,020
Она означает логическое ИЛИ

1602
01:13:48,020 --> 01:13:50,630
В Python и других современных языках вы можете 

1603
01:13:50,630 --> 01:13:52,280
буквально написать or, "или"

1604
01:13:52,280 --> 01:13:57,500
Но это не сработает в Си. Если вы 
хотите задать два вопроса,

1605
01:13:57,500 --> 01:14:00,740
И принять любой из ответов

1606
01:14:00,740 --> 01:14:03,020
Вы просто используете две 
вертикальные полосы, они обычно

1607
01:14:03,020 --> 01:14:05,720
Над клавишей энтер, на американской 
клавиатуре, по крайней мере.

1608
01:14:05,720 --> 01:14:07,760
Итак, две вертикальные полосы означают "или".

1609
01:14:07,760 --> 01:14:10,640
А два амперсанда означают логическое "И"

1610
01:14:10,640 --> 01:14:13,940
Это просто способ задать два вопроса за раз

1611
01:14:13,940 --> 01:14:16,800
И принять любой из ответов 

1612
01:14:16,800 --> 01:14:21,650
Итак, если c - заглавное Y или c - прописное y,
значит пользователь согласен

1613
01:14:21,650 --> 01:14:26,090
Иначе, если c равно заглавному N или прописному n,
значит пользователь не согласен

1614
01:14:26,090 --> 01:14:28,970
А если я введу какие-нибудь другие буквы,

1615
01:14:28,970 --> 01:14:32,220
что программа сделает?

1616
01:14:32,220 --> 01:14:32,720
Еще раз?

1617
01:14:32,720 --> 01:14:33,740
ЗАЛ: Спросит снова

1618
01:14:33,740 --> 01:14:35,000
DAVID MALAN: Она не спросит снова,

1619
01:14:35,000 --> 01:14:36,950
потому что здесь нет цикла.

1620
01:14:36,950 --> 01:14:41,360
Нет ни while, ни for

1621
01:14:41,360 --> 01:14:46,190
get_char получит символ,
неизвестно какой 

1622
01:14:46,190 --> 01:14:50,900
Что произойдет, если я не введу
ни заглавную или прописную Y или N?

1623
01:14:50,900 --> 01:14:52,103
Ничего!

1624
01:14:52,103 --> 01:14:54,020
Просто ничего не произойдет, и 
это совершенно нормально

1625
01:14:54,020 --> 01:14:56,210
Программа не обязана что-то печатать

1626
01:14:56,210 --> 01:15:01,060
И в самом деле, если я запущу это снова

1627
01:15:01,060 --> 01:15:02,130
Ничего не произойдет

1628
01:15:02,130 --> 01:15:03,860
Поскольку мы ни согласились, ни отказались

1629
01:15:03,860 --> 01:15:07,910
Однако, мы могли бы добавить цикл, 
чтобы заставить пользователя ответить

1630
01:15:07,910 --> 01:15:10,117
так или иначе

1631
01:15:10,117 --> 01:15:12,200
Хорошо, давайте откроем другой пример

1632
01:15:12,200 --> 01:15:15,800
основанный на идее абстрации

1633
01:15:15,800 --> 01:15:18,980
Помните, в Scratch не было кусочка пазла

1634
01:15:18,980 --> 01:15:21,620
чтобы кот "кашлял"?

1635
01:15:21,620 --> 01:15:25,070
И мы реализовали это с нашим
собственным кусочком

1636
01:15:25,070 --> 01:15:25,850

1637
01:15:25,850 --> 01:15:30,080
Итак, я создам программу cough0.c.

1638
01:15:30,080 --> 01:15:33,140
Своеобразное определение бездействия,
но ладно

1639
01:15:33,140 --> 01:15:35,960
Я должен обновить страницу

1640
01:15:35,960 --> 01:15:38,420
Если в CS50 что-то не так,
перезагрузитесь

1641
01:15:38,420 --> 01:15:39,920
Может помочь

1642
01:15:39,920 --> 01:15:43,248
К сожалению, и в программировании
такое бывает

1643
01:15:43,248 --> 01:15:45,290
Итак, через мгонвение,

1644
01:15:45,290 --> 01:15:49,730
Я перенесу эту идею из Scratch
в программу на Си

1645
01:15:49,730 --> 01:15:54,060
Но вместо блока say использую блок printf,
или, точнее, функцию printf

1646
01:15:54,060 --> 01:15:54,990


1647
01:15:54,990 --> 01:15:58,700
А затем улучшу эту программу

1648
01:15:58,700 --> 01:16:01,920
с каждым следующим шагом.

1649
01:16:01,920 --> 01:16:07,010
Итак, я открою файл cough0.c

1650
01:16:07,010 --> 01:16:11,900
И, для начала, подключу stdio.h.

1651
01:16:11,900 --> 01:16:16,180
Затем добавлю int main void, пока что
просто не обращайте внимание на это

1652
01:16:16,180 --> 01:16:18,080


1653
01:16:18,080 --> 01:16:21,080
Затем printf, кавычки,

1654
01:16:21,080 --> 01:16:22,580
"кашель", новая строка.

1655
01:16:22,580 --> 01:16:25,050
Помните, сначала в Scratch я 
просто сделал это три раза

1656
01:16:25,050 --> 01:16:27,300
Сделаю так же и сейчас

1657
01:16:27,300 --> 01:16:31,520
Отлично, перейдем в окно терминала

1658
01:16:31,520 --> 01:16:35,330
и скажем make cough0, Enter.

1659
01:16:35,330 --> 01:16:39,470
Вроде сработало
./cough0 и "cough, cough, cough".

1660
01:16:39,470 --> 01:16:42,950
На прошлой неделе мы говорили,
что это можно сделать лучше

1661
01:16:42,950 --> 01:16:44,960
Когда вы начинаете дублировать код,

1662
01:16:44,960 --> 01:16:46,850
надо бороться с искушением,

1663
01:16:46,850 --> 01:16:49,933
потому что это может привести 
к грязному коду

1664
01:16:49,933 --> 01:16:52,133
Как мы решили проблему на той неделе? 

1665
01:16:52,133 --> 01:16:52,920
ЗАЛ: Циклом

1666
01:16:52,920 --> 01:16:54,390
DAVID MALAN: Да, циклом

1667
01:16:54,390 --> 01:16:55,682
Давайте сделаем это снова

1668
01:16:55,682 --> 01:16:57,693
Создам новую версию, cough1.c.

1669
01:16:57,693 --> 01:17:00,360
И скопирую код, чтобы было с чего начать

1670
01:17:00,360 --> 01:17:02,400
Но теперь сделаю это чище

1671
01:17:02,400 --> 01:17:04,960
Вместо дублирования кода,
использую цикл for

1672
01:17:04,960 --> 01:17:07,460
Оставим пока скобки в стороне

1673
01:17:07,460 --> 01:17:08,690
Вернемся к этому позже

1674
01:17:08,690 --> 01:17:12,530
Я хочу, чтобы программа 
кашлянула несколько раз

1675
01:17:12,530 --> 01:17:15,333
Итак, что здесь за синтаксис?

1676
01:17:15,333 --> 01:17:17,250
Это можно сделать по разному

1677
01:17:17,250 --> 01:17:18,890
Например, даже циклом while 

1678
01:17:18,890 --> 01:17:22,520
Но я скажу int и, затем, имя переменной

1679
01:17:22,520 --> 01:17:24,960
Я могу сказать counter,
или, может быть, просто i

1680
01:17:24,960 --> 01:17:28,970
чтобы сделать короче,
присвоим 0 для начала.

1681
01:17:28,970 --> 01:17:32,540
повторять пока i меньше трех,

1682
01:17:32,540 --> 01:17:38,070
И, для каждого повтора, i = i + 1
или, для краткости, i++.

1683
01:17:38,070 --> 01:17:39,710

1684
01:17:39,710 --> 01:17:41,223
Много нового!

1685
01:17:41,223 --> 01:17:43,140
И точки с запятыми повсюду!

1686
01:17:43,140 --> 01:17:46,700
Но если я скомпилирую cough1,

1687
01:17:46,700 --> 01:17:48,410
Ничего плохого не случилось

1688
01:17:48,410 --> 01:17:51,020
запускаю ./cough1:
cough, cough, cough.

1689
01:17:51,020 --> 01:17:53,180
Выглядит уже лучше, правда?

1690
01:17:53,180 --> 01:17:55,460
К несчастью, есть такое правило 
в программировании

1691
01:17:55,460 --> 01:18:00,110
что программисты начинают считать с нуля

1692
01:18:00,110 --> 01:18:02,240
Однако, если вам это не нравится,

1693
01:18:02,240 --> 01:18:05,210
Вполне можно присвоить i единицу

1694
01:18:05,210 --> 01:18:08,420
И тогда можно повторять, пока 
i меньше четырех или, точнее,

1695
01:18:08,420 --> 01:18:10,655
i меньше или равно трем.

1696
01:18:10,655 --> 01:18:13,280
Знака меньше или равно на вашей 
клавиатуре нет

1697
01:18:13,280 --> 01:18:17,390
поэтому его можно сделать из знака меньше
и знака равно, два символа.

1698
01:18:17,390 --> 01:18:18,800
Это тоже самое.

1699
01:18:18,800 --> 01:18:20,240
Присвоить i единицу

1700
01:18:20,240 --> 01:18:23,450
Напечатать "cough", и прирастить i

1701
01:18:23,450 --> 01:18:26,150
Проверить, меньше ли i трех,

1702
01:18:26,150 --> 01:18:28,850
Два меньше трех, продолжить

1703
01:18:28,850 --> 01:18:31,620
Так что два даст тот же эффект

1704
01:18:31,620 --> 01:18:36,590
Однако, по общему соглашению, 
счет с нуля используется чаще

1705
01:18:36,590 --> 01:18:42,768
Повторяй пока i равно 0 и тогда 1
и затем 2, всего три раза

1706
01:18:42,768 --> 01:18:44,810
Хорошо, однако, вспомните, 
что мы сделали в прошлый раз

1707
01:18:44,810 --> 01:18:47,540
если я пишу код, благодаря 
которому программа кашляет

1708
01:18:47,540 --> 01:18:51,800
было бы неплохо создать отдельную функцию, 

1709
01:18:51,800 --> 01:18:52,920

1710
01:18:52,920 --> 01:18:54,450
Это мы и сделаем.

1711
01:18:54,450 --> 01:18:58,430
Я создам новую функцию.

1712
01:18:58,430 --> 01:19:00,570
Сделаю это следующим образом

1713
01:19:00,570 --> 01:19:04,220
Я наберу void, затем имя функции

1714
01:19:04,220 --> 01:19:07,160
здесь я тоже напишу void,
к этому мы еще вернемся

1715
01:19:07,160 --> 01:19:10,160
И затем я скажу кашлять

1716
01:19:10,160 --> 01:19:14,120
Функции, которые мы использовали:
printf, get_int, get_string, get_float - 

1717
01:19:14,120 --> 01:19:18,650
вы не видели реализацию ни одной из них,

1718
01:19:18,650 --> 01:19:21,270
потому что люди, давным давно,
сотрудники университета и другие люди

1719
01:19:21,270 --> 01:19:23,000
реализовали эти функции для нас

1720
01:19:23,000 --> 01:19:26,270
Вы тоже можете реализовать свои 
собственные функции или,

1721
01:19:26,270 --> 01:19:29,690
как в Scratch, эти кусочки паззла
создавая блоки функций

1722
01:19:29,690 --> 01:19:31,940
Так что если вы хотите создать
свою собственную функцию cough,

1723
01:19:31,940 --> 01:19:35,960
для того, чтобы писать "cough" на экране,

1724
01:19:35,960 --> 01:19:37,010
синтаксис таков:

1725
01:19:37,010 --> 01:19:40,880
Сегодня вы просто пишете void здесь
и здесь, но имя функции важно

1726
01:19:40,880 --> 01:19:41,690


1727
01:19:41,690 --> 01:19:43,040
Я назову ее cough.

1728
01:19:43,040 --> 01:19:45,000
Я могу использовать ее вот так:

1729
01:19:45,000 --> 01:19:50,750
Я могу написать cough, cough, cough
чтобы кашлянуть три раза

1730
01:19:50,750 --> 01:19:53,150
Но мы уже знаем, что это плохой подход

1731
01:19:53,150 --> 01:19:57,770
For int i = 0, i меньше 3, i++

1732
01:19:57,770 --> 01:20:00,230
Вот теперь лучше

1733
01:20:00,230 --> 01:20:03,290
Как и в прошлый раз, 
с глаз долой - из сердца вон

1734
01:20:03,290 --> 01:20:07,460
Мне не нужно беспокоится о том,
как именно кашляет программа

1735
01:20:07,460 --> 01:20:10,850
Я забочусь о моем коде здесь,
говоря компьютеру, что делать

1736
01:20:10,850 --> 01:20:15,260
For i от 0 до 3, 
cough, cough, cough.

1737
01:20:15,260 --> 01:20:16,480
Это называется абстракция

1738
01:20:16,480 --> 01:20:18,950
Мне не важно, как именно кашляет функция

1739
01:20:18,950 --> 01:20:22,070
Мне важно, что такая функция есть

1740
01:20:22,070 --> 01:20:25,490
Давайте запустим это и посмотрим, 
что произойдет

1741
01:20:25,490 --> 01:20:28,710
Переключусь в терминал, make cough1.

1742
01:20:28,710 --> 01:20:29,750
Отлично

1743
01:20:29,750 --> 01:20:30,830
Нет ошибок

1744
01:20:30,830 --> 01:20:34,550
./cough1
cough, cough, cough.

1745
01:20:34,550 --> 01:20:38,553
Однако здесь есть одна небольшая ошибка

1746
01:20:38,553 --> 01:20:39,470
Знаете что?

1747
01:20:39,470 --> 01:20:42,890
Если я продолжк писать свои функции здесь,

1748
01:20:42,890 --> 01:20:46,145
основную часть программы сдвинет вниз

1749
01:20:46,145 --> 01:20:48,770
И есть соглашение, что основную функцию
лучше держать здесь,

1750
01:20:48,770 --> 01:20:49,790
в начале файла

1751
01:20:49,790 --> 01:20:50,790
Довольно логично

1752
01:20:50,790 --> 01:20:53,420
Вы открываете файл - 
и главная функция прямо здесь

1753
01:20:53,420 --> 01:20:54,620
Давайте тут ее и оставим

1754
01:20:54,620 --> 01:20:58,448
Так что я подвину функцию cough вниз

1755
01:20:58,448 --> 01:21:01,490
так что первое, что я увижу,
будет main, главная часть программы

1756
01:21:01,490 --> 01:21:03,020
А где там cough мне безразлично

1757
01:21:03,020 --> 01:21:05,090
Для этого мы и создали функцию

1758
01:21:05,090 --> 01:21:08,990
Итак, я переключусь в терминал 
и выполню make cough1.

1759
01:21:08,990 --> 01:21:12,500
Ага, какие-то ошибки!

1760
01:21:12,500 --> 01:21:14,030
Что же не так?

1761
01:21:14,030 --> 01:21:19,130
Ошибка, неявное объявление функции
cough недопустимо в С '99.

1762
01:21:19,130 --> 01:21:22,610
C '99 означает версию
языка Си, созданную в  1999.

1763
01:21:22,610 --> 01:21:23,690
Что же случилось?

1764
01:21:23,690 --> 01:21:25,100
Неявное объявление?

1765
01:21:25,100 --> 01:21:27,500
Этим Си тоже отличается от Scratch

1766
01:21:27,500 --> 01:21:29,840
Си уже старый язык, и 
довольно прямолинейный

1767
01:21:29,840 --> 01:21:32,840
Он знает только то, что вы ему говорите,

1768
01:21:32,840 --> 01:21:36,290
и знает только в порядке сверху вниз,
слева направо

1769
01:21:36,290 --> 01:21:41,480
В этой программе я подключил stdio.h,
как и раньше

1770
01:21:41,480 --> 01:21:43,700
Я подключил в самом начале, до main.

1771
01:21:43,700 --> 01:21:45,480
Начал цикл for

1772
01:21:45,480 --> 01:21:48,320
И затем использовал функцию cough.

1773
01:21:48,320 --> 01:21:52,640
Однако, где cough реализован?

1774
01:21:52,640 --> 01:21:54,880
Гораздо ниже, на 11 строчке

1775
01:21:54,880 --> 01:21:56,600
Си не настолько умен

1776
01:21:56,600 --> 01:21:59,510
Он не станет проверять, 
есть ли эта функция дальше,

1777
01:21:59,510 --> 01:22:02,150
может быть и есть,
1778
01:22:02,150 --> 01:22:04,070
он делает только то, что сказано

1779
01:22:04,070 --> 01:22:05,503
И вот как это исправить

1780
01:22:05,503 --> 01:22:07,670
Можно либо сделать то, что я
сделал в начале, разместить 

1781
01:22:07,670 --> 01:22:09,268
ваши функции наверху

1782
01:22:09,268 --> 01:22:11,810
но это не лучший способ,

1783
01:22:11,810 --> 01:22:13,107
Все время добавлять функции наверх

1784
01:22:13,107 --> 01:22:15,690
Однажды вы натолкнетесь 
на некоторые ограничения

1785
01:22:15,690 --> 01:22:19,070
Да и по соглашению, функцию main 
надо держать наверху

1786
01:22:19,070 --> 01:22:20,880
Но есть и другое решение

1787
01:22:20,880 --> 01:22:23,900
И это единственный случай, когда
копирование оправданнл

1788
01:22:23,900 --> 01:22:29,210
Вы буквально копируете первую строку функции

1789
01:22:29,210 --> 01:22:33,660
И вставляете ее тут, в начале файла,
с точкой с запятой


1790
01:22:33,660 --> 01:22:38,113
Это такой способ обмануть Си,
показать, что он уже видел эту функцию

1791
01:22:38,113 --> 01:22:40,530
Не всю видел, но достаточно

1792
01:22:40,530 --> 01:22:41,720
видел ее объявление,

1793
01:22:41,720 --> 01:22:45,870
и теперь может пережить ее вызов в main

1794
01:22:45,870 --> 01:22:49,130
Итак, я перекомпилирую этот код

1795
01:22:49,130 --> 01:22:51,770
make cough1 enter.

1796
01:22:51,770 --> 01:22:53,510
Хорошо, скомпилировалось.

1797
01:22:53,510 --> 01:22:59,370
./cough1, voila, все в порядке

1798
01:22:59,370 --> 01:23:00,740
Но я хочу кое-что улучшить

1799
01:23:00,740 --> 01:23:05,810
Так что откроем файл из онлайн-примеров cough3.c

1800
01:23:05,810 --> 01:23:08,600
Ваши собственные функции могут принимать аргументы

1801
01:23:08,600 --> 01:23:11,610
Слово void означает, что 
функция не принимает аргументы

1802
01:23:11,610 --> 01:23:15,938
А это слово void означает, что она 
не возвращает значения, в отличии от

1803
01:23:15,938 --> 01:23:16,730
get_int и get_string, которые 
возвращают значение

1804
01:23:16,730 --> 01:23:18,647
Сейчас это не так важно, но мы вернемся

1805
01:23:18,647 --> 01:23:20,450
к этому через неделю или две

1806
01:23:20,450 --> 01:23:24,770
Итак, предположим, что вы хотите 
сделать эту функцию более универсальной

1807
01:23:24,770 --> 01:23:28,190
Например, чтобы она сама кашляла 
необходимое количество раз

1808
01:23:28,190 --> 01:23:29,660
Можно сделать вот так:

1809
01:23:29,660 --> 01:23:34,670
Можно изменить входные аргументы так,
чтобы она принимала значение

1810
01:23:34,670 --> 01:23:38,840
И тогда можно сделать так
for int i = 0, i меньше n, i++

1811
01:23:38,840 --> 01:23:43,730
Вот так, больше никакого хардкода

1812
01:23:43,730 --> 01:23:48,650
А внутри фигурных скобок можно 
напечатать эту строку

1813
01:23:48,650 --> 01:23:52,520
Теперь функция принимает значения

1814
01:23:52,520 --> 01:23:55,430
Принимает целое число, названное n

1815
01:23:55,430 --> 01:23:58,220
И использует это число, как раньше 

1816
01:23:58,220 --> 01:24:00,740
в Scratch, чтобы сделать что-то n раз

1817
01:24:00,740 --> 01:24:04,010
Не один, не три, а каждый раз
заданное значение

1818
01:24:04,010 --> 01:24:06,360
Мне нужно поменять объявление функции здесь

1819
01:24:06,360 --> 01:24:07,520
Это называется прототип

1820
01:24:07,520 --> 01:24:09,860
Эта строчка, которую я скопировал, 
это прототип 

1821
01:24:09,860 --> 01:24:12,140

1822
01:24:12,140 --> 01:24:13,700
И вот что я теперь могу сделать

1823
01:24:13,700 --> 01:24:16,550
Моя главная функция, суть моей программы,

1824
01:24:16,550 --> 01:24:19,190
Немного запутанно

1825
01:24:19,190 --> 01:24:23,150
Не будет ли лучше, если я скажу cough 3

1826
01:24:23,150 --> 01:24:28,040
И в самом деле, мне уже неважно, как
именно реализован кашель

1827
01:24:28,040 --> 01:24:30,950
Это -  неплохо реализованная программа

1828
01:24:30,950 --> 01:24:32,300
Лишь одна строчка кода

1829
01:24:32,300 --> 01:24:33,137
Понятно, что делает

1830
01:24:33,137 --> 01:24:33,720
Кашляет

1831
01:24:33,720 --> 01:24:35,990
Функция принимает аргумент, 
определяющий количество

1832
01:24:35,990 --> 01:24:38,823
И то, что убрано вниз, я могу вернуть

1833
01:24:38,823 --> 01:24:40,770
обратно наверх, программисты

1834
01:24:40,770 --> 01:24:43,250
назвали бы это подробностями реализации

1835
01:24:43,250 --> 01:24:45,620
Кто-то должен позаботится о реализации кашля

1836
01:24:45,620 --> 01:24:48,200
но вам это не важно

1837
01:24:48,200 --> 01:24:50,530
Вам не важно, как работает get_integer

1838
01:24:50,530 --> 01:24:52,930
Вам не нужно заботится о том, 
как работает printf

1839
01:24:52,930 --> 01:24:56,140
Кто-то уже реализовал эти детали

1840
01:24:56,140 --> 01:25:00,280
Так что вы можете сделать что-то большее,
используя их труд

1841
01:25:00,280 --> 01:25:03,310
что-то, что вам важно

1842
01:25:03,310 --> 01:25:06,235
Я покажу пример, котрый строится на той же идее.

1843
01:25:06,235 --> 01:25:08,740


1844
01:25:08,740 --> 01:25:14,030
В файле positive.c есть пример,

1845
01:25:14,030 --> 01:25:16,040
Который делает это более понятным

1846
01:25:16,040 --> 01:25:20,100
Это программа, которая использует две
библиотеки, CS50 и стандартный I/O.

1847
01:25:20,100 --> 01:25:22,330
Оказывается, в CS50 нет функции 
get_positive_int.

1848
01:25:22,330 --> 01:25:24,730

1849
01:25:24,730 --> 01:25:25,772
А только get_int.

1850
01:25:25,772 --> 01:25:27,730
Представьте себе программу, которой 
подойдут только положительные числа

1851
01:25:27,730 --> 01:25:31,450
введенные человеком, 

1852
01:25:31,450 --> 01:25:33,820
а отрицательные не имеют смысла.

1853
01:25:33,820 --> 01:25:35,380
Как мы можем это реализовать?

1854
01:25:35,380 --> 01:25:38,350
Было бы здорово создать что-то

1855
01:25:38,350 --> 01:25:40,930
написать программу из пары строк,
чтобы мы могли просто вызвать

1856
01:25:40,930 --> 01:25:42,820
функцию get_positive_int.

1857
01:25:42,820 --> 01:25:46,720
И если я пролистаю вниз,
заметьте новую особенность Си

1858
01:25:46,720 --> 01:25:49,810
чего мы еще не видели,
интересный пример

1859
01:25:49,810 --> 01:25:52,600
одной возможности в Си
которую я подстветил здесь

1860
01:25:52,600 --> 01:25:56,350
между строками 15 и 24

1861
01:25:56,350 --> 01:25:58,510
Функция get_positive_int.

1862
01:25:58,510 --> 01:26:01,690
Она не принимает аргументов, мне
нечего указывать в скобках

1863
01:26:01,690 --> 01:26:03,850
Мне просто нужно положительное целое число

1864
01:26:03,850 --> 01:26:06,670
Так что мне нужен ответ от этой функции

1865
01:26:06,670 --> 01:26:09,850
В точности как get_int вернул мне значение,
которое я сохранил в переменную

1866
01:26:09,850 --> 01:26:11,170
Так же как и get_string.

1867
01:26:11,170 --> 01:26:13,030
Так что это не пустота, не void.

1868
01:26:13,030 --> 01:26:13,990
Это integer

1869
01:26:13,990 --> 01:26:17,290
Это слово слева от функции обозночает 
тип данных, которые она возвращает

1870
01:26:17,290 --> 01:26:20,920
Слова в скобках - тип входящих аргументов

1871
01:26:20,920 --> 01:26:24,640
А если их нет - просто напишите пусто, void

1872
01:26:24,640 --> 01:26:26,190
Теперь, интересно, 

1873
01:26:26,190 --> 01:26:30,280
на строке 17, мы такого не видели раньше
здесь просто подсказка для компьютера

1874
01:26:30,280 --> 01:26:32,425
говорящая: дай мне переменную n

1875
01:26:32,425 --> 01:26:34,300
Я пока не знаю, что здесь будет, 

1876
01:26:34,300 --> 01:26:36,580
Так что здесь буквально int n;

1877
01:26:36,580 --> 01:26:38,405
Присваивать пока нечего.

1878
01:26:38,405 --> 01:26:40,030
Оно имеет так называемое мусорное значение.

1879
01:26:40,030 --> 01:26:42,322
Ни малейшего представления, 
что там внутри, но и неважно

1880
01:26:42,322 --> 01:26:43,730
Зададим значение позже

1881
01:26:43,730 --> 01:26:45,820
Затем такой цикл, которого мы еще не видели

1882
01:26:45,820 --> 01:26:47,800
В языке Си это называется do-while цикл

1883
01:26:47,800 --> 01:26:52,120
Это означает "Повторяй, пока это условие верно"

1884
01:26:52,120 --> 01:26:53,320
Итак, что же мне делать

1885
01:26:53,320 --> 01:26:55,330
Я хочу получить целое число от пользователя,

1886
01:26:55,330 --> 01:26:58,540
Прошу его ввести значение и
сохраняю в переменной

1887
01:26:58,540 --> 01:27:03,010
Однако, я продолжаю это делать,
пока число меньше одного

1888
01:27:03,010 --> 01:27:06,370
Потому что ессли введен ноль, или минус один

1889
01:27:06,370 --> 01:27:12,040
Или любое другое не-положительное число, 
я хочу спросить снова и снова

1890
01:27:12,040 --> 01:27:14,530
Итак, do-while цикл очень удобный

1891
01:27:14,530 --> 01:27:17,090
Потому что он выполняет действие
минимум один раз

1892
01:27:17,090 --> 01:27:20,200
Затем проверяет условие и
может выполнить еще раз

1893
01:27:20,200 --> 01:27:22,450
Если ввод неверный

1894
01:27:22,450 --> 01:27:25,900
Обычный цикл while, если вспомнить,
всегда проверяет условие в начале.

1895
01:27:25,900 --> 01:27:29,590
Пока условие выполнено, сделай что-то

1896
01:27:29,590 --> 01:27:34,210
А этот цикл всегда выполняется
хотя бы один раз

1897
01:27:34,210 --> 01:27:35,767
И уже потом проверяет условие

1898
01:27:35,767 --> 01:27:37,600
Это просто другой подход

1899
01:27:37,600 --> 01:27:40,090
Хотя мы могли бы сделать все при помощи

1900
01:27:40,090 --> 01:27:46,550
циклов while или даже for

1901
01:27:46,550 --> 01:27:50,080
Хорошо, теперь давайте сделаем программу 
более дружественной к пользователю

1902
01:27:50,080 --> 01:27:54,790
Я открою другие примеры, которые

1903
01:27:54,790 --> 01:27:56,060
могут выглядеть знакомо

1904
01:27:56,060 --> 01:27:58,488
Так что если я открою, например,

1905
01:27:58,488 --> 01:28:00,280
вот этот слайд, вы можете вспомнить эту игру

1906
01:28:00,280 --> 01:28:04,000
прошлых лет, Super Mario Brothers
от самой Nintendo.

1907
01:28:04,000 --> 01:28:07,510
Эта игра может выглядеть вот так:

1908
01:28:07,510 --> 01:28:09,100
Например, вот эти маленькие кирпичи в воздухе

1909
01:28:09,100 --> 01:28:11,200
Если Марио или Луиджи ударят их,

1910
01:28:11,200 --> 01:28:13,450
выскочит монетка или что-нибудь ещё

1911
01:28:13,450 --> 01:28:16,810
Давайте подумаем, как такое можно 

1912
01:28:16,810 --> 01:28:18,535
реализовать программно?

1913
01:28:18,535 --> 01:28:21,160
Например, как мне написать программу,

1914
01:28:21,160 --> 01:28:23,800
которая просто печатает 4 
вопросительных знака?

1915
01:28:23,800 --> 01:28:26,920
Я открою один пример,

1916
01:28:26,920 --> 01:28:30,100
пример под названием mario0.c.

1917
01:28:30,100 --> 01:28:33,087
И я утверждаю, что это один из 
способов выполнить эту задачу

1918
01:28:33,087 --> 01:28:35,170
Очень просто, исключительно знаки вопроса

1919
01:28:35,170 --> 01:28:39,400
больше ничего не рисует,
но выполняет эту задачу

1920
01:28:39,400 --> 01:28:41,800
И в самом деле, где-то в коде Марио

1921
01:28:41,800 --> 01:28:43,600
есть строка кода вроде такой

1922
01:28:43,600 --> 01:28:47,950
говорящая консольной игре вывести
вопрос, вопрос

1923
01:28:47,950 --> 01:28:48,970
вопрос, вопрос

1924
01:28:48,970 --> 01:28:51,760
В Си, мы определенно можем это сделать
с четырьмя вопросительными знаками

1925
01:28:51,760 --> 01:28:55,048
Но есть ли способ лучше?

1926
01:28:55,048 --> 01:28:55,840
ЗАЛ: Цикл for

1927
01:28:55,840 --> 01:28:57,465
DAVID MALAN: Да, цикл for

1928
01:28:57,465 --> 01:29:00,310
Итак, я продолжу и открою

1929
01:29:00,310 --> 01:29:05,200
следующий пример mario2.c,
который все это делает

1930
01:29:05,200 --> 01:29:08,500
Обратите внимание, как это работает:

1931
01:29:08,500 --> 01:29:12,010
В блоке main, я прошу ввести integer n.

1932
01:29:12,010 --> 01:29:14,630
Делать следующее пока n меньше 1.

1933
01:29:14,630 --> 01:29:18,820
Это просто способ спросить,
сколько нужно блоков напечатать?

1934
01:29:18,820 --> 01:29:20,140

1935
01:29:20,140 --> 01:29:24,190
Как только я получу ответ, 
можно двигаться дальше

1936
01:29:24,190 --> 01:29:28,940
Напечатать столько-то знаков вопроса,
один за одним

1937
01:29:28,940 --> 01:29:32,080
И в самом конце, я напечатаю
знак новой линии

1938
01:29:32,080 --> 01:29:35,470
Итак, вкратце, если хотите 
создать программу

1939
01:29:35,470 --> 01:29:37,760
которая делает что-то вроде этого, 
скомпилирую её make mario2

1940
01:29:37,760 --> 01:29:38,410
Упс

1941
01:29:38,410 --> 01:29:43,510
Итак, make mario2,
Enter, запустим ./mario2,

1942
01:29:43,510 --> 01:29:46,510
Я могу задать ширину в 4
и получу 4 блока

1943
01:29:46,510 --> 01:29:49,730
Или я могу задать 50 и 
получу их все на экран

1944
01:29:49,730 --> 01:29:51,480
Используя эти простые шаги

1945
01:29:51,480 --> 01:29:54,660
Но заметьте, из-за этого цикла do-while, 
если я не введу положительное число

1946
01:29:54,660 --> 01:29:58,110
А введу ноль, -1 или -50

1947
01:29:58,110 --> 01:30:02,160
Меня попросят ввести значение снова,
поскольку n меньше 1.

1948
01:30:02,160 --> 01:30:05,130
Вот такая логика здесь реализована

1949
01:30:05,130 --> 01:30:10,018
Но давайте продолжим и перейдем
к следующему примеру Mario,

1950
01:30:10,018 --> 01:30:12,060
и кирпичиков у нас будет побольше

1951
01:30:12,060 --> 01:30:16,000
В этот раз, это не просто ряд кирпичей,

1952
01:30:16,000 --> 01:30:17,755
В этот раз они уже двухмерные

1953
01:30:17,755 --> 01:30:20,130
Это уже гораздо интереснее,

1954
01:30:20,130 --> 01:30:23,200
потому что нам надо 

1955
01:30:23,200 --> 01:30:25,158
из простых напечатанных символов 

1956
01:30:25,158 --> 01:30:26,700
сделать двухмерную структуру

1957
01:30:26,700 --> 01:30:30,090
Ну что же, в Си, как и в Scratch,
это можно сделать

1958
01:30:30,090 --> 01:30:33,540
с помощью циклов

1959
01:30:33,540 --> 01:30:35,650
Позвольте мне показать вам этот пример:

1960
01:30:35,650 --> 01:30:38,070
В первой строке кода

1961
01:30:38,070 --> 01:30:41,938
Я спрошу о размере блока

1962
01:30:41,938 --> 01:30:44,730
Я хочу создать квадратный блок

1963
01:30:44,730 --> 01:30:47,710
много-много кирпичиков

1964
01:30:47,710 --> 01:30:51,270
Я могу запросить целое число,

1965
01:30:51,270 --> 01:30:53,500
снова и снова и снова,

1966
01:30:53,500 --> 01:30:54,930
И обратите внимание:

1967
01:30:54,930 --> 01:30:58,770
Получается сложновато,
но логика понятна

1968
01:30:58,770 --> 01:31:02,520
Итак, for int i = 0, i < n, i++

1969
01:31:02,520 --> 01:31:04,500
Сделай это n раз, верно?

1970
01:31:04,500 --> 01:31:08,220
Вот такой способ сказать сделай это n раз

1971
01:31:08,220 --> 01:31:10,170
А что на строке 16?

1972
01:31:10,170 --> 01:31:13,740
Что она говорит?

1973
01:31:13,740 --> 01:31:16,710
Она использует другую переменную,

1974
01:31:16,710 --> 01:31:18,869
использует j вместо i.

1975
01:31:18,869 --> 01:31:19,744
ЗАЛ: Тоже самое

1976
01:31:19,744 --> 01:31:20,786
Сделай это n раз

1977
01:31:20,786 --> 01:31:24,180
DAVID MALAN: Да, тоже самое
Сделай это n раз

1978
01:31:24,180 --> 01:31:26,880
Однако, оно считает j вместо i,

1979
01:31:26,880 --> 01:31:30,100
это чтобы счет не перемешался

1980
01:31:30,100 --> 01:31:32,580
Если вы подумаете о том,
что такое блок в Mario,

1981
01:31:32,580 --> 01:31:35,318
это как печатать строки и столбцы.

1982
01:31:35,318 --> 01:31:37,860
Как старая печатная машинка, 
которая печатает 

1983
01:31:37,860 --> 01:31:41,250
слева направа и, затем, одна строка
вниз - и снова слева направо

1984
01:31:41,250 --> 01:31:44,610
И так далее, чтобы напечатать 
различные блоки на разных строчках

1985
01:31:44,610 --> 01:31:47,010
Я открою mario8...

1986
01:31:47,010 --> 01:31:48,730
make-- упс

1987
01:31:48,730 --> 01:31:53,193
Итак, make mario8, ./mario8.

1988
01:31:53,193 --> 01:31:54,360
Какой размер мне нужен?

1989
01:31:54,360 --> 01:31:55,680
Допустим, три

1990
01:31:55,680 --> 01:32:00,030
И мы видим три строки и три столбца

1991
01:32:00,030 --> 01:32:03,930
которые представляют мои строки

1992
01:32:03,930 --> 01:32:05,830
Я считаю от i и до...

1993
01:32:05,830 --> 01:32:07,450
Ох

1994
01:32:07,450 --> 01:32:10,980
Учу сам себя, мда

1995
01:32:10,980 --> 01:32:11,760
Давайте еще раз

1996
01:32:11,760 --> 01:32:13,950
Вот чему  так радовался

1997
01:32:13,950 --> 01:32:16,770
Когда я запустил программу,
1998
01:32:16,770 --> 01:32:19,140
то получил 3 на 3 квадрат блоков

1999
01:32:19,140 --> 01:32:21,450
И если я запущу ее снова, но уже с десятью,

2000
01:32:21,450 --> 01:32:24,003
я получу еще больший объект, 
уже 10 на 10

2001
01:32:24,003 --> 01:32:26,670
Он несколько выше, чем шире, потому что 

2002
01:32:26,670 --> 01:32:27,960
этот знак выше. чем шире

2003
01:32:27,960 --> 01:32:30,390
И вы видите, что программа работает

2004
01:32:30,390 --> 01:32:31,950
Итак, как это работает?

2005
01:32:31,950 --> 01:32:33,950
Если мы посмотрим на код

2006
01:32:33,950 --> 01:32:36,750
обратите внимание на строку 14

2007
01:32:36,750 --> 01:32:39,030
Она выводит строку за строкой

2008
01:32:39,030 --> 01:32:43,170
Она создает n строк, и каждая из 
этих строк состоит из i0,

2009
01:32:43,170 --> 01:32:46,020
i1, i2, и так далее.

2010
01:32:46,020 --> 01:32:50,650
Тем временем, для каждой строки, 
я использую вложенный цикл,

2011
01:32:50,650 --> 01:32:54,900
вложенный цикл выводит эти
символы слева направа

2012
01:32:54,900 --> 01:32:55,990
слева направо

2013
01:32:55,990 --> 01:32:58,680
Для каждой строки: hash, hash, hash

2014
01:32:58,680 --> 01:33:00,750
Для каждой строки: hash, hash, hash

2015
01:33:00,750 --> 01:33:03,670
Это и создает двухмерный объект

2016
01:33:03,670 --> 01:33:06,900
используя те же самые фундаментальные идеи

2017
01:33:06,900 --> 01:33:11,370
Просто цикл, который считает
что-то с нуля и далее

2018
01:33:11,370 --> 01:33:16,032
до заданного значения, делая
что-то снова и снова

2019
01:33:16,032 --> 01:33:18,240
Так что если вы видите в современных играх

2020
01:33:18,240 --> 01:33:21,150
или в компьютерной графике,
каждый раз, когда вы видите повторение

2021
01:33:21,150 --> 01:33:24,600
Неважно, в двух измерениях,

2022
01:33:24,600 --> 01:33:26,712
или вертикально, или горизонтально

2023
01:33:26,712 --> 01:33:29,670
Если некое явление повторяется снова и снова

2024
01:33:29,670 --> 01:33:33,510
То в Си или в Scracth или в других языках
это может быть сведено

2025
01:33:33,510 --> 01:33:36,780
буквально к нескольким строкам кода

2026
01:33:36,780 --> 01:33:39,270
Это напоминает об одной из первых вещей, 

2027
01:33:39,270 --> 01:33:41,760
Которые вы сделаете в качестве 
домашнего задания, problem set 1.

2028
01:33:41,760 --> 01:33:45,180
Вы используете CS50 Lab, которая
идентична CS50 Sandbox

2029
01:33:45,180 --> 01:33:48,090
которую я использовал,
но там добавлены инструкции,

2030
01:33:48,090 --> 01:33:52,170
и настоящие проблемы для решения

2031
01:33:52,170 --> 01:33:55,470
Но перед этим, давайте

2032
01:33:55,470 --> 01:34:00,720
поговорим еще о некоторых нюансах

2033
01:34:00,720 --> 01:34:03,060
До сих пор, все ошибки в моем коде

2034
01:34:03,060 --> 01:34:06,990
были моими собственными, некоторые
намеренно, некоторые нет

2035
01:34:06,990 --> 01:34:10,560
Однако и сами компьютеры имеют некоторые ограничения

2036
01:34:10,560 --> 01:34:12,810
Внутри вашего компьютера есть 

2037
01:34:12,810 --> 01:34:14,372
так называемая память, RAM

2038
01:34:14,372 --> 01:34:16,080
Обычно ее не видно,

2039
01:34:16,080 --> 01:34:18,900
пока не снимешь крышку

2040
01:34:18,900 --> 01:34:22,680
В памяти RAM хранится вся информация
ваших программ, пока они выполняются

2041
01:34:22,680 --> 01:34:26,190
В RAM хранятся данные и файлы,

2042
01:34:26,190 --> 01:34:27,540
пока они открыты

2043
01:34:27,540 --> 01:34:30,930
Эту память компьютер использует, 
чтобы делать несколько дел сразу

2044
01:34:30,930 --> 01:34:32,440
там все это хранится

2045
01:34:32,440 --> 01:34:35,430
Однако, по природе объем памяти не бесконечен

2046
01:34:35,430 --> 01:34:38,610
У вас может быть, допустим, 
один гигабайт памяти

2047
01:34:38,610 --> 01:34:41,400
Может быть четыре гигабайта,

2048
01:34:41,400 --> 01:34:44,280
Количество доступной памяти
ограничено, конечно,

2049
01:34:44,280 --> 01:34:48,040
Что означает, что есть некоторые
фундаментальные ограничения того,

2050
01:34:48,040 --> 01:34:48,540
что компьютер может делать

2051
01:34:48,540 --> 01:34:52,350
Он не может считать до бесконечности,
как бы он считал до бесконечности,

2052
01:34:52,350 --> 01:34:57,020
это невозможно - сохранить бесконечное
множество цифр в конечной памяти

2053
01:34:57,020 --> 01:34:59,370
Так что есть некоторые ограничения

2054
01:34:59,370 --> 01:35:01,230
которые мы только начинаем видеть

2055
01:35:01,230 --> 01:35:02,890
Итак, давайте кое-что сделаем

2056
01:35:02,890 --> 01:35:06,445
Напишем программу float.c.

2057
01:35:06,445 --> 01:35:09,570
это будет программа, которая получит 
от пользователя 

2058
01:35:09,570 --> 01:35:11,980
пару дробных чисел

2059
01:35:11,980 --> 01:35:15,000
Подключим библиотеку CS50

2060
01:35:15,000 --> 01:35:19,420
подключим stdio.h, int main void, 
как и раньше

2061
01:35:19,420 --> 01:35:22,488
Все что мне сейчас нужно - это получить пару дробей

2062
01:35:22,488 --> 01:35:23,280
Итак, введите число с запятой

2063
01:35:23,280 --> 01:35:24,420
Назовем переменную икс.

2064
01:35:24,420 --> 01:35:26,808
Get_float, попрошу ввести икс.

2065
01:35:26,808 --> 01:35:28,350
Теперь получим другую

2066
01:35:28,350 --> 01:35:29,370
Назову игрек.

2067
01:35:29,370 --> 01:35:31,380
Get_float, кавычки, игрек.

2068
01:35:31,380 --> 01:35:34,110
Помните, float - это число 

2069
01:35:34,110 --> 01:35:36,475
с точкой, десятичная дробь,
действительное число

2070
01:35:36,475 --> 01:35:38,100
А теперь сделаем самое простое деление

2071
01:35:38,100 --> 01:35:40,990
Я уже говорил, что компьютеры умеют
складывать, вычитать и так далее

2072
01:35:40,990 --> 01:35:41,920
Сделаем это

2073
01:35:41,920 --> 01:35:46,410
Скажем ему поделить икс на игрек

2074
01:35:46,410 --> 01:35:52,150
%f бэкслэш n икс / игрек 
точка с запятой

2075
01:35:52,150 --> 01:35:55,110
Вот такой крайне простой калькулятор

2076
01:35:55,110 --> 01:35:57,510
который я сделал, 
поддерживает только деление

2077
01:35:57,510 --> 01:36:04,170
продолжим и скомпилируем
make floats.

2078
01:36:04,170 --> 01:36:05,820
Скомпилировалось

2079
01:36:05,820 --> 01:36:07,980
./floats

2080
01:36:07,980 --> 01:36:09,570
Икс будет равно одному

2081
01:36:09,570 --> 01:36:10,960
Игрек будет равно 10.

2082
01:36:10,960 --> 01:36:12,120
Вуаля.

2083
01:36:12,120 --> 01:36:15,501
Икс деленное на игрек бует равно 0.10000.

2084
01:36:15,501 --> 01:36:16,440
Неплохо

2085
01:36:16,440 --> 01:36:19,570
Помните, если лишние нули не нужны,
можно упростить

2086
01:36:19,570 --> 01:36:23,160
добавив 0.1.

2087
01:36:23,160 --> 01:36:25,950
Перекомпилируем и перезапустим

2088
01:36:25,950 --> 01:36:27,790
Итак, 1 поделить на 10

2089
01:36:27,790 --> 01:36:29,820
Ну вот, равно одной десятой

2090
01:36:29,820 --> 01:36:30,930
Равно ли?

2091
01:36:30,930 --> 01:36:33,660
Посмотрим подальше за точку

2092
01:36:33,660 --> 01:36:36,900
Сделаем число точнее,

2093
01:36:36,900 --> 01:36:40,440
Допустим, я хочу получить 10
знаков после точки

2094
01:36:40,440 --> 01:36:48,210
перезапустим программу,
make floats, ./floats, 1, 10.

2095
01:36:48,210 --> 01:36:49,920
Интересно!

2096
01:36:49,920 --> 01:36:51,627
Да, выглядит странно

2097
01:36:51,627 --> 01:36:52,710
Может, просто случайность?

2098
01:36:52,710 --> 01:36:54,043
Посмотрим чуть дальше

2099
01:36:54,043 --> 01:36:56,080
Допустим, 50 знаков после запятой

2100
01:36:56,080 --> 01:36:57,887
Давайте я пересоберу.

2101
01:36:57,887 --> 01:36:59,970
Кстати, здесь есть некоторые
горячие клавиши
And it turns out, there's
some keyboard shortcuts.

2102
01:36:59,970 --> 01:37:02,100
я сейчас жму вверх и вниз
на моей клавиатуре, это

2103
01:37:02,100 --> 01:37:04,302
позволяет мне ходить
по всей моей истории команд

2104
01:37:04,302 --> 01:37:06,010
поэтому вам не надо ничего
запоминать.

2105
01:37:06,010 --> 01:37:08,130
Итак, чтобы сэкономить время,
я просто переключаюсь вверх и вниз.

2106
01:37:08,130 --> 01:37:11,85
Давайте я сделаю
./floats теперь, 1, 10.

2107
01:37:11,850 --> 01:37:14,820
Боже мой, деление это ложь.

2108
01:37:14,820 --> 01:37:18,660
Так что если ваш школьный учитель,
или кто бы то ни был учил вас что 1 деленное на 10

2109
01:37:18,660 --> 01:37:24,690
это 1/10, или 0.1, с бесконечными нулями,
это очевидно неправда.

2110
01:37:24,690 --> 01:37:28,810
В компьютере 1/10 это вот
это значение.

2111
01:37:28,810 --> 01:37:31,500
Так на чем мы остановимся?

2112
01:37:31,500 --> 01:37:36,180
Кто прав, начальная школа
или компьютеры?

2113
01:37:36,180 --> 01:37:39,150
Кто может обьяснить?

2114
01:37:39,150 --> 01:37:40,860
Есть какие-то мысли?

2115
01:37:40,860 --> 01:37:41,850
Да?

2116
01:37:41,850 --> 01:37:45,550
АУДИТОРИЯ: Компьютер может сохранить
только ограниченное количество символов,

2117
01:37:45,550 --> 01:37:47,300
так что непонятно что происходит
с тем что не получилось сохранить.

2118
01:37:47,300 --> 01:37:48,800
DAVID MALAN: Да, хорошее обьяснение

2119
01:37:48,800 --> 01:37:51,200
Компьютеры могут только хранить
ограниченный обьем информации,

2120
01:37:51,200 --> 01:37:52,908
поэтому в какой то момент
непонятно что происходит дальше.

2121
01:37:52,908 --> 01:37:53,480
Мне оно нравится.

2122
01:37:53,480 --> 01:37:54,710
Потому что оно очень верное.

2123
01:37:54,710 --> 01:37:57,120
Если у вас ограниченное количество
оборудования,

2124
01:37:57,120 --> 01:38:00,830
например ограниченный обьем памяти,
в какой то момент компьютер решит:

2125
01:38:00,830 --> 01:38:02,780
"я не могу хранить больше чем это значение".

2126
01:38:02,780 --> 01:38:06,890
Или "я не могу хранить больше
чем вот столько знаков после точки".

2127
01:38:06,890 --> 01:38:09,290
Мы используем 32 бита,
которые представлены типом float.

2128
01:38:09,290 --> 01:38:12,470
Вы можете использовать больше бит, как,
например double, который я описывал раньше,

2129
01:38:12,470 --> 01:38:14,720
он использует буквально
в два раза больше битов, 64.

2130
01:38:14,720 --> 01:38:19,580
Что значит мы можем пойти дальше от
точки, прежде чем увидим неточности.

2131
01:38:19,580 --> 01:38:20,870
Но вы их обязательно увидите.

2132
01:38:20,870 --> 01:38:24,440
Компьютеры не идеальны,
в этом плане.

2133
01:38:24,440 --> 01:38:26,780
Они могут хранить только
ограниченный обьем информации.

2134
01:38:26,780 --> 01:38:31,190
И в этом смысле, компьютер
хранит настолько точное значение

2135
01:38:31,190 --> 01:38:34,190
для 1 деленного на 10, насколько может.

2136
01:38:34,190 --> 01:38:38,090
Потому что вы вероятно не можете
хранить бесконечное число цифр

2137
01:38:38,090 --> 01:38:42,080
со 100% точностью, используя
ограниченный обьем информации.

2138
01:38:42,080 --> 01:38:44,060
И мы еще увидим это в
другом контексте.

2139
01:38:44,060 --> 01:38:48,530
Давайте я напишу еще одну
программу по имени overflow.c.

2140
01:38:48,530 --> 01:38:50,990
И мы увидим ту же проблему
в другом свете.

2141
01:38:50,990 --> 01:38:54,350
Я включаю stdio.h.

2142
01:38:54,350 --> 01:38:57,410
Пишу int main void.

2143
01:38:57,410 --> 01:39:01,190
int i равен единице.

2144
01:39:01,190 --> 01:39:07,478
Тааак, нет условия, потом делать i раз
умноженное на 2.

2145
01:39:07,478 --> 01:39:09,020
И затем я просто напишу.

2146
01:39:09,020 --> 01:39:11,840
Напечатать значение i.

2147
01:39:11,840 --> 01:39:15,440
Да, я пишу быстро, но
я только что написал программу, которая

2148
01:39:15,440 --> 01:39:17,510
начнет считать в нуле.

2149
01:39:17,510 --> 01:39:19,430
Она умножит i.

2150
01:39:19,430 --> 01:39:22,562
Звездочка равно значит на два
снова и снова.

2151
01:39:22,562 --> 01:39:25,520
И я буду это делать вечно, потому что,
я намеренно

2152
01:39:25,520 --> 01:39:27,380
не задал булево условие здесь.

2153
01:39:27,380 --> 01:39:29,352
Я мог написать что то типа
true,

2154
01:39:29,352 --> 01:39:30,810
но я также могу оставить его пустым.

2155
01:39:30,810 --> 01:39:32,310
Это значит делать вечно.

2156
01:39:32,310 --> 01:39:33,590
Это бесконечный цикл.

2157
01:39:33,590 --> 01:39:36,950
Оно очень быстро пролетит на этом экране.

2158
01:39:36,950 --> 01:39:40,190
Поэтому я скажу ему спать
одну секунду между выполнениями.

2159
01:39:40,190 --> 01:39:43,010
И это функция в C, по имени sleep.

2160
01:39:43,010 --> 01:39:45,230
Но чтобы ее использовать, вам
нужно подключить

2161
01:39:45,230 --> 01:39:50,092
другой файл по имени unistandard.h.

2162
01:39:50,092 --> 01:39:52,550
Вы можете узнать об этом только
прочтя документацию,

2163
01:39:52,550 --> 01:39:55,820
но это удобная функция, которая
позволит мне спать одну секунду.

2164
01:39:55,820 --> 01:39:57,920
Давайте сделаем переполнение.

2165
01:39:57,920 --> 01:39:58,650
No errors.

2166
01:39:58,650 --> 01:40:00,650
Я увеличу экран.

2167
01:40:00,650 --> 01:40:02,600
И запущу переполнение.

2168
01:40:02,600 --> 01:40:06,530
И мы увидим, что каждую секунду оно
печатает значение начинающееся с одного,

2169
01:40:06,530 --> 01:40:08,780
потом удваивает,
и удваивает,

2170
01:40:08,780 --> 01:40:10,760
и удваивает снова.

2171
01:40:10,760 --> 01:40:13,220
Вы можете вспомнить некоторые
из этих значений с прошлой недели,

2172
01:40:13,220 --> 01:40:16,620
где я предположил что в телефонной
книге 1024 страницы, а потом

2173
01:40:16,620 --> 01:40:18,893
их число становилось меньше и
меньше и меньше.

2174
01:40:18,893 --> 01:40:20,310
Теперь мы делаем это в обратную сторону.

2175
01:40:20,310 --> 01:40:22,970
Мы умножаем на два, на два, на два.

2176
01:40:22,970 --> 01:40:26,090
Мы теперь за миллионом,
2 миллиона, 4 миллиона, 8 миллионов,

2177
01:40:26,090 --> 01:40:27,077
16 миллионов.

2178
01:40:27,077 --> 01:40:28,160
И все еще растет.

2179
01:40:28,160 --> 01:40:30,770
Так что получается
integerы достаточно большие.

2180
01:40:30,770 --> 01:40:35,720
Они используют 32 бита в компьютере,
что очевидно--

2181
01:40:35,720 --> 01:40:38,150
что только что произошло?

2182
01:40:38,150 --> 01:40:39,170
Еще одна ложь.

2183
01:40:39,170 --> 01:40:44,360
Если вы постоянно умножаете какой нибудь
integer на два, он в итоге становится нулем,

2184
01:40:44,360 --> 01:40:46,310
получается так.

2185
01:40:46,310 --> 01:40:48,153
Это как то не очень верно.

2186
01:40:48,153 --> 01:40:49,070
Но что случилось?

2187
01:40:49,070 --> 01:40:51,770
Тут есть некоторый трюк, и в имени
моей программы

2188
01:40:51,770 --> 01:40:53,240
и в этой красной ошибке.

2189
01:40:53,240 --> 01:40:56,750
В какой то момент у вас есть
вот столько бит

2190
01:40:56,750 --> 01:40:59,840
после которых если продолжать
увеличивать,

2191
01:40:59,840 --> 01:41:02,600
у вас уже нет столько битов, чтобы
продолжать увеличение, чтобы

2192
01:41:02,600 --> 01:41:04,580
запомнить еще большие значения.

2193
01:41:04,580 --> 01:41:08,000
В итоге, если мы вернемся к некоторым
вещам, которые мы обсуждали

2194
01:41:08,000 --> 01:41:12,240
это называется неточностью плавающей точки
или вот теперь переполнением integer,

2195
01:41:12,240 --> 01:41:14,720
что значит floatы могут быть
лишь настолько точными

2196
01:41:14,720 --> 01:41:16,830
и integerы лишь настолько большими.

2197
01:41:16,830 --> 01:41:18,670
Так что у вас есть следующий сценарий.

2198
01:41:18,670 --> 01:41:21,253
123 десятичная, в нашем человеческом мире--

2199
01:41:21,253 --> 01:41:23,170
вы конечно можете продолжать
добавлять единицы к нему.

2200
01:41:23,170 --> 01:41:26,630
И как только вы достигните
девяти, число округляется до нуля.

2201
01:41:26,630 --> 01:41:29,240
Затем вы переносите
единицу, и у вас 130.

2202
01:41:29,240 --> 01:41:30,380
Это прекрасно работает.

2203
01:41:30,380 --> 01:41:36,050
Но, конечно, даже в десятичной системе, если
вы сейчас на числе 999, и используете при этом только три цифры,

2204
01:41:36,050 --> 01:41:39,440
и вы пытаетесь добавить еще единицу, вы ее
переносите, переносите,

2205
01:41:39,440 --> 01:41:41,000
и вы теряете одиницу.

2206
01:41:41,000 --> 01:41:41,840
Прошу прощения.

2207
01:41:41,840 --> 01:41:43,110
Что произойдет дальше?

2208
01:41:43,110 --> 01:41:47,030
Значение становится 1, 0, 0, 0.

2209
01:41:47,030 --> 01:41:50,420
Но если у вас есть только три
цифры, вы теряете ту начальную,

2210
01:41:50,420 --> 01:41:51,890
и вы остались только с нулем.

2211
01:41:51,890 --> 01:41:53,150
То же самое происходит в двоичном формате.

2212
01:41:53,150 --> 01:41:54,690
Теперь, если вы поменяете контекст--

2213
01:41:54,690 --> 01:41:58,860
а это в двоичном виде какое число?

2214
01:41:58,860 --> 01:42:01,580
Это место четверки,
это место двойки и единицы.

2215
01:42:01,580 --> 01:42:02,420
Так что это 7.

2216
01:42:02,420 --> 01:42:04,280
4 плюс 2 плюс 1, это 7.

2217
01:42:04,280 --> 01:42:06,230
Так что, конечно, если вы
добавите 1 к 7, вы бы хотели

2218
01:42:06,230 --> 01:42:10,010
получить 8, что даст вам 1, 0, 0.

2219
01:42:10,010 --> 01:42:13,370
Но если у вас есть только
три бита, три цифры,

2220
01:42:13,370 --> 01:42:15,740
у вас будет переполнение (overflow), так сказать.

2221
01:42:15,740 --> 01:42:19,400
Вы потеряте ту единицу, которую переносили, так что
что значение, которое вы действительно храните

2222
01:42:19,400 --> 01:42:20,600
это просто ноль.

2223
01:42:20,600 --> 01:42:23,600
Вот почему, если я считаю и получаются достаточно большие
целые числа в программе,

2224
01:42:23,600 --> 01:42:28,010
то, как только я наберу миллиарды, в конце концов,
это будет много -

2225
01:42:28,010 --> 01:42:30,620
Так как всего 32 бита.

2226
01:42:30,620 --> 01:42:33,530
Мы не можем набрать число больше.

2227
01:42:33,530 --> 01:42:35,240
Это то, что называется избытком целых чисел.

2228
01:42:35,240 --> 01:42:38,340
И если вы когда-нибудь слышали о проблеме 2000 года,

2229
01:42:38,340 --> 01:42:43,340
это была ужасная, очень простая проблема,
которую люди создали сами для себя

2230
01:42:43,340 --> 01:42:46,960
когда-то, в середине 1900-х годов,
когда компьютеры были изобретены

2231
01:42:46,960 --> 01:42:50,410
Люди решили сохранить место,
что было очень разумно, потому что место был дорогим

2232
01:42:50,410 --> 01:42:51,260
в самом начале.

2233
01:42:51,260 --> 01:42:58,452
Вместо того, чтобы хранить обозначение года как 1999
или же 1970 как 1970, что они сделали?

2234
01:42:58,452 --> 01:43:00,160
Да, они просто хранили 2 последние цифры, так?

2235
01:43:00,160 --> 01:43:01,480
"О конечно же, мы
не собираюсь использовать

2236
01:43:01,480 --> 01:43:03,190
эти компьютеры через 50 лет.

2237
01:43:03,190 --> 01:43:04,570
Давайте просто хранить две цифры."

2238
01:43:04,570 --> 01:43:06,573
К сожалению, это было не так.

2239
01:43:06,573 --> 01:43:09,490
И было много программ
и много компьютеров

2240
01:43:09,490 --> 01:43:12,040
которые все еще продолжали работать в 1999 году.

2241
01:43:12,040 --> 01:43:17,080
Но если вы храните только две
цифры и вы добавляете единицу к значению

2242
01:43:17,080 --> 01:43:20,020
года, то вы бы, конечно,
хотели, чтобы получился 2000

2243
01:43:20,020 --> 01:43:25,120
но во многих системах это могло быть неверно истолковано
как 1900 год, и в этот момент случились ошибки.

2244
01:43:25,120 --> 01:43:27,580
И мир потратил, предположительно,
миллионы долларов

2245
01:43:27,580 --> 01:43:30,160
чтобы программы, начали использовать больше памяти

2246
01:43:30,160 --> 01:43:32,650
для решения этой проблемы
предвидя то, что назали

2247
01:43:32,650 --> 01:43:35,860
рещением Проблемы 2000 года.

2248
01:43:35,860 --> 01:43:38,890
И в конце концов, мир не закончился
в 1999 году, что было великолепно.

2249
01:43:38,890 --> 01:43:40,930
Но это была реальная
и очень дорогая

2250
01:43:40,930 --> 01:43:43,570
проблема из-за
отсутствия предусмотрительности.

2251
01:43:43,570 --> 01:43:46,400
Оказывается, есть и другие
примеры.

2252
01:43:46,400 --> 01:43:50,980
Вот этот, например, про почти конец Boeing 787.

2253
01:43:50,980 --> 01:43:53,737
Так что у Боинга не было
хороших публикаций в прессе в последнее время.

2254
01:43:53,737 --> 01:43:55,570
И даже несколько лет
назад, у них было то, что

2255
01:43:55,570 --> 01:43:58,150
казалось очень простой ошибкой
программного обеспечения.

2256
01:43:58,150 --> 01:44:01,300
Здесь изображён самолёт модели 787.

2257
01:44:01,300 --> 01:44:04,210
И статья New
York Times объясняет это так--

2258
01:44:04,210 --> 01:44:09,130
"Самолет модели 787, который
непрерывно работал 248 дней

2259
01:44:09,130 --> 01:44:12,070
может потерять весь переменный ток,

2260
01:44:12,070 --> 01:44:14,380
из-за того, что блоки управлени генератором одновременно

2261
01:44:14,380 --> 01:44:15,940
перейдут в режим защиты от ошибок.

2262
01:44:15,940 --> 01:44:17,920
Это состояние вызывается счетчиком
программного обеспечения

2263
01:44:17,920 --> 01:44:20,920
внутренний счетчик
переполняется

2264
01:44:20,920 --> 01:44:24,550
после 248 дней непрерывной работы.

2265
01:44:24,550 --> 01:44:26,920
Boeing, как утверждается, находится в процессе

2266
01:44:26,920 --> 01:44:30,550
разработки обновления программного обеспечения,
которое исправит это."

2267
01:44:30,550 --> 01:44:31,578
И что это значит?

2268
01:44:31,578 --> 01:44:33,370
Ну, если вы действительно
погрузитесь в цифры,

2269
01:44:33,370 --> 01:44:41,560
248 дней - приблизительное значение
2 в 32-й степени,

2270
01:44:41,560 --> 01:44:44,467
плюс-минус, через 1/100 секунды.

2271
01:44:44,467 --> 01:44:47,050
Что означает, что в Боинге,
какая-то важная часть оборудования

2272
01:44:47,050 --> 01:44:51,640
в их действующих 787 моделях самолетов,
использовала целые числа

2273
01:44:51,640 --> 01:44:56,140
которые в процессе вычислений получают настолько большие числа,
что после 248-й дня работы самолета

2274
01:44:56,140 --> 01:44:59,230
будет переполнение (overflow), результат которого,


2275
01:44:59,230 --> 01:45:01,900
это то, что электричество в самолете
может полностью отключиться.

2276
01:45:01,900 --> 01:45:05,140
Итак, решение, если вы проигнорируете
все технические слова и жаргон

2277
01:45:05,140 --> 01:45:09,970
это то, что они буквально должны были
перезагружать свои самолеты каждые 248 дней

2278
01:45:09,970 --> 01:45:13,270
чтобы сбросить эту переменную назад к нулю.

2279
01:45:13,270 --> 01:45:16,870
Такие проблемы,происходят даже сегодня,
в реальном мире.

2280
01:45:16,870 --> 01:45:19,540
И вы начинаете замечать эти тенденции
каждый раз, когда люди говорят

2281
01:45:19,540 --> 01:45:21,760
о аппаратных ошибках
или ошибках программного обеспечения.

2282
01:45:21,760 --> 01:45:24,700
Честно говоря, вы можете их, как правило, свсти к проблемам

2283
01:45:24,700 --> 01:45:26,690
с которыми вы сами столкнулись.

2284
01:45:26,690 --> 01:45:30,310
И позвольте мне подразнить вас парой вещей,
парой особенностей

2285
01:45:30,310 --> 01:45:31,390
сегодня.

2286
01:45:31,390 --> 01:45:34,450
Оказалось, что теперь, когда у нас
есть возможность писать код,

2287
01:45:34,450 --> 01:45:37,630
наши программы, конечно, могут делать любое
количество вещей, говорить или печатать

2288
01:45:37,630 --> 01:45:38,657
вещи на экране.

2289
01:45:38,657 --> 01:45:40,990
Мы, конечно, можем сделать
что-то вроде этого в программе

2290
01:45:40,990 --> 01:45:43,900
Мы можем назвать это Figlet, программа, которая
действительно идет вместе с некоторыми системами.
(FIGlet - компьютерная программа,
генерирующая текстовый баннер с буквами, составленными из букв. Прим. пер)

2291
01:45:43,900 --> 01:45:46,630
И я могу напечатать,
например, это СС50,

2292
01:45:46,630 --> 01:45:49,540
и программа  выведет то,
что называется Искусство ASCII с использованием символов

2293
01:45:49,540 --> 01:45:51,707
на экране - символы похожие на буквы

2294
01:45:51,707 --> 01:45:55,520
они созданы довольно красиво,
это старая школа, искусство на экране.

2295
01:45:55,520 --> 01:45:58,210
Конечно, если Вы пишите
код и понимаете

2296
01:45:58,210 --> 01:46:01,450
что не только цифры и буквы
могут представляться, но также и звуки,

2297
01:46:01,450 --> 01:46:04,270
а с помощью нашей встречи на прошлой неделе, вы сможете
делать еще более впечатляющие вещи,

2298
01:46:04,270 --> 01:46:08,900
такие как эта заметка, на которой мы,
кстати говоря, и остановимся на сегодня.

2299
01:46:08,900 --> 01:46:10,217
ВТОРОЙ СПИКЕР: Это CS50.

2300
01:46:10,217 --> 01:46:11,550
DAVID MALAN: На сегодня это все, по курсу CS50.

2301
01:46:11,550 --> 01:46:13,210
Мы увидимся на следующей неделе.

2302
01:46:13,210 --> 01:46:15,060
[АПЛОДИСМЕНТЫ]
