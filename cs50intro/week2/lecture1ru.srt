1
00:00:00,000 --> 00:00:00,994


2
00:00:00,994 --> 00:00:03,976
[ИГРАЕТ МУЗЫКА]

3
00:00:03,976 --> 00:01:23,496


4
00:01:23,496 --> 00:01:27,907
DAVID MALAN: Всем привет, это CS50,
и очень волнительный день,

5
00:01:27,907 --> 00:01:29,990
потому что сегодня мы изучим
новый язык.

6
00:01:29,990 --> 00:01:33,020
И едва ли вы можете сказать
что это происходит с вами каждый день.

7
00:01:33,020 --> 00:01:35,810
И этот язык будет немного похож 
на это.

8
00:01:35,810 --> 00:01:37,220
Сегодня мы введем С--

9
00:01:37,220 --> 00:01:41,690
очень традиционный, очень старый
язык, который весь текстовый,

10
00:01:41,690 --> 00:01:45,230
но который может все что Scratch
и даже больше,

11
00:01:45,230 --> 00:01:47,810
однако без особого дружелюбия 
к пользователю

12
00:01:47,810 --> 00:01:49,370
к которому мы привыкли за последние дни.

13
00:01:49,370 --> 00:01:52,490
Тем не менее, хотя он выглядит чуток
непонятно на первый взгляд,

14
00:01:52,490 --> 00:01:55,280
хотя там есть всякие английские или 
похожие на английские слова,

15
00:01:55,280 --> 00:01:58,200
будьте уверены, что в течение нескольких дней,
возможно нескольких недель

16
00:01:58,200 --> 00:02:00,658
вы поймете каждую буковку на экране,

17
00:02:00,658 --> 00:02:02,520
каждую строчку кода и даже больше.

18
00:02:02,520 --> 00:02:06,157
Но я скажу, что любой курс, подобный этому,
может быть сложным, особенно

19
00:02:06,157 --> 00:02:07,490
если у вас нет никакого опыта.

20
00:02:07,490 --> 00:02:10,759
Но напоминаю, что это норма, 
обычное дело.

21
00:02:10,759 --> 00:02:13,490
2/3 слушателей CS50,-- 
вероятно и вы среди них--

22
00:02:13,490 --> 00:02:16,250
никогда не проходили никаких курсов по информатике.

23
00:02:16,250 --> 00:02:21,462
Так что, то что изображено здесь сейчас
будет в итоге понятно ровно так же как и это.

24
00:02:21,462 --> 00:02:24,170
На самом деле, даже если код 
будет выглядеть по другому-- упс.


25
00:02:24,170 --> 00:02:25,670
Даже если код 
будет выглядеть по другому,

26
00:02:25,670 --> 00:02:27,830
идеи за ним
будут точно такими же


27
00:02:27,830 --> 00:02:30,410
как на прошлой неделе на Scratch.

28
00:02:30,410 --> 00:02:33,500
Мы посмотрим на функции и условия
и Бушевские выражения, циклы,

29
00:02:33,500 --> 00:02:35,390
и другие вещи по пути.

30
00:02:35,390 --> 00:02:37,800
Но я возможно напомню о чудесном
хаке(?) из MIT

31
00:02:37,800 --> 00:02:42,350
из 1991, выражении что 
получение образования в MIT

32
00:02:42,350 --> 00:02:44,630
как будто пить из пожарного шланга.

33
00:02:44,630 --> 00:02:46,910
И в духе так называемых 
MIT хаков

34
00:02:46,910 --> 00:02:51,140
Какие то студенты реально подключили 
пожарный шланг к фонтану

35
00:02:51,140 --> 00:02:53,480
с табличкой на стене
на которой написана 
как раз эта фраза.


36
00:02:53,480 --> 00:02:56,240
И это как раз тот вид курса,
который как и многие вводные курсы,

37
00:02:56,240 --> 00:02:58,990
где вы буквальное ощущаете как 
поток информации бьет вас по лицу

38
00:02:58,990 --> 00:03:04,010
гораздо быстрее чем вы можете 
его переварить


39
00:03:04,010 --> 00:03:09,652
Но поймите, вы сможете это все усвоить
со временем

40
00:03:09,652 --> 00:03:11,360
И цель этого курса

41
00:03:11,360 --> 00:03:14,240
это дать вам тот набор концепций
и практических навыков

42
00:03:14,240 --> 00:03:16,040
который абсолютно точно понадобится
позднее.

43
00:03:16,040 --> 00:03:20,960
И в конце семестра у вас будет намного меньше
ощущения как это

44
00:03:20,960 --> 00:03:24,630
и гораздо больше как чего то
в чем вы преуспели.

45
00:03:24,630 --> 00:03:27,880
Итак без долгих разговоров, давайте
же представим этот язык по имени С.

46
00:03:27,880 --> 00:03:30,380
Итак, слева вы можете помнить 
наверное самую простую программу


47
00:03:30,380 --> 00:03:31,910
которую мы могли написать на Scratch

48
00:03:31,910 --> 00:03:35,330
И все что она делала -
заставляла кота или любой другой спрайт

49
00:03:35,330 --> 00:03:36,760
говорить "привет" на экране

50
00:03:36,760 --> 00:03:38,960
Сегодня, чтобы достигнуть
такого же результата

51
00:03:38,960 --> 00:03:42,650
мы напишем код который выглядит 
вот так, используя только клавиатуру

52
00:03:42,650 --> 00:03:44,690
и меньше графических элементов управления.

53
00:03:44,690 --> 00:03:47,910
Но давайте посмотрим почему слева
то же самое что и справа.

54
00:03:47,910 --> 00:03:50,390
Давайте разобьем это на, так сказать,
простые кусочки пазла.

55
00:03:50,390 --> 00:03:53,330
Что это делает?--

56
00:03:53,330 --> 00:03:55,815
Что это представляет из себя
в контексте программы на Scratch?

57
00:03:55,815 --> 00:03:57,440
В чем назначение этого кусочка пазла?

58
00:03:57,440 --> 00:03:58,700
ЗАЛ: Типа начинать программу

59
00:03:58,700 --> 00:03:59,850
DAVID MALAN: Да, для начала программы.

60
00:03:59,850 --> 00:04:01,892
Итак, чтобы главная часть вашей
программы сделала что то,

61
00:04:01,892 --> 00:04:05,600
вам нужно прикрепить ее к 
этому кусочку пазла с зеленым флагом.

62
00:04:05,600 --> 00:04:08,693
И мы увидим что в С это не 
настолько очевидно.

63
00:04:08,693 --> 00:04:11,360
Но пока это можно просто скопировать
 и вставить

64
00:04:11,360 --> 00:04:15,040
И в течение нескольких дней оно
обретет смысл, символ за символом.

65
00:04:15,040 --> 00:04:17,720
Int main void и потом 
открытые фигурные скобки,

66
00:04:17,720 --> 00:04:20,029
которые затем закрываются

67
00:04:20,029 --> 00:04:22,940
предполагая, что весь код который 
мы напишем сегодня

68
00:04:22,940 --> 00:04:26,240
пойдет между фигурных скобок
как в примере

69
00:04:26,240 --> 00:04:28,770
с кусочками пазла

70
00:04:28,770 --> 00:04:31,785
Так вот, даже если вам не будет понятно
что происходит сегодня, или несколько следующих дней

71
00:04:31,785 --> 00:04:34,160
поймите что функционально
это то же самое что и сказать

72
00:04:34,160 --> 00:04:38,070
"если зеленый флаг нажат,
запустите главную часть моей программы"

73
00:04:38,070 --> 00:04:40,197
Итак, что программа должна сделать
для нас?

74
00:04:40,197 --> 00:04:43,280
Наверное мы хотим начать с чего нибудь типа
 печати "Hello world", как мы делали на Scratch 

75
00:04:43,280 --> 00:04:45,030
просто напечатать hello world на экране.

76
00:04:45,030 --> 00:04:48,260
Итак, представим что вам сейчас
надо это сделать на С, С

77
00:04:48,260 --> 00:04:50,930
основан на тексте или 
клавиатурно-ориентированный язык.

78
00:04:50,930 --> 00:04:55,490
Так вот, нету глагола или функции
которая называется "сказать" в С. Вместо этого,

79
00:04:55,490 --> 00:04:57,410
она называется "print", вернее не "print".

80
00:04:57,410 --> 00:05:00,680
На самом деле зовется printf,
где f значит formatted(форматированное)

81
00:05:00,680 --> 00:05:03,860
которая позволяет печатать отформатированный
текст, как мы скоро увидим.

82
00:05:03,860 --> 00:05:07,400
Затем вы просто ставите две скобки
рядом с printf--

83
00:05:07,400 --> 00:05:09,830
открывающую скобку
и закрывающую скобку.

84
00:05:09,830 --> 00:05:14,180
И это в некотором роде похоже на эту овальную
форму, в которую мы раньше

85
00:05:14,180 --> 00:05:15,770
запихивали нашу строку.

86
00:05:15,770 --> 00:05:19,210
И на прошлой неделе мы вводили
say hello world.

87
00:05:19,210 --> 00:05:21,770
Так что буквально в С, мы напишем
"hello world"

88
00:05:21,770 --> 00:05:24,200
между этих двух скобочек.

89
00:05:24,200 --> 00:05:25,850
Но С более придирчив

90
00:05:25,850 --> 00:05:28,850
Вы не можете просто начать писать
слова между скобочек.

91
00:05:28,850 --> 00:05:32,870
В любой момент если у вас символы,
или слова, или предложения, или фразы,

92
00:05:32,870 --> 00:05:36,290
вам нужно обернуть их двойными
кавычками,

93
00:05:36,290 --> 00:05:37,090
как в данном случае.

94
00:05:37,090 --> 00:05:40,340
Так что вам нужно обернуть все
что вы хотите сказать или напечатать

95
00:05:40,340 --> 00:05:41,540
двойными кавычками здесь.

96
00:05:41,540 --> 00:05:44,480
И последняя вещь с С, о которой легко
забыть, и вы непременно ее забудете

97
00:05:44,480 --> 00:05:47,520
это то, что нужно закончить свою мысль.

98
00:05:47,520 --> 00:05:51,000
Как в сочинении на уроках английского, вы 
обычно заканчиваете предложение точкой,

99
00:05:51,000 --> 00:05:52,850
так и в С вам нужно закончить мысль.

100
00:05:52,850 --> 00:05:55,730
Но не точкой, а точкой с запятой

101
00:05:55,730 --> 00:05:57,560
в конце строчки кода.

102
00:05:57,560 --> 00:06:00,882
Но мы еще посмотрим какие типы 
строчек кода требуют закрытия

103
00:06:00,882 --> 00:06:02,840
Итак, слева у нас идея
прошлой недели.

104
00:06:02,840 --> 00:06:06,930
Справа у нас идея этой недели
и мы скоро увидим на моем компьютере,

105
00:06:06,930 --> 00:06:08,930
что функционально они идентичны.

106
00:06:08,930 --> 00:06:10,440
Они делают одно и то же.

107
00:06:10,440 --> 00:06:13,940
Так что давайте обсудим, как
мы перешли из этой программы на Scratch

108
00:06:13,940 --> 00:06:15,540
к этой программе на Scratch?

109
00:06:15,540 --> 00:06:18,770
Так что давайте посмотрим на 
последнее что хотелось сказать.

110
00:06:18,770 --> 00:06:20,840
Нам нужна последняя строчка кода,
которую я только что

111
00:06:20,840 --> 00:06:24,090
вывел на экране,
которая include stdio.h

112
00:06:24,090 --> 00:06:25,320
Так вот, что это значит?

113
00:06:25,320 --> 00:06:28,010
Получается что Scratch
очень дружелюбный к пользователю.

114
00:06:28,010 --> 00:06:30,600
Мы получили все эти разноцветные категории
с кусочками пазлов

115
00:06:30,600 --> 00:06:32,670
слева, и они все просто доступны

116
00:06:32,670 --> 00:06:35,220
с момента когда вы вообще
начали использовать Scratch.

117
00:06:35,220 --> 00:06:38,910
В С, когда вы хотите использовать какую то
функцию-- всмысле какой то кусочек паззла,

118
00:06:38,910 --> 00:06:39,790
если вы хотите--

119
00:06:39,790 --> 00:06:42,240
вам обычно нужно заранее
сказать компьютеру

120
00:06:42,240 --> 00:06:47,110
где эта функция сделана,
где она была сохранена.

121
00:06:47,110 --> 00:06:50,340
И это будет, если честно, достаточно
запутанный способ сказать,

122
00:06:50,340 --> 00:06:52,880
"Эй, компьтер, взгляни
в том файле что мы собираемся делать"

123
00:06:52,880 --> 00:06:56,640
чтобы начать вызывать stdio.h,
что бы это ни значило,

124
00:06:56,640 --> 00:06:58,933
чтобы получить доступ к этой функции.

125
00:06:58,933 --> 00:07:00,350
Опять же, огромный глоток.

126
00:07:00,350 --> 00:07:02,400
Первый из пожарных шлангов
сегодня.

127
00:07:02,400 --> 00:07:04,620
Но реально важная строка кода
нужная для сегодняшней задачи,

128
00:07:04,620 --> 00:07:07,470
это вот эта внизу.

129
00:07:07,470 --> 00:07:11,040
Так вот, как я собираюсь
писать мою первую программу на С,

130
00:07:11,040 --> 00:07:15,210
подобно тому как мы на прошлой
неделе написали программу на Scratch?

131
00:07:15,210 --> 00:07:18,540
Так вот, вспомните, что первое,
что мы сделали на Scratch

132
00:07:18,540 --> 00:07:22,950
это открыли программу,
инструментарий-- scratch.mit.edu.

133
00:07:22,950 --> 00:07:25,530
Вы можете программировать,
на Windows или Mac,

134
00:07:25,530 --> 00:07:27,510
неважно какая у вас операционка.

135
00:07:27,510 --> 00:07:30,630
Но, если честно, это становится
сложно и раздражает, когда

136
00:07:30,630 --> 00:07:32,640
приходится устанавливать и
поддерживать

137
00:07:32,640 --> 00:07:36,900
нужный софт на всех наших
персональных компьютерах.

138
00:07:36,900 --> 00:07:39,420
У всех нас установлены разные
программы, разные вещи

139
00:07:39,420 --> 00:07:41,500
и наши компьютеры все работают
несколько по разному.

140
00:07:41,500 --> 00:07:44,440
Поэтому в начальные недели CS50,
мы используем облачный инструмент--

141
00:07:44,440 --> 00:07:48,270
CS50 Sandbox, который живет
на sandbox.cs50.io.

142
00:07:48,270 --> 00:07:51,360
И вы используете именно его, чтобы решать
задачи этой недели.

143
00:07:51,360 --> 00:07:54,280
Это программное окружение в духе
Scratch,

144
00:07:54,280 --> 00:07:55,530
но не использующее Scratch.

145
00:07:55,530 --> 00:07:57,000
Тут нет никаких кусочков пазла.

146
00:07:57,000 --> 00:07:59,730
Вместо этого у нас С,
этот текстовый язык.

147
00:07:59,730 --> 00:08:01,530
который мы уже начнем сейчас.

148
00:08:01,530 --> 00:08:04,410
Итак, в этом окружении две части.

149
00:08:04,410 --> 00:08:07,350
В области сверху я просто буду писать код.

150
00:08:07,350 --> 00:08:09,250
Буквально сейчас, я
кликну на кнопку плюс,

151
00:08:09,250 --> 00:08:10,708
и создам новый файл.

152
00:08:10,708 --> 00:08:13,390
И я собираюсь начать писать код в этот
файл и сохранить его.

153
00:08:13,390 --> 00:08:16,038
И потом, в нижней части этой
утилиты находится

154
00:08:16,038 --> 00:08:18,330
то что мы будем называть
окно консоли.

155
00:08:18,330 --> 00:08:20,880
Консоль - это такой олдскульный
интерфейс

156
00:08:20,880 --> 00:08:24,780
через который вы запускаете команды,
буквально печатая их

157
00:08:24,780 --> 00:08:25,980
и нажимая Enter.

158
00:08:25,980 --> 00:08:27,330
Поэтому не как в Scratch--

159
00:08:27,330 --> 00:08:29,700
ну и вообще-то, не как в Mac OS
и не как в Windows

160
00:08:29,700 --> 00:08:32,610
где можно куда то кликнуть,
что то перетащить, взаимодействуя

161
00:08:32,610 --> 00:08:35,460
с графическим интерфейсом,
большая часть нашего программирования

162
00:08:35,460 --> 00:08:38,620
на ранних этапах будет включать
печатание команд.

163
00:08:38,620 --> 00:08:40,380
Поэтому давайте приблизим наши условия
к реальности.

164
00:08:40,380 --> 00:08:44,580
Напоминаю, что наша задача - это
без геморроя написать программу на С

165
00:08:44,580 --> 00:08:47,580
которая говорит привет миру,
что функционально то же самое,

166
00:08:47,580 --> 00:08:49,950
что и программа на Scratch слева.

167
00:08:49,950 --> 00:08:53,295
Но нам нужно сделать это
используя язык справа.

168
00:08:53,295 --> 00:08:55,170
Итак, в этом программном окружении я

169
00:08:55,170 --> 00:08:59,610
нажму на кнопку "Плюс", чтобы
создать новый файл или вкладку.

170
00:08:59,610 --> 00:09:03,090
По принятым соглашениям, я
назову файл как нибудь типа hello.c.

171
00:09:03,090 --> 00:09:05,550
Hello потому что я хочу
чтобы эта программа говорила 'hello',

172
00:09:05,550 --> 00:09:07,170
но вообще я мог бы назвать его как я хочу.

173
00:09:07,170 --> 00:09:10,920
И точка с, потому что соглашение
в этом языке С говорит,

174
00:09:10,920 --> 00:09:14,640
что надо оканчивать свои файлы,
которые содержат код буквально,

175
00:09:14,640 --> 00:09:18,740
точкой с С, типа как у вас есть
,doc или .dotx для Ворда,

176
00:09:18,740 --> 00:09:22,342
.gif для графических файлов,
и так далее.

177
00:09:22,342 --> 00:09:24,300
Поэтому я жму Create File.

178
00:09:24,300 --> 00:09:27,750
И вы видите что сейчас у меня мигает
курсор ввода на линии 1--

179
00:09:27,750 --> 00:09:31,530
оно автоматически пронумерует мои линии
для меня-- во вкладке по имени hello.c.

180
00:09:31,530 --> 00:09:33,000
Там я могу писать код.

181
00:09:33,000 --> 00:09:37,210
Итак, несмотря на то, что код,
который я сейчас напишу, весьма загадочен--

182
00:09:37,210 --> 00:09:41,400
include standard.io, int main void.

183
00:09:41,400 --> 00:09:44,220
И потом вот тут, я сделаю
printf, открыть кавычки, закрыть кавычки,

184
00:09:44,220 --> 00:09:46,650
"hello world" точка с запятой.

185
00:09:46,650 --> 00:09:50,008
Я только что написал
свою первую программу на С.

186
00:09:50,008 --> 00:09:52,050
Итак, я сейчас увеличу
верхнюю левую часть.

187
00:09:52,050 --> 00:09:54,120
Всего шесть строк кода.

188
00:09:54,120 --> 00:09:57,720
И вы видите что я включил stdio.h,
что бы это ни значило,

189
00:09:57,720 --> 00:09:59,850
int main void, что бы это ни значило.

190
00:09:59,850 --> 00:10:02,610
И реально, все мясцо этой программы
на пятой строчке--

191
00:10:02,610 --> 00:10:07,050
print, или printf для
форматирования, "hello world."

192
00:10:07,050 --> 00:10:10,050
Вспоминаем, что int main void
это похоже на тот кусочек пазла

193
00:10:10,050 --> 00:10:11,580
где зеленый флаг.

194
00:10:11,580 --> 00:10:13,980
И printf похоже на блок Say.

195
00:10:13,980 --> 00:10:16,350
И эта верхняя строчка,
она нам нужна,

196
00:10:16,350 --> 00:10:19,320
потому что компьютер не поймет
что такое printf

197
00:10:19,320 --> 00:10:22,630
пока я ему прямо не скажу включить этот файл.

198
00:10:22,630 --> 00:10:26,850
Отлично, теперь я могу
сказать что я написал какой то код.

199
00:10:26,850 --> 00:10:28,110
Как мне теперь его запустить?

200
00:10:28,110 --> 00:10:32,390
Ну, как вы запускаете
программу на компьютере?

201
00:10:32,390 --> 00:10:34,590
Что вы обычно делаете?

202
00:10:34,590 --> 00:10:36,180
Дважды щёлкаете по ней, верно?

203
00:10:36,180 --> 00:10:39,730
К сожалению, здесь нет ничего,
по чему можно было бы щёлкнуть.

204
00:10:39,730 --> 00:10:41,370
На моём экране даже никакого значка нет.

205
00:10:41,370 --> 00:10:44,100
На самом деле, как таковой пока
нет и самой программы.

206
00:10:44,100 --> 00:10:47,760
Ведь компьютеры, как мы помним,
не понимают английский язык.

207
00:10:47,760 --> 00:10:49,740
Технически, они и язык C
не понимают.

208
00:10:49,740 --> 00:10:52,440
Но тогда какой язык они вообще
знают и понимают?

209
00:10:52,440 --> 00:10:53,235
ЗАЛ: Двоичный.

210
00:10:53,235 --> 00:10:55,110
DAVID MALAN: Именно, двоичный.
Нули и единицы.

211
00:10:55,110 --> 00:10:56,943
А здесь, как мы видим,
совсем не нули и единицы.

212
00:10:56,943 --> 00:11:00,030
И, честно говоря, никому из нас
не понравился бы процесс написания кода,

213
00:11:00,030 --> 00:11:03,240
включающий в себя буквальную запись нулей
и единиц, что, в некотором смысле,

214
00:11:03,240 --> 00:11:06,450
некогда и правда представляло собой
программирование.

215
00:11:06,450 --> 00:11:09,510
Но в настоящее время существует
решение этой проблемы.

216
00:11:09,510 --> 00:11:12,660
Вот с этим, как бы загадочно оно
ни выглядело для большинства из вас,

217
00:11:12,660 --> 00:11:15,540
вы хоть как-то сможете свыкнуться,

218
00:11:15,540 --> 00:11:18,700
как только познакомитесь с синтаксисом,
правилами

219
00:11:18,700 --> 00:11:19,530
и так далее.

220
00:11:19,530 --> 00:11:22,260
Но нужно как-то преобразовать это
в нули и единицы.

221
00:11:22,260 --> 00:11:25,110
Возможно, не совсем очевидно,
как именно.

222
00:11:25,110 --> 00:11:31,110
Оказывается, что для преобразования
такого кода в нули и единицы,

223
00:11:31,110 --> 00:11:34,770
понятные компьютеру, необходимо наличие
промежуточного этапа.

224
00:11:34,770 --> 00:11:38,370
Мне нужно, чтобы на моём компьютере или
в этом облачном окружении

225
00:11:38,370 --> 00:11:43,200
была программа, которая бы взяла
мой исходный код,

226
00:11:43,200 --> 00:11:45,650
написанный на языке C, и выдала на выходе

227
00:11:45,650 --> 00:11:48,000
то, что называется машинным кодом.

228
00:11:48,000 --> 00:11:53,400
Исходный код - то, что написано на C,
Python, Java, C++ или другом языке,

229
00:11:53,400 --> 00:11:54,660
о котором вы могли слышать.

230
00:11:54,660 --> 00:11:58,170
Языке с подобным английскому синтаксисом,
на котором вы пишете программы.

231
00:11:58,170 --> 00:12:02,760
Машинный же код - это нули и единицы,
которые понимает каждый компьютер.

232
00:12:02,760 --> 00:12:05,970
Итак, для перехода от исходного кода
к машинному

233
00:12:05,970 --> 00:12:08,773
необходим некий алгоритм или,
если быть точнее,

234
00:12:08,773 --> 00:12:10,690
подпрограмма, осуществляющая преобразование.

235
00:12:10,690 --> 00:12:14,230
И такую подпрограмму мы будем называть
компилятором.

236
00:12:14,230 --> 00:12:17,790
Мы будем писать код, буквально набирая
команды с клавиатуры.

237
00:12:17,790 --> 00:12:20,160
Потом будем сохранять эти команды в файл,

238
00:12:20,160 --> 00:12:21,900
точно так же, как вы сохраняли код в Scratch.

239
00:12:21,900 --> 00:12:24,990
Но прежде, чем я смогу запустить программу,
выполнив двойной щелчок или что-то подобное,

240
00:12:24,990 --> 00:12:28,200
мне необходимо прогнать её через компилятор

241
00:12:28,200 --> 00:12:30,640
и получить результат, состоящий
из нулей и единиц.

242
00:12:30,640 --> 00:12:33,000
Так, ну и как же мне это сделать?

243
00:12:33,000 --> 00:12:35,640
Это первая из более эзотерических команд,

244
00:12:35,640 --> 00:12:38,880
но оказывается, что её
относительно просто выполнить.

245
00:12:38,880 --> 00:12:40,680
В верхней части моей среды программирования--

246
00:12:40,680 --> 00:12:43,380
опять же, код у меня тут сверху слева,

247
00:12:43,380 --> 00:12:45,780
а если прокрутить экран до самого низа,
то здесь находится

248
00:12:45,780 --> 00:12:47,322
так называемое окно терминала.

249
00:12:47,322 --> 00:12:49,530
Символ доллара - это просто
странная человеческая условность.

250
00:12:49,530 --> 00:12:51,930
Он означает что-то вроде
"введи сюда что-нибудь".

251
00:12:51,930 --> 00:12:54,540
Это ваша так называемая командная строка
или командная оболочка.

252
00:12:54,540 --> 00:12:59,700
Мигающий курсор предлагает мне
ввести команду в этой строке.

253
00:12:59,700 --> 00:13:04,740
В качестве первой команды я собираюсь
использовать команду Clang из языка C.

254
00:13:04,740 --> 00:13:09,210
Clang - это название программы,
предназначенной для компиляции кода.

255
00:13:09,210 --> 00:13:10,650
Её не я написал.

256
00:13:10,650 --> 00:13:14,100
Кто-то другой создал её и назвал Clang--
группа людей,

257
00:13:14,100 --> 00:13:14,640
если быть точным.

258
00:13:14,640 --> 00:13:18,210
Они выложили её в свободный доступ, чтобы
мы с вами могли использовать её на компьютерах

259
00:13:18,210 --> 00:13:19,990
или в такой вот изолированной среде.

260
00:13:19,990 --> 00:13:23,110
И мы можем использовать Clang для преобразования
исходного кода в машинный.

261
00:13:23,110 --> 00:13:26,940
Так что теперь я просто запущу команду
Clang hello.c.

262
00:13:26,940 --> 00:13:29,860
Я пока ещё не нажал клавишу Enter,
но в тот момент, когда я это сделаю,

263
00:13:29,860 --> 00:13:31,360
кое-что произойдёт.

264
00:13:31,360 --> 00:13:33,720
Давайте я щёлкну по этому маленькому
значку папки вот здесь,

265
00:13:33,720 --> 00:13:37,020
и вы увидите все файлы в моей
текущей, так сказать, песочнице,

266
00:13:37,020 --> 00:13:38,710
моей среде программирования.

267
00:13:38,710 --> 00:13:41,752
Файл здесь только один, потому что
единственным созданным мной файлом

268
00:13:41,752 --> 00:13:43,170
является hello.c.

269
00:13:43,170 --> 00:13:45,720
Но обратите внимание на то,
что произойдёт после нажатия Enter,

270
00:13:45,720 --> 00:13:47,940
то есть после выполнения команды Clang hello.c.

271
00:13:47,940 --> 00:13:50,610


272
00:13:50,610 --> 00:13:54,150
Определённо, появилось что-то новое,

273
00:13:54,150 --> 00:13:56,490
что-то странное и с очень глупым именем.

274
00:13:56,490 --> 00:14:02,520
Это файл a.out, но вы, возможно, догадываетесь,
что находится внутри него.

275
00:14:02,520 --> 00:14:03,842
Что там может быть?

276
00:14:03,842 --> 00:14:04,800
ЗАЛ: Машинный код.

277
00:14:04,800 --> 00:14:06,133
DAVID MALAN: Именно, машинный код.

278
00:14:06,133 --> 00:14:09,540
Вообще говоря, это вывод сборки,
но это то же самое, что машинный код.

279
00:14:09,540 --> 00:14:13,110
Внутри этого файла есть только
набор нулей и единиц,

280
00:14:13,110 --> 00:14:16,437
которые соответствуют этому коду,
но в двоичном виде,

281
00:14:16,437 --> 00:14:18,270
то есть на языке, понятном компьютеру.

282
00:14:18,270 --> 00:14:20,640
Так что я сейчас сделал буквально следующее--

283
00:14:20,640 --> 00:14:24,450
Я взял вот такой исходный код,
написанный на языке C.

284
00:14:24,450 --> 00:14:28,148
Я подал его на вход компилятора и на выходе
получил результат из нулей и единиц.

285
00:14:28,148 --> 00:14:29,940
И эти нули и единицы были автоматически

286
00:14:29,940 --> 00:14:35,113
сохранены в файл, который, по умолчанию,
называется a.out.

287
00:14:35,113 --> 00:14:37,530
Хорошо, но кто-то предложил раньше,
что для запуска программы

288
00:14:37,530 --> 00:14:40,088
на компьютере нужно просто
дважды щёлкнуть по ней.

289
00:14:40,088 --> 00:14:41,880
Но у нас тут не по чему щёлкать.

290
00:14:41,880 --> 00:14:44,940
Даже если я дважды щёлкну вот так,
результат будет странным,

291
00:14:44,940 --> 00:14:46,380
потому что компьютер не поймёт,
что нужно сделать.

292
00:14:46,380 --> 00:14:48,930
Это ведь просто нули и единицы,
они не предназначены для щелчков.

293
00:14:48,930 --> 00:14:52,598
Но зато они предназначены для выполнения
в командной строке.

294
00:14:52,598 --> 00:14:53,890
Давайте я покажу.

295
00:14:53,890 --> 00:14:54,807
Это тоже может выглядеть не очень непонятно,

296
00:14:54,807 --> 00:14:58,740
но я просто возьму и выполню команду
./a.out.

297
00:14:58,740 --> 00:15:02,190
И вот это, как бы странно оно не выглядело
на первый взгляд,

298
00:15:02,190 --> 00:15:07,890
является корректным способом указания компьютеру
"выполни a.out в текущем каталоге".

299
00:15:07,890 --> 00:15:11,010
Точка в начале команды означает буквально
"прямо здесь",

300
00:15:11,010 --> 00:15:13,260
"в текущей папке", как если бы вы дважды щёлкали

301
00:15:13,260 --> 00:15:14,730
по файлу на компьютере.

302
00:15:14,730 --> 00:15:19,650
И /a.out значит посмотреть в эту папку,
и запустить программу в файле, которая называется

303
00:15:19,650 --> 00:15:20,860
a.out.

304
00:15:20,860 --> 00:15:23,150
Поэтому давайте продолжим и нажмем Enter.

305
00:15:23,150 --> 00:15:25,980
И вуаля, hello world.

306
00:15:25,980 --> 00:15:29,610
Итак, насколько я помню, на прошлой неделе Вы были впечатлены,
когда я сделал так, чтобы кот сказал

307
00:15:29,610 --> 00:15:30,580
hello world.

308
00:15:30,580 --> 00:15:32,510
Здесь, кажется мы не в восторге

309
00:15:32,510 --> 00:15:36,360
Но hello world это моя программа на
Cи, которая делает абсолютно то же самое.

310
00:15:36,360 --> 00:15:39,870
Но конечно, она выглядит
немного глупо сейчас.

311
00:15:39,870 --> 00:15:40,950
И она выглядит немного глючно.

312
00:15:40,950 --> 00:15:44,373
В чем загвоздка, даже
если Вы не программировали никогда раньше?

313
00:15:44,373 --> 00:15:45,290
AUDIENCE: Знак доллара.

314
00:15:45,290 --> 00:15:46,748
DAVID MALAN: Да, знак доллара.

315
00:15:46,748 --> 00:15:48,660
Я не хочу сказать
hello world знак доллара,

316
00:15:48,660 --> 00:15:50,868
но знак доллара
это как артефакт, верно?

317
00:15:50,868 --> 00:15:52,482
Что это опять за знак доллара?

318
00:15:52,482 --> 00:15:53,190
АУДИТОРИЯ: Подсказка

319
00:15:53,190 --> 00:15:54,150
DAVID MALAN: Это просто подсказка.

320
00:15:54,150 --> 00:15:57,270
Он ждет другой команды, и
вот почему мой курсор мигает там.

321
00:15:57,270 --> 00:15:58,603
Но это выглядит довольно глупо, не так ли?

322
00:15:58,603 --> 00:16:01,538
Мы можем утверждать, что таково было
мое намерение, но, честно говоря, я бы солгал.

323
00:16:01,538 --> 00:16:03,330
Он не делает не совсем то, что я хотел бы,
чтобы он делал.

324
00:16:03,330 --> 00:16:05,380
И это потому что, в отличии от нуля--

325
00:16:05,380 --> 00:16:06,930
который, опять же, более удобен для пользователя--

326
00:16:06,930 --> 00:16:12,220
Си, и многие языки подобные ему, в прямом смысле
будут делать только то, что Вы скажете им делать.

327
00:16:12,220 --> 00:16:16,972
Я ни разу не сказал компьютеру
передвинуть курсор на новую строчку.

328
00:16:16,972 --> 00:16:18,180
Я не закончил эту мысль.

329
00:16:18,180 --> 00:16:20,340
Я сказал, hello, запятая,
world, и на этом все.

330
00:16:20,340 --> 00:16:23,650
На самом деле, я никогда не отправлял команду
компьютеру переместить курсор,

331
00:16:23,650 --> 00:16:24,660
но я могу.

332
00:16:24,660 --> 00:16:26,830
Итак, позвольте мне вернуться к моему коду.

333
00:16:26,830 --> 00:16:30,300
И, оказывается, что в
Си, если вы скажете компьютеру

334
00:16:30,300 --> 00:16:33,240
напечатать hello, запятая, world,
в буквальном смысле все это,

335
00:16:33,240 --> 00:16:34,620
это будет напечатано.

336
00:16:34,620 --> 00:16:36,810
Если хотите напечатать
новую строчку, вам нужно

337
00:16:36,810 --> 00:16:40,950
использовать специальную команду, специальный
символ, который называется новый символ строки,

338
00:16:40,950 --> 00:16:43,650
он выглядит следующим образом -  обратный слэш n.

339
00:16:43,650 --> 00:16:44,672
А почему так происходит?

340
00:16:44,672 --> 00:16:46,380
Ну, это действительно так,
даже несмотря на то, что вы

341
00:16:46,380 --> 00:16:49,590
можете быть намерены нажимать
Enter  и просто нажмете

342
00:16:49,590 --> 00:16:51,900
Enter так, как вы надеетесь
компьютер сделает

343
00:16:51,900 --> 00:16:54,210
даже если вы никогда не программировали
раньше, это, вероятней всего

344
00:16:54,210 --> 00:16:55,950
будет создавать
неудобства.

345
00:16:55,950 --> 00:16:57,270
Это выглядит немного странно.

346
00:16:57,270 --> 00:16:59,460
Это выглядит немного неопрятно,
когда одна строка здесь

347
00:16:59,460 --> 00:17:00,930
а вторая строка здесь.

348
00:17:00,930 --> 00:17:03,180
Так что люди решили
много лет назад,

349
00:17:03,180 --> 00:17:06,750
что будет простая
команда, бэкслэш n,

350
00:17:06,750 --> 00:17:10,170
которая говорит компьютеру
переместить эту новую строку вниз.

351
00:17:10,170 --> 00:17:11,670
Итак, позвольте мне пойти дальше и уменьшить масштаб сейчас.

352
00:17:11,670 --> 00:17:14,010
В песочнице все автоматически
сохраняется точно так же как Google Docs,

353
00:17:14,010 --> 00:17:16,589
так что вам не нужно кликать на File,
Save или что-нибудь в этом духе.

354
00:17:16,589 --> 00:17:23,440
If I go ahead now and rerun this program
./a.out Enter, it's not yet fixed.

355
00:17:23,440 --> 00:17:25,319
Let me go ahead and zoom in.

356
00:17:25,319 --> 00:17:27,210
Notice that the symptom is still there.

357
00:17:27,210 --> 00:17:28,260
Почему?

358
00:17:28,260 --> 00:17:31,050
Какую ошибку я только что сделал?

359
00:17:31,050 --> 00:17:32,700
Да, я не перекомпилировал это.

360
00:17:32,700 --> 00:17:36,120
И еще раз напомню,  компьютер будет
воспринимать вас очень, очень буквально

361
00:17:36,120 --> 00:17:38,580
now that you're programming
it to do things.

362
00:17:38,580 --> 00:17:41,340
And if you want to run the
new version of your code,

363
00:17:41,340 --> 00:17:44,880
you are literally going to
have to do something like Clang

364
00:17:44,880 --> 00:17:48,360
и затем hello.c, Enter.

365
00:17:48,360 --> 00:17:49,810
И, кажется, ничего не произошло.

366
00:17:49,810 --> 00:17:52,552
И, честно говоря, ирония в том,
когда вы не видите результатов (output),

367
00:17:52,552 --> 00:17:53,760
это обычно неплохо.

368
00:17:53,760 --> 00:17:56,340
Когда вы видите результат (output), это обычно
список, например, из пяти ошибок

369
00:17:56,340 --> 00:17:58,560
которые вы сделали или сообщения
об ошибке, которые мы скоро увидим.

370
00:17:58,560 --> 00:18:00,120
Но у нас все еще есть a.out.

371
00:18:00,120 --> 00:18:02,200
Это просто новая версия

372
00:18:02,200 --> 00:18:06,930
Так что, если я продолжу и увеличу сейчас
и сделаю это-- ./a.out, Enter--

373
00:18:06,930 --> 00:18:10,070
теперь у меня есть более впечатляющая
версия hello world.

374
00:18:10,070 --> 00:18:12,450
Теперь я немного его подкорректирую.

375
00:18:12,450 --> 00:18:14,190
Хорошо, дайте мне
буквально минутку

376
00:18:14,190 --> 00:18:18,490
и посмотрим, есть ли вопросы
по этим механикам.

377
00:18:18,490 --> 00:18:19,066
Да?

378
00:18:19,066 --> 00:18:20,440
АУДИТОРИЯ: Почему вторая строка пустая?

379
00:18:20,440 --> 00:18:21,940
DAVID MALAN: Скажите это чуть громче.

380
00:18:21,940 --> 00:18:23,640
AUDIENCE: Почему вторая строка пустая?

381
00:18:23,640 --> 00:18:24,330
DAVID MALAN: Почему вторая строка пустая?

382
00:18:24,330 --> 00:18:25,540
O, это действвительно хороший вопрос.

383
00:18:25,540 --> 00:18:29,678
Строка 2 пуста только потому, что
я решил, что стилистически

384
00:18:29,678 --> 00:18:30,720
так будет выглядеть немного лучше.

385
00:18:30,720 --> 00:18:32,553
Так же как при написании эссе,
вы можете нажать

386
00:18:32,553 --> 00:18:34,500
Enter, Enter - это просто для того, чтобы
разделить параграфы,

387
00:18:34,500 --> 00:18:36,810
так программисты часто
разделяют свой  код, просто

388
00:18:36,810 --> 00:18:39,300
чтобы сделать его немного более
читательным, чтобы он не

389
00:18:39,300 --> 00:18:41,610
выглядел как один большой массив кода.

390
00:18:41,610 --> 00:18:44,680
Но это не обязательно,
и я мог бы опустить это.

391
00:18:44,680 --> 00:18:46,880
Есть еще какие-то вопросы?

392
00:18:46,880 --> 00:18:49,036
Да?

393
00:18:49,036 --> 00:18:51,940
АУДИТОРИЯ: Можно ли переименовать a.out
таким образом, чтобы был больше, чем один

394
00:18:51,940 --> 00:18:52,898
файл в папке?

395
00:18:52,898 --> 00:18:54,315
DAVID MALAN: Это очень хороший вопрос.

396
00:18:54,315 --> 00:18:57,750
Можно ли переименовать a.out таким образом, чтобы была
больше, чем один файл или программа

397
00:18:57,750 --> 00:18:58,740
в той же самой папке?

398
00:18:58,740 --> 00:18:59,430
Конечно.

399
00:18:59,430 --> 00:19:00,990
Давайте я это сделаю прямо сейчас.

400
00:19:00,990 --> 00:19:04,350
Оказывается, что при запуске
на компьютере таких команд, как Clang,

401
00:19:04,350 --> 00:19:08,100
можно указывать не только
имя программы и имя файла.

402
00:19:08,100 --> 00:19:10,380
Вы можете добавлять дополнительные
параметры, иначе известные

403
00:19:10,380 --> 00:19:12,180
как аргументы командной строки.

404
00:19:12,180 --> 00:19:14,280
И здесь тоже есть что-то загадочное.

405
00:19:14,280 --> 00:19:19,020
Необходимо заранее знать эти аргументы,
чтобы иметь возможность их указать.

406
00:19:19,020 --> 00:19:20,640
Но оказывается, что в случае с Clang--

407
00:19:20,640 --> 00:19:22,740
если почитаете документацию,
то увидите сами--

408
00:19:22,740 --> 00:19:25,920
можно использовать аргумент "-o" для вывода.

409
00:19:25,920 --> 00:19:28,140
А далее можно задать любое имя

410
00:19:28,140 --> 00:19:31,860
для файла, в котором будет сохранён
машинный код.

411
00:19:31,860 --> 00:19:33,000
Обратите внимание на то, что сейчас произойдёт.

412
00:19:33,000 --> 00:19:35,550
Когда я нажму Enter, посмотрите
в левый верхний угол,

413
00:19:35,550 --> 00:19:37,710
где сейчас есть файлы "a.out" и "hello.c".

414
00:19:37,710 --> 00:19:40,930
Там также есть "hello".

415
00:19:40,930 --> 00:19:45,210
А сейчас я введу ./hello вместо a.out

416
00:19:45,210 --> 00:19:48,137
и получу тот же самый результат.

417
00:19:48,137 --> 00:19:50,970
Здесь я хотел бы отметить ещё кое-что.

418
00:19:50,970 --> 00:19:53,570
Хотя мы и видим графический интерфейс
вот тут,

419
00:19:53,570 --> 00:19:55,320
он тут лишь ради удобства,
потому как мы с вами

420
00:19:55,320 --> 00:19:59,310
уже привыкли к подобным интерфейсам
на компьютерах.

421
00:19:59,310 --> 00:20:04,590
Но через командную строку я могу делать
всё то же самое, что и с помощью мыши.

422
00:20:04,590 --> 00:20:07,350
Например, в этой среде программирования

423
00:20:07,350 --> 00:20:10,200
я могу ввести команду "ls" для вывода списка.

424
00:20:10,200 --> 00:20:13,800
Это краткое обозначение, потому что
несколько лет назад люди решили, что, ну,

425
00:20:13,800 --> 00:20:17,830
зачем писать "L-I-S-T", если можно просто
ввести "ls", что почти то же самое.

426
00:20:17,830 --> 00:20:22,320
Так и появилась команда "ls",
которая отображает

427
00:20:22,320 --> 00:20:26,340
список всех файлов в текущем каталоге.

428
00:20:26,340 --> 00:20:30,570
И мы видим всё то же самое--
файлы a.out, hello и hello.c.

429
00:20:30,570 --> 00:20:33,720
Возможно, вы догадываетесь,
что означает символ звёздочки

430
00:20:33,720 --> 00:20:36,060
после имён файлов a.out и hello?

431
00:20:36,060 --> 00:20:37,033
ЗАЛ: Они исполняемые.

432
00:20:37,033 --> 00:20:38,950
DAVID MALAN: Исполняемые, верно,
что означает,

433
00:20:38,950 --> 00:20:42,660
что внутри них находится машинный код,
который может быть выполнен компьютером,

434
00:20:42,660 --> 00:20:45,773
тогда как после hello.c нет звёздочки,

435
00:20:45,773 --> 00:20:47,190
потому что это исходный код.

436
00:20:47,190 --> 00:20:50,340
Так что даже визуально можно отличить
исходный код

437
00:20:50,340 --> 00:20:51,600
от машинного кода.

438
00:20:51,600 --> 00:20:54,630
А теперь предположим, что я не хочу
больше иметь файл a.out,

439
00:20:54,630 --> 00:20:56,130
потому что он называется как-то глупо.

440
00:20:56,130 --> 00:20:58,230
Так я никогда не запомню,
что это там программа.

441
00:20:58,230 --> 00:21:02,520
Ну, тогда я могу ввести другую команду,
например, "rm", и удалить a.out.

442
00:21:02,520 --> 00:21:03,660
И затем нажать Enter.

443
00:21:03,660 --> 00:21:04,980
Снова небольшая магия.

444
00:21:04,980 --> 00:21:07,540
Тут написано про удаление обычного файла a.out.

445
00:21:07,540 --> 00:21:10,890
Обратите внимание, что курсор
после вопросительного знака мигает.

446
00:21:10,890 --> 00:21:15,060
Я могу ввести "Y" или "yes",
чтобы подтвердить команду.

447
00:21:15,060 --> 00:21:17,010
Кажется, как будто ничего не произошло.

448
00:21:17,010 --> 00:21:20,730
Но как мне проверить, какие файлы теперь
существуют в этом каталоге?

449
00:21:20,730 --> 00:21:24,790
Я просто снова введу "ls", и теперь
у меня тут только эти два файла.

450
00:21:24,790 --> 00:21:27,450
Так что мы видим, что нам доступно
множество разных команд.

451
00:21:27,450 --> 00:21:34,140
Например, такие, как "ls" и "rm".

452
00:21:34,140 --> 00:21:36,690
Есть команда "mkdir" для создания каталога,

453
00:21:36,690 --> 00:21:38,683
есть "rmdir" для его удаления.

454
00:21:38,683 --> 00:21:41,100
Когда вам нужно будет узнать или
использовать какую-то из команд,

455
00:21:41,100 --> 00:21:43,080
мы обязательно сообщим об этом
в условии задания.

456
00:21:43,080 --> 00:21:46,320
А пока запомните: всё, что вы можете
делать с помощью мыши

457
00:21:46,320 --> 00:21:50,610
и графического пользовательского интерфейса,
вы можете делать и через командную строку.

458
00:21:50,610 --> 00:21:53,640
Ладно, давайте пойдём дальше

459
00:21:53,640 --> 00:21:55,950
и сделаем кое-что более интересное.

460
00:21:55,950 --> 00:21:58,350
Вернёмся к исходному виду.

461
00:21:58,350 --> 00:22:02,000
Итак, пока что всё, что мы сделали —
это вывели на экран фразу "Hello, world".

462
00:22:02,000 --> 00:22:04,620
Но как вы помните, вторая программа,
которую мы писали на прошлой неделе,

463
00:22:04,620 --> 00:22:06,450
была чуть более динамичной и интерактивной.

464
00:22:06,450 --> 00:22:10,200
Помните, что делала наша вторая программа
в Scratch на прошлой неделе?

465
00:22:10,200 --> 00:22:12,400
ЗАЛ: Запрашивала у пользователя имя.

466
00:22:12,400 --> 00:22:14,692
DAVID MALAN: Точно, спрашивала имя.

467
00:22:14,692 --> 00:22:17,550
И мы отвечали "hello, David",
или "hello, Brian", в зависимости

468
00:22:17,550 --> 00:22:19,133
от того, кто запустил программу.

469
00:22:19,133 --> 00:22:21,300
Та программа выглядела примерно так.

470
00:22:21,300 --> 00:22:25,590
Эти две строчки кода соединялись с блоком
"когда нажат зелёный флажок".

471
00:22:25,590 --> 00:22:28,170
Вот этот синий блок сверху был функцией,

472
00:22:28,170 --> 00:22:32,940
которая возвращала значение, ответ.

473
00:22:32,940 --> 00:22:35,170
Она возвращала то, что вводил пользователь.

474
00:22:35,170 --> 00:22:38,130
И это было полезно, потому что затем
мы использовали ответ пользователя

475
00:22:38,130 --> 00:22:42,600
для объединения (или конкатенации)
со словом "hello".

476
00:22:42,600 --> 00:22:45,160
И далее мы выводили полученный результат.

477
00:22:45,160 --> 00:22:46,255
А как сделать то же самое в языке C?

478
00:22:46,255 --> 00:22:48,630
Что ж, именно с этого момента
всё будет резко усложняться.

479
00:22:48,630 --> 00:22:51,570
Но опять же, процесс будет подчинён
определённым правилам и шаблонам,

480
00:22:51,570 --> 00:22:54,190
которые постепенно будут становиться
всё понятнее.

481
00:22:54,190 --> 00:22:57,990
В языке C (по крайней мере, в песочнице
курса CS50) ближайшим аналогом

482
00:22:57,990 --> 00:23:03,810
функции запроса из Scratch является функция
под названием get_string (получить строку).

483
00:23:03,810 --> 00:23:06,180
Строка в программировании —
это просто обозначение

484
00:23:06,180 --> 00:23:09,750
слова, фразы или предложения.

485
00:23:09,750 --> 00:23:14,470
То есть это текст, а не число
или данные другого типа.

486
00:23:14,470 --> 00:23:19,680
Итак, get_string — ближайший аналог
функции запроса.

487
00:23:19,680 --> 00:23:22,830
В скобках, которые соответствуют полю вот тут,

488
00:23:22,830 --> 00:23:24,840
можно задать какую-то фразу,

489
00:23:24,840 --> 00:23:27,673
скажем, вопрос, который пользователь
увидит на экране--

490
00:23:27,673 --> 00:23:30,217
например, "как вас зовут",
обязательно в кавычках.

491
00:23:30,217 --> 00:23:31,050
А зачем, собственно, нужны кавычки?

492
00:23:31,050 --> 00:23:34,050
Чуть ранее я сказал, что каждый раз,
когда вы передаёте строку--

493
00:23:34,050 --> 00:23:36,450
слово, фразу, буквы алфавита--

494
00:23:36,450 --> 00:23:38,460
вы должны заключать её в двойные кавычки

495
00:23:38,460 --> 00:23:40,380
с обеих сторон.

496
00:23:40,380 --> 00:23:44,994
А это что за странное заклинание,
обратная косая черта и "n" ("\n")?

497
00:23:44,994 --> 00:23:45,786
ЗАЛ: Переход на новую строку.

498
00:23:45,786 --> 00:23:47,970
DAVID MALAN: Верно, оно просто
переводит курсор на новую строку.

499
00:23:47,970 --> 00:23:48,540
Зачем?

500
00:23:48,540 --> 00:23:50,207
Просто потому, что так немного красивее.

501
00:23:50,207 --> 00:23:51,000
Я не обязан этого делать.

502
00:23:51,000 --> 00:23:54,370
И действительно, мгновение назад, мой
компьютер ожидал от меня ответа: Да или Нет

503
00:23:54,370 --> 00:23:56,780
и он не переместил курсор
на новую строку.

504
00:23:56,780 --> 00:23:59,470
Это произошло потому что программист
решил не делать этого.

505
00:23:59,470 --> 00:24:02,120
Но я продолжу с переносом строки.

506
00:24:02,120 --> 00:24:07,150
Когда я запросил имя пользователя
с помощью функции get_string,

507
00:24:07,150 --> 00:24:08,680
мне нужно что-то с этим сделать.

508
00:24:08,680 --> 00:24:12,220
И чтобы реализовать это в языке С вы 
буквально заводите переменную

509
00:24:12,220 --> 00:24:15,837
которая хранит
значения.

510
00:24:15,837 --> 00:24:18,670
Я назову переменную answer,
точно так же как в Scratch.

511
00:24:18,670 --> 00:24:21,040
Но в языке С вы можете назвать 
её как угодно.

512
00:24:21,040 --> 00:24:22,565
Я могу назвать её xyz.

513
00:24:22,565 --> 00:24:25,690
Все эти имена не очень наглядны, 
поэтому я назову её answer (ответ).

514
00:24:25,690 --> 00:24:27,100
Вы можете использовать любое слово.

515
00:24:27,100 --> 00:24:28,990
Но в С все немного по другому.

516
00:24:28,990 --> 00:24:34,480
С - олдскульный язык, поэтому вы должны
явно указать тип значения,

517
00:24:34,480 --> 00:24:37,630
которое вы получаете, и, соответственно,
храните в этой переменной.

518
00:24:37,630 --> 00:24:40,040
Поэтому слева от 
имени переменной

519
00:24:40,040 --> 00:24:43,810
я должен сказать компьютеру, что
тип значения, который мне нужно хранить

520
00:24:43,810 --> 00:24:45,010
будет строкой.

521
00:24:45,010 --> 00:24:49,180
Скоро мы узнаем, что
существуют и другие типы значений.

522
00:24:49,180 --> 00:24:53,860
Есть цифры и прочие, но сейчас
мы просто будем хранить строку.

523
00:24:53,860 --> 00:24:56,760
Но мы кое-что упустили в 
этой строчке кода.

524
00:24:56,760 --> 00:24:57,700
Зрители: точка с запятой.

525
00:24:57,700 --> 00:24:58,600
DAVID MALAN: точка с запятой, верно?

526
00:24:58,600 --> 00:25:00,392
Конец мысли,
и это была не маленькая мысль,

527
00:25:00,392 --> 00:25:02,200
и точка с заятой завершает эту мысль.

528
00:25:02,200 --> 00:25:04,700
Знак "равно" в этом случае
отличается от привычного нам в алгебре.

529
00:25:04,700 --> 00:25:07,750
Если вы вспомните математику,
вы скажите, что Х равен Y.

530
00:25:07,750 --> 00:25:11,440
Когда X равен Y, то это буквально означает,
что X - это тоже самое, что и Y.

531
00:25:11,440 --> 00:25:14,740
Но в языках программирования,
знак "равно"

532
00:25:14,740 --> 00:25:17,990
как правило означает 
перемещение справа налево.

533
00:25:17,990 --> 00:25:20,560
Этот знак "равно" 
не подразумевает равенство.


534
00:25:20,560 --> 00:25:24,070
Он обозначает "присваивание", 
или "оператор присваивания".

535
00:25:24,070 --> 00:25:27,200
Перемести что-либо справа
в левую часть.

536
00:25:27,200 --> 00:25:31,600
Таким образом, если функция get_string,
точно так же как функция ask,

537
00:25:31,600 --> 00:25:35,140
спрашивает у пользователя его имя
и возвращает значение,

538
00:25:35,140 --> 00:25:37,930
то вы помещаете это имя
в переменную,

539
00:25:37,930 --> 00:25:40,192
которая называется answer.
Справа налево.

540
00:25:40,192 --> 00:25:42,650
Как мы и написали эту
строку справа налево,

541
00:25:42,650 --> 00:25:45,710
вы должны думать о выполнении этой команды
как справа налево.

542
00:25:45,710 --> 00:25:48,310
Итак, на текущий момент,
у нас есть

543
00:25:48,310 --> 00:25:52,960
где-то в памяти компьютера так называемая
переменная - ответ пользователя

544
00:25:52,960 --> 00:25:54,130
на вопрос какое у него имя.

545
00:25:54,130 --> 00:25:55,540
Что мы хотим с этим сделать?

546
00:25:55,540 --> 00:25:58,093
В языке С нет функции join,
поэтому нам

547
00:25:58,093 --> 00:26:00,010
придется сделать это
немного иначе.

548
00:26:00,010 --> 00:26:03,613
В С есть функция аналогичная функции say.
Как эта функция называется?

549
00:26:03,613 --> 00:26:04,340
Зрители: Printf.

550
00:26:04,340 --> 00:26:05,173
DAVID MALAN: Printf.

551
00:26:05,173 --> 00:26:08,440
Printf - это функция, которую мы испольуем 
когда хотим что-то сказать или вывести

552
00:26:08,440 --> 00:26:09,320
на экране.

553
00:26:09,320 --> 00:26:10,993
Поэтому я продолжу, используя printf.

554
00:26:10,993 --> 00:26:13,660
И я буду использовать скобки, 
потому что скобки означают:

555
00:26:13,660 --> 00:26:18,670
здесь идут данные, называемые в программировании
аргументами или параметрами.

556
00:26:18,670 --> 00:26:21,100
Для нас это  
синонимы.

557
00:26:21,100 --> 00:26:23,350
И сейчас это всё немного 
неправильно, да?

558
00:26:23,350 --> 00:26:29,180
Потому что я не хочу просто вывести
кавычки, привет, запятая, ответ, кавычки.

559
00:26:29,180 --> 00:26:29,680
Почему?

560
00:26:29,680 --> 00:26:34,480
Почему будет неверно сделать
кавычки, привет, запятая, ответ, кавычки?

561
00:26:34,480 --> 00:26:35,155
Что вы сказали?

562
00:26:35,155 --> 00:26:36,400
Зрители: Это только выведет на экран answer.

563
00:26:36,400 --> 00:26:39,323
DAVID MALAN: Верно, этим мы буквально
скажем привет, запятая, answer. Верно?

564
00:26:39,323 --> 00:26:40,490
А это не то, что мы хотим.

565
00:26:40,490 --> 00:26:41,530
Мы не хотим сказать "привет answer"

566
00:26:41,530 --> 00:26:43,450
Мы хотим сказать: Привет, Дэвид 
или Привет, Брайан.

567
00:26:43,450 --> 00:26:45,280
Или привет любой, кто играет в эту программу.

568
00:26:45,280 --> 00:26:49,900
То есть я должен как то присоединить слово 
"привет" к тому, что введёт пользователь.

569
00:26:49,900 --> 00:26:53,335
То, как это делается с помощью printf,
немного отличается от Scratch.

570
00:26:53,335 --> 00:26:55,550
Мы будем использовать так называемый плейсхолдер.

571
00:26:55,550 --> 00:26:57,550
Вы буквально пишете
предложение или фразу,

572
00:26:57,550 --> 00:27:00,220
которую хотите сказать 
или вывести на экран,

573
00:27:00,220 --> 00:27:03,340
но заранее не знаете
значение этой фразы,

574
00:27:03,340 --> 00:27:08,570
поэтому вы используете плейсхолдер с помощью
знака процента и s, обозначающую string (строка).

575
00:27:08,570 --> 00:27:11,320
И это потому, что я пишу
программу сегодня.

576
00:27:11,320 --> 00:27:13,840
Я понятия не имею кто будет 
пользоваться ей завтра.

577
00:27:13,840 --> 00:27:15,910
Поэтому я хочу использовать
плейсхолдер,

578
00:27:15,910 --> 00:27:19,400
чтобы если кто-то запустит эту программу
завтра или в любой другой день,

579
00:27:19,400 --> 00:27:21,070
его имя вставлялось динамически.

580
00:27:21,070 --> 00:27:23,410
Сегодня я, конечно же, 
не знаю их имён.

581
00:27:23,410 --> 00:27:26,350
Поэтому кавычки, привет, запятая,
процент, s, кавычки.

582
00:27:26,350 --> 00:27:30,130
%s - это всего лишь плейсхолдер
для чего угодно, что я хочу вставить в это место.

583
00:27:30,130 --> 00:27:32,590
Бэкслеш n, конечно же,
означает переход на новую строку.

584
00:27:32,590 --> 00:27:35,590
Единственное, что в этой строке новое - 
это %s.

585
00:27:35,590 --> 00:27:39,490
Далее, оказыватся, что функции в С,
так же как в Scratch,

586
00:27:39,490 --> 00:27:40,990
могут не принимать аргументы.

587
00:27:40,990 --> 00:27:42,550
Или они могут принять один аргумент.

588
00:27:42,550 --> 00:27:44,650
Или они могут принять два или более аргументов.

589
00:27:44,650 --> 00:27:49,310
И если они могут принять два и более аргументов,
вы просто перечисляете их через запятую.

590
00:27:49,310 --> 00:27:50,450
Так работает printf.

591
00:27:50,450 --> 00:27:53,200
Вы знали бы это только если 
вас этому научили,

592
00:27:53,200 --> 00:27:55,720
или вы прочитали документацию.
Таким образом, вы можете

593
00:27:55,720 --> 00:27:59,560
передать одну строку
в качестве ввода:

594
00:27:59,560 --> 00:28:00,910
кавычки, что-либо, кавычки.

595
00:28:00,910 --> 00:28:03,010
Но если вы используете здесь
плейсхолдер,

596
00:28:03,010 --> 00:28:06,520
вы говорите компьютеру, 
что именно нужно подставить, добавляя запятую, 

597
00:28:06,520 --> 00:28:10,570
затем имя переменной, которую хотите
вставить.

598
00:28:10,570 --> 00:28:14,120
Эти две строчки кода эквивалентны
этим строчкам здесь.

599
00:28:14,120 --> 00:28:15,870
Но хотя на первый взгляд, 
может показаться,

600
00:28:15,870 --> 00:28:17,620
что это немного загадочно,
вы просто 

601
00:28:17,620 --> 00:28:19,480
разберете это до конца 
на отдельные компоненты

602
00:28:19,480 --> 00:28:23,020
справа налево и затем 
снаружи внутрь, 

603
00:28:23,020 --> 00:28:28,150
вы обычно можете сделать вывод даже о том, 
что делает новый код, который вы никогда 

604
00:28:28,150 --> 00:28:29,860
раньше не видели.

605
00:28:29,860 --> 00:28:33,880
Есть ли вопросы по этим 
двум строкам Scratch или по C?

606
00:28:33,880 --> 00:28:34,594
Да?

607
00:28:34,594 --> 00:28:36,570
АУДИТОРИЯ: Можно ли добавлять [неразборчиво]?

608
00:28:36,570 --> 00:28:40,220
...

609
00:28:40,220 --> 00:28:41,220
DAVID MALAN: Безусловно.

610
00:28:41,220 --> 00:28:42,450
Можно ли добавлять другие переменные?

611
00:28:42,450 --> 00:28:46,290
Если бы я имел больше переменных в этой
программе, благодаря большему количеству строк кода,

612
00:28:46,290 --> 00:28:49,740
Я мог бы написать: запятая, что-то
еще, запятая, что-то еще, запятая.

613
00:28:49,740 --> 00:28:52,620
И я бы просто взял один плейсхолдер
из этого выражения

614
00:28:52,620 --> 00:28:56,340
в кавычках для всех переменных,
которые я хочу подключить.

615
00:28:56,340 --> 00:28:57,670
И они будут идти слева направо.

616
00:28:57,670 --> 00:29:00,510
Итак, если бы я имел два %s здесь, 
то 

617
00:29:00,510 --> 00:29:01,890
первый бы шел после первой запятой.

618
00:29:01,890 --> 00:29:04,481
А второй шел бы после второй запятой.

619
00:29:04,481 --> 00:29:06,485
АУДИТОРИЯ: Так вам нужен %s [НЕРАЗБОРЧИВО]

620
00:29:06,485 --> 00:29:07,360
DAVID MALAN: Верно.

621
00:29:07,360 --> 00:29:10,962
Вам нужен %s после каждого плейсхолдера,
который вы хотите подключить если это срока.

622
00:29:10,962 --> 00:29:13,420
И мы собираемся увидеть остальные 
плейсхолдеры через мгновение.

623
00:29:13,420 --> 00:29:14,720
Хороший вопрос.

624
00:29:14,720 --> 00:29:16,464
Еще вопросы?

625
00:29:16,464 --> 00:29:17,230
Нет?

626
00:29:17,230 --> 00:29:18,440
Ах да, сзади.

627
00:29:18,440 --> 00:29:20,705
АУДИТОРИЯ: Есть ли другие способы 
конкатенации строк?

628
00:29:20,705 --> 00:29:23,080
DAVID MALAN: Есть ли другие способы 
конкатенации строк?

629
00:29:23,080 --> 00:29:26,533
Короткий ответ - да, много 
способов, но все они непростые.

630
00:29:26,533 --> 00:29:29,200
Мы займемся этим, вообще-то,
через пару недель.

631
00:29:29,200 --> 00:29:33,290
Printf, на данный момент, безусловно
самый простой способ сделать это.

632
00:29:33,290 --> 00:29:34,175
Еще вопросы?

633
00:29:34,175 --> 00:29:36,550
И если я когда-нибудь пропущу
ваши руки, то это из-за яркого света.

634
00:29:36,550 --> 00:29:37,510
Просто призови меня.

635
00:29:37,510 --> 00:29:38,200
Сюда.

636
00:29:38,200 --> 00:29:40,550
Ок, вы трое.

637
00:29:40,550 --> 00:29:41,571
Вон там справа.

638
00:29:41,571 --> 00:29:43,890
АУДИТОРИЯ: [НЕРАЗБОРЧИВО]

639
00:29:43,890 --> 00:29:44,640
DAVID MALAN: Уверен.

640
00:29:44,640 --> 00:29:45,420
Что такое строка?

641
00:29:45,420 --> 00:29:50,530
Строка это последовательность нулей
или других символов в двойных кавычках.

642
00:29:50,530 --> 00:29:54,060
Иными словами, это слово, фраза, 
предложение, абзац - ноль

643
00:29:54,060 --> 00:29:58,883
или больше символов, в алфавитном 
порядке, в двойных ковычках.

644
00:29:58,883 --> 00:29:59,550
Еще вопросы?

645
00:29:59,550 --> 00:30:01,100
Да?

646
00:30:01,100 --> 00:30:07,083
АУДИТОРИЯ: Что произойдет, если \n
окажется за пределами кавычек?

647
00:30:07,083 --> 00:30:08,500
DAVID MALAN: Действительно хороший вопрос.

648
00:30:08,500 --> 00:30:11,270
Что произойдет, если \n
окажется за пределами кавычек?

649
00:30:11,270 --> 00:30:12,210
Что ж, позвольте мне попробовать сделать это.

650
00:30:12,210 --> 00:30:14,210
И, честно говоря, это 
правильный подход.

651
00:30:14,210 --> 00:30:17,250
В любое время, двигаясь вперед, у вас будут 
возникать те же самые  инстинктивные вопросы,

652
00:30:17,250 --> 00:30:17,880
просто попробуйте это.

653
00:30:17,880 --> 00:30:19,770
Вы не сможете причинить времд компьютеру.

654
00:30:19,770 --> 00:30:22,170
Так что позвольте мне пойти вперед
и просто случайно, если хотите,

655
00:30:22,170 --> 00:30:24,510
ввести \n вне кавычек,

656
00:30:24,510 --> 00:30:25,978
ваш вопрос именно об этом, я полагаю.

657
00:30:25,978 --> 00:30:27,520
Окей, давайте посмотрим что произойдет.

658
00:30:27,520 --> 00:30:29,490
Так что я сейчас пойду и 
запущу Clang.

659
00:30:29,490 --> 00:30:31,470
Теперь я знаю, как сделать
нужное мне имя,

660
00:30:31,470 --> 00:30:34,380
поэтому воспользуюсь 
этим знанием: -o hello.

661
00:30:34,380 --> 00:30:36,720
И теперь я пойду 
дальше и говорю hello.c,

662
00:30:36,720 --> 00:30:38,940
который, я думаю, будет сломан.

663
00:30:38,940 --> 00:30:41,910
И в самом деле, что-то, 
действительно тут сломано.

664
00:30:41,910 --> 00:30:43,420
Давайте посмотрим в чем ошибка.

665
00:30:43,420 --> 00:30:48,210
И это тоже немного загадочно, 
но текст ошибки такой: hello.c двоеточие 5 двоеточие 26.

666
00:30:48,210 --> 00:30:49,240
Что здесь происходит?

667
00:30:49,240 --> 00:30:50,370
Давайте я уменьшу это.

668
00:30:50,370 --> 00:30:53,110
После любой сделаной ошибки в вашем коде
на подобии этой, 

669
00:30:53,110 --> 00:30:57,870
Clang попытается помочь вам выяснить
где эта ошибка или баг находятся.

670
00:30:57,870 --> 00:31:02,760
Надпись "colon 5" в hello.c означает
что вашу ошибку стоит искать в строке 5

671
00:31:02,760 --> 00:31:07,930
Далее, видите, там написана ошибка - ожидается
что круглые скобки будут закрыты прямо здесь.

672
00:31:07,930 --> 00:31:11,500
Так что это немного странно, потому что нет,
я не хочу закрывать скобки,

673
00:31:11,500 --> 00:31:12,000
Я думаю.

674
00:31:12,000 --> 00:31:13,170
Я хочу начать с новой строчки.

675
00:31:13,170 --> 00:31:16,080
Так что система не в состоянии
сказать вам, эй

676
00:31:16,080 --> 00:31:18,450
этот \n должен быть 
внутри кавычек

677
00:31:18,450 --> 00:31:21,780
Но это может в конечном счете помочь вам
выяснить где находится ошибка.

678
00:31:21,780 --> 00:31:24,000
И так, она где-то тут 
рядом, и в какой-то момент

679
00:31:24,000 --> 00:31:26,850
ваша собственная память или гугление
помогут вам понять,

680
00:31:26,850 --> 00:31:29,717
что да, это должно быть
снаружи кавычек.

681
00:31:29,717 --> 00:31:30,300
Хороший вопрос.

682
00:31:30,300 --> 00:31:31,883
Был ли там еще третий вопрос?

683
00:31:31,883 --> 00:31:32,430
Да?

684
00:31:32,430 --> 00:31:32,930
Нет?

685
00:31:32,930 --> 00:31:33,480
OK.

686
00:31:33,480 --> 00:31:37,860
Итак, давайте перейдем к нескольким
другим функциям

687
00:31:37,860 --> 00:31:39,360
которые мы также можем сделать - 

688
00:31:39,360 --> 00:31:42,630
а именно, реализуем ту же самую программу,
которая у меня только что была.

689
00:31:42,630 --> 00:31:45,600
Позвольте мне продолжить и закрыть этот
файл, а затем создать новый,

690
00:31:45,600 --> 00:31:49,173
скажем, string.c, потому что я сейчас
эксперементирую со строками.

691
00:31:49,173 --> 00:31:50,590
И я собираюсь начать как и раньше - 

692
00:31:50,590 --> 00:31:55,260
с #include <stdio.h> 
int main(void)

693
00:31:55,260 --> 00:32:01,470
А потом я собираюсь пойти дальше и 
сказать string answer равно get_string,

694
00:32:01,470 --> 00:32:07,020
скобка открывается, кавычка, 
как тебя зовут, знак вопроса, \n, кавычка, скобка и ;

695
00:32:07,020 --> 00:32:09,448
И в качестве отступления, все, 
что я печатал на клавиатуре сегодня,

696
00:32:09,448 --> 00:32:11,490
позже мы разместим на сайте курса.

697
00:32:11,490 --> 00:32:15,010
Так что нет необходимости набирать 
каждый маленький символ, если вы не хотите.

698
00:32:15,010 --> 00:32:18,448
И затем я продолжаю и пишу printf,
открываю ковычки, hello answer. 

699
00:32:18,448 --> 00:32:20,490
Не answer, потому что мы 
утверждали, что это плохо.

700
00:32:20,490 --> 00:32:22,440
Он буквально скажет "answer".


701
00:32:22,440 --> 00:32:24,750
Я хочу сделать плейсхолдер, процент и s.

702
00:32:24,750 --> 00:32:29,920
И теперь обратный слеш n,
запятая, answer, точка с запятой.

703
00:32:29,920 --> 00:32:32,910
Так что я думаю я перевел
код со слайда

704
00:32:32,910 --> 00:32:37,920
в мое программное окружение, он теперь
в файле, по имени string.c.

705
00:32:37,920 --> 00:32:39,300
Так что давайте я уменьшу.

706
00:32:39,300 --> 00:32:41,790
И если я хочу скомпилировать
программу, превратить ее

707
00:32:41,790 --> 00:32:46,795
из исходного кода в машинный код,
что мне нужно тут написать?

708
00:32:46,795 --> 00:32:47,295
Clang.

709
00:32:47,295 --> 00:32:50,150


710
00:32:50,150 --> 00:32:51,210
string.c.

711
00:32:51,210 --> 00:32:53,590
Но он даст мне программу,
которая по умолчанию зовется

712
00:32:53,590 --> 00:32:56,030
a.out, что не очень то понятно.

713
00:32:56,030 --> 00:32:58,670
Так что давайте я сделаю
-o string, чтобы моя программа

714
00:32:58,670 --> 00:33:00,230
называлась string.

715
00:33:00,230 --> 00:33:02,090
Но я могу ее назвать как хочу.

716
00:33:02,090 --> 00:33:04,975
Я могу назвать ее
"программа два", если мне угодно.

717
00:33:04,975 --> 00:33:06,350
Так что давайте нажмем Enter.

718
00:33:06,350 --> 00:33:10,220
И боже мой, ошибок больше
чем строчек кода,

719
00:33:10,220 --> 00:33:12,320
что немного тревожно.

720
00:33:12,320 --> 00:33:15,530
И это второй уровень, где вы
должны расслабиться, так что это значит

721
00:33:15,530 --> 00:33:17,113
что компьютер чего то не понял, верно?

722
00:33:17,113 --> 00:33:20,480
Вы не можете быть так плохи в программировании,
чтобы сделать больше ошибок чем строчек кода

723
00:33:20,480 --> 00:33:21,860
который вы написали.

724
00:33:21,860 --> 00:33:25,370
Так что реально компьютер просто
запутался где то,

725
00:33:25,370 --> 00:33:28,670
и начинает спотыкаться о собственные
ноги, говоря образно.

726
00:33:28,670 --> 00:33:31,910
Он не знает где ошибка, и начинает
неправильно интерпретировать правильный код

727
00:33:31,910 --> 00:33:33,020
как неправильный.

728
00:33:33,020 --> 00:33:38,100
Так что нужно начинать всегда с первой
ошибки.

729
00:33:38,100 --> 00:33:41,450
Вы могли заметить, что я уже проскроллил
на самый верх вывода команды

730
00:33:41,450 --> 00:33:44,570
которую я напечатал, вот тут, где
подсвечено.

731
00:33:44,570 --> 00:33:47,270
Сфокусируйтесь на первой ошибке,
может остальные

732
00:33:47,270 --> 00:33:50,985
просто "фантомные" ошибки.

733
00:33:50,985 --> 00:33:53,360
Так что давайте приблизим
эту часть экрана

734
00:33:53,360 --> 00:33:55,700
и посмотрим что мы можем с ней сделать.

735
00:33:55,700 --> 00:33:59,420
Команда которую я запустил:
Clang -o string string.c.

736
00:33:59,420 --> 00:34:02,480
И это значит что мой входной параметр
это исходный код в string.c.

737
00:34:02,480 --> 00:34:06,500
Я хочу чтобы вывод был машинным кодом
в файл по имени string.

738
00:34:06,500 --> 00:34:09,409
Итак, ошибка начинается в
string.c на пятой строчке,

739
00:34:09,409 --> 00:34:11,540
и это очень знакомое нам место.

740
00:34:11,540 --> 00:34:13,820
Использование неопределенного идентификатора string.

741
00:34:13,820 --> 00:34:19,960
Вы имели в виду-- ожидается-- stdin?

742
00:34:19,960 --> 00:34:21,280
Не, я не это имел в виду.

743
00:34:21,280 --> 00:34:22,600
Я имел в виду string в этом случае.

744
00:34:22,600 --> 00:34:25,159
И вот здесь, тоже,
компьютер запутался,

745
00:34:25,159 --> 00:34:28,179
и даже зеленое сообщение с помощью,
не очень то помогает.

746
00:34:28,179 --> 00:34:29,679
Нет, я хочу string.

747
00:34:29,679 --> 00:34:31,270
Я не хочу стандартный in.

748
00:34:31,270 --> 00:34:34,060
Но причина для ошибки
в том, что технически

749
00:34:34,060 --> 00:34:37,420
во всяком случае, сейчас,
нет такой вещи как string,

750
00:34:37,420 --> 00:34:41,699
S-T-R-I-N-G в Си. Это реально
иллюстративный пример, который

751
00:34:41,699 --> 00:34:44,949
мы будет использовать пару недель, пока, отвечая
на ваш вопрос,

752
00:34:44,949 --> 00:34:48,340
мы не покажем, что реально происходит
"под капотом" у компьютера,

753
00:34:48,340 --> 00:34:51,130
и то что происходит, чтобы
имплементировать string.

754
00:34:51,130 --> 00:34:56,620
Так вот, string это штука,
которую курс CS50 вам дает

755
00:34:56,620 --> 00:35:01,570
в файле под названием CS50.h

756
00:35:01,570 --> 00:35:06,355
Так же как файл под названием
стандартный I/O--

757
00:35:06,355 --> 00:35:10,330
где I/O значит ввод(input)/вывод(output),
типа печатать строчку, получить строчку из ввода.

758
00:35:10,330 --> 00:35:16,060
Как здесь, в файле stdio.h,
где обьявлен printf,

759
00:35:16,060 --> 00:35:19,420
все функции, которые я буду
использовать в этой программе,

760
00:35:19,420 --> 00:35:25,000
типа get_string, они хранятся
в файле CS50.h

761
00:35:25,000 --> 00:35:28,150
Так что моя ошибка просто подняла
проблему, когда я компилировал этот код,

762
00:35:28,150 --> 00:35:30,640
компьютер не имел
никакого понятия что такое string.

763
00:35:30,640 --> 00:35:34,870
И не понимает-- мы увидим это
что такое get_string.

764
00:35:34,870 --> 00:35:37,570
Так что давайте я перекомпилирую
это сейчас.

765
00:35:37,570 --> 00:35:46,130
Я печатаю Clang -o string string.c
и приближаю.

766
00:35:46,130 --> 00:35:46,630
Отлично.

767
00:35:46,630 --> 00:35:47,820
Enter.

768
00:35:47,820 --> 00:35:49,930
OK, выполняется.

769
00:35:49,930 --> 00:35:51,100
Все еще баг.

770
00:35:51,100 --> 00:35:53,230
Тут ошибка, потому что красный
цвет не может

771
00:35:53,230 --> 00:35:54,850
значить ничего хорошего, в этом контексте.

772
00:35:54,850 --> 00:35:56,590
Ну да, точно, это ошибка.

773
00:35:56,590 --> 00:35:58,940
Но их число намного меньше.

774
00:35:58,940 --> 00:36:02,080
Так что время последнего набора команд,
про который мы поговорим сейчас.

775
00:36:02,080 --> 00:36:04,240
Обратите внимание, что нам говорит сообщение об ошибке.

776
00:36:04,240 --> 00:36:07,450
После того как я запустил Clang -o
string string.c, тут

777
00:36:07,450 --> 00:36:09,490
все еще проблема в моей функции main.

778
00:36:09,490 --> 00:36:11,170
Какая проблема?

779
00:36:11,170 --> 00:36:13,480
Неопределенная ссылка на get_string.

780
00:36:13,480 --> 00:36:18,490
Так что получается, когда вы используете
библиотеку CS50, вам нужно сделать две вещи.

781
00:36:18,490 --> 00:36:21,100
В исходниках, вы должны сказать
компьютеру

782
00:36:21,100 --> 00:36:23,800
включить этот файл
CS50.h, где, снова,

783
00:36:23,800 --> 00:36:26,860
функции подобные get_string
и слово string

784
00:36:26,860 --> 00:36:28,870
уже созданы для вас.

785
00:36:28,870 --> 00:36:32,170
Но когда вы компилируете код,
вам нужно, наверное немного избыточно,

786
00:36:32,170 --> 00:36:37,060
но по другим причинам, сказать компьютеру
чтобы он добавил весь этот код

787
00:36:37,060 --> 00:36:40,600
который сотрудники CS50 написали, чтобы
создать get_string и string

788
00:36:40,600 --> 00:36:44,110
и другие функции, подобные им.

789
00:36:44,110 --> 00:36:50,530
Поэтому я напишу Clang
-o string string.c, точно как только что,

790
00:36:50,530 --> 00:36:54,400
но надо дать компьютеру эту
специальную инструкцию

791
00:36:54,400 --> 00:36:56,410
чтобы слинковать с CS50.

792
00:36:56,410 --> 00:36:59,320
И вы поймете зачем, в течение
следующих двух недель

793
00:36:59,320 --> 00:37:02,620
Но пока это просто -l для линкования и CS50.

794
00:37:02,620 --> 00:37:04,720
И все вот это говорит
компьютеру, что

795
00:37:04,720 --> 00:37:10,550
единицы и нули моей программы, должны
придти из string.c прямо

796
00:37:10,550 --> 00:37:11,050
сюда.

797
00:37:11,050 --> 00:37:12,400
Это мой исходный код.

798
00:37:12,400 --> 00:37:16,780
Но сотрудники CS50, годы назад,
также написали код для Си, чтобы

799
00:37:16,780 --> 00:37:19,420
дать вам функции get_string
и другие, чтобы

800
00:37:19,420 --> 00:37:22,390
у вас были переменные, такие как строки.

801
00:37:22,390 --> 00:37:27,070
Нули и единицы из библиотеки CS50
хранятся где-то в облаке,

802
00:37:27,070 --> 00:37:29,920
и их нужно как-то связать
вместе с вашими.

803
00:37:29,920 --> 00:37:34,000
Подобно тому, как ваш код находится
в этом файле, наш код находится в другом.

804
00:37:34,000 --> 00:37:37,330
Указание компьютеру включить его
в ваш исходный код

805
00:37:37,330 --> 00:37:40,980
и связать его с помощью данной команды —
всего лишь магический способ сказать:

806
00:37:40,980 --> 00:37:46,930
"соедини мой код с кодом из CS50 в одну
программу, которую я могу запустить".

807
00:37:46,930 --> 00:37:49,180
Так. Всё это, если честно,
начинает становиться

808
00:37:49,180 --> 00:37:53,170
крайне сложным. Я бы даже сказал,
неоправданно сложным.

809
00:37:53,170 --> 00:37:56,200
Поэтому есть способ получше.

810
00:37:56,200 --> 00:38:00,310
Оказывается, что для компиляции кода

811
00:38:00,310 --> 00:38:01,720
вам не нужно запоминать команду "-o".

812
00:38:01,720 --> 00:38:03,935
Как и команду "-l CS50".

813
00:38:03,935 --> 00:38:07,060
Вам не нужна ни одна из этих команд,
разве что понимание основной идеи.

814
00:38:07,060 --> 00:38:12,130
Вместо этого вы можете сказать: "создай
программу под названием "string" — и всё.

815
00:38:12,130 --> 00:38:15,970
Весь этот вывод будет
сгенерирован автоматически,

816
00:38:15,970 --> 00:38:18,610
когда вы дадите компьютеру
команду на сборку программы.

817
00:38:18,610 --> 00:38:24,130
И программа сборки (make) сама разберётся,
какие аргументы командной строки нужно использовать,

818
00:38:24,130 --> 00:38:26,800
какое имя присвоить файлу,
с какими библиотеками

819
00:38:26,800 --> 00:38:29,650
или чужими кусочками кода необходимо
связать программу.

820
00:38:29,650 --> 00:38:32,500
Таким образом, чтобы скомпилировать
программу,

821
00:38:32,500 --> 00:38:36,460
вам достаточно буквально сказать "сделай" (make)
и указать имя программы.

822
00:38:36,460 --> 00:38:38,680
Но выглядеть это должно не как "make string.c",

823
00:38:38,680 --> 00:38:41,260
а как "make" и имя программы.

824
00:38:41,260 --> 00:38:43,180
Make, то есть внешняя программа,
сама поймёт,

825
00:38:43,180 --> 00:38:46,630
что вы имели в виду что-то с именем string.c.

826
00:38:46,630 --> 00:38:48,910
Можно вернуться назад и проделать это
для программы hello.

827
00:38:48,910 --> 00:38:50,770
Make hello.

828
00:38:50,770 --> 00:38:53,150
Ой, я так и не исправил старую ошибку.

829
00:38:53,150 --> 00:38:56,660
Давайте-ка я открою файл hello.c

830
00:38:56,660 --> 00:38:59,740
и исправлю это для потомков.

831
00:38:59,740 --> 00:39:02,110
Сохраню файл или включу автосохранение.

832
00:39:02,110 --> 00:39:03,310
А теперь — make hello.

833
00:39:03,310 --> 00:39:06,100
И вуаля — всё то же самое.

834
00:39:06,100 --> 00:39:06,820
Да?

835
00:39:06,820 --> 00:39:09,543
ЗАЛ: Является ли make стандартной
программой?

836
00:39:09,543 --> 00:39:10,960
DAVID MALAN: Очень хороший вопрос.

837
00:39:10,960 --> 00:39:13,300
Является ли make стандартной
или же она специфична для CS50?

838
00:39:13,300 --> 00:39:16,280
Нет, она не специфична для CS50.

839
00:39:16,280 --> 00:39:19,460
Это стандартное средство,
которое есть на компьютерах,

840
00:39:19,460 --> 00:39:21,410
как правило под управлением ОС Unix или Linux.

841
00:39:21,410 --> 00:39:24,020
И действительно, инструмент песочницы,
который мы используем,

842
00:39:24,020 --> 00:39:26,480
сам по себе является компьютером в облаке,
хотя у него

843
00:39:26,480 --> 00:39:30,960
есть только эти два окна, вкладки сверху
и окно терминала снизу.

844
00:39:30,960 --> 00:39:32,960
Выполнив вход в песочницу "CS50 Sandbox",
вы получаете доступ

845
00:39:32,960 --> 00:39:36,620
к собственному серверу в облаке
под управлением операционной системы Linux.

846
00:39:36,620 --> 00:39:41,600
А Clang, make и прочие инструменты, которые
мы используем, такие как ls и rm,

847
00:39:41,600 --> 00:39:43,700
все существуют в операционной системе.

848
00:39:43,700 --> 00:39:46,580
Они совсем не специфичны для CS50.

849
00:39:46,580 --> 00:39:47,768
Спрашивайте.

850
00:39:47,768 --> 00:39:51,235
ЗАЛ: Получается, программа hello
будет машинным кодом, а не [НЕРАЗБОРЧИВО]?

851
00:39:51,235 --> 00:39:52,110
DAVID MALAN: Правильно.

852
00:39:52,110 --> 00:39:53,520
Hello — это машинный код.

853
00:39:53,520 --> 00:39:55,756
Hello.c — это исходный код.

854
00:39:55,756 --> 00:39:57,244
ЗАЛ: То есть [НЕРАЗБОРЧИВО]?

855
00:39:57,244 --> 00:40:00,915


856
00:40:00,915 --> 00:40:01,790
DAVID MALAN: Верно.

857
00:40:01,790 --> 00:40:06,110
Make — умная программа, предназначенная
для облегчения нашей жизни.

858
00:40:06,110 --> 00:40:11,210
Если выполнить команду "make hello",
она будет искать файл с именем hello.c.

859
00:40:11,210 --> 00:40:14,450
И если найдёт — создаст программу
с именем "hello",

860
00:40:14,450 --> 00:40:16,630
превратив исходный код в, соответственно, машинный.

861
00:40:16,630 --> 00:40:17,267
У вас вопрос?

862
00:40:17,267 --> 00:40:18,698
ЗАЛ: [НЕРАЗБОРЧИВО].

863
00:40:18,698 --> 00:40:22,498


864
00:40:22,498 --> 00:40:23,540
DAVID MALAN: Не совсем.

865
00:40:23,540 --> 00:40:27,770
Программа make ранее входила в состав
операционных систем семейства Linux,

866
00:40:27,770 --> 00:40:29,150
а также семейства Mac OS.

867
00:40:29,150 --> 00:40:31,160
В настоящее время она есть и в
составе систем семейства Windows.

868
00:40:31,160 --> 00:40:34,040
Программу make запускают
путём ввода её имени,

869
00:40:34,040 --> 00:40:37,147
а не двойным щелчком по значку.

870
00:40:37,147 --> 00:40:37,730
Хороший вопрос.

871
00:40:37,730 --> 00:40:38,882
Да-да?

872
00:40:38,882 --> 00:40:39,854
ЗАЛ: [НЕРАЗБОРЧИВО]?

873
00:40:39,854 --> 00:40:43,755


874
00:40:43,755 --> 00:40:44,880
DAVID MALAN: Это тоже хороший вопрос.

875
00:40:44,880 --> 00:40:46,610
Хранится ли программа make
на вашем компьютере

876
00:40:46,610 --> 00:40:47,930
или на облачной машине?

877
00:40:47,930 --> 00:40:49,350
Второе. В облаке.

878
00:40:49,350 --> 00:40:52,100
На данном этапе семестра и в течение
первых нескольких недель

879
00:40:52,100 --> 00:40:55,310
всё, что мы будем делать, будет находиться
в облачной стандартизированной среде

880
00:40:55,310 --> 00:40:58,670
под названием "CS50 Sandbox",
а чуть позже — в среде "CS50 Lab".

881
00:40:58,670 --> 00:41:02,780
Но эта среда призвана представлять собой
обычный компьютер на Linux,

882
00:41:02,780 --> 00:41:04,210
Mac OS или другой системе.

883
00:41:04,210 --> 00:41:05,960
Однако программное обеспечение всё равно
немного отличается,

884
00:41:05,960 --> 00:41:09,470
поэтому мы ориентируемся на Linux
как на крайне популярную систему

885
00:41:09,470 --> 00:41:12,140
среди разработчиков программного обеспечения.

886
00:41:12,140 --> 00:41:15,265
Ладно, давайте теперь посмотрим на пару
других равнозначностей, затем —

887
00:41:15,265 --> 00:41:18,015
сравнений, а после приступим к написанию
более интересных программ,

888
00:41:18,015 --> 00:41:19,220
чем банальные "hello world".

889
00:41:19,220 --> 00:41:22,400
Здесь ещё раз приведено
краткое описание способа

890
00:41:22,400 --> 00:41:25,070
преобразования исходного кода
в машинный

891
00:41:25,070 --> 00:41:28,580
с помощью программы Clang и
аргумента командной строки,

892
00:41:28,580 --> 00:41:33,322
специального параметра, -o hello,
который позволяет задать имя для файла.

893
00:41:33,322 --> 00:41:35,780
Поверьте мне, никто и никогда
не запомнит эту команду.

894
00:41:35,780 --> 00:41:37,905
А даже если вы это сделаете, печатать её
каждый раз очень утомительно.

895
00:41:37,905 --> 00:41:40,250
Именно поэтому существуют такие программы,
как make, которые

896
00:41:40,250 --> 00:41:42,142
автоматизируют весь этот процесс.

897
00:41:42,142 --> 00:41:43,850
Но делают-то они всё то же самое--

898
00:41:43,850 --> 00:41:46,700
компилируют исходный код в машинный.

899
00:41:46,700 --> 00:41:48,500
Для последующего запуска программы
мы вводим

900
00:41:48,500 --> 00:41:50,920
точку, которая соответствует
текущему каталогу,

901
00:41:50,920 --> 00:41:54,140
потому что, как мы увидим далее, на сервере
может быть множество каталогов, а затем hello,

902
00:41:54,140 --> 00:41:55,510
то есть имя программы.

903
00:41:55,510 --> 00:41:58,760
Хорошо, давайте разберём пару
других особенностей Scratch

904
00:41:58,760 --> 00:42:00,510
и то, как они будут выглядеть в Си,

905
00:42:00,510 --> 00:42:04,560
а затем начнём реализовывать на Си
более сложные программы.

906
00:42:04,560 --> 00:42:07,130
Рассмотрим вот такой пример.
Какой тип функционала

907
00:42:07,130 --> 00:42:11,450
он демонстрировал в Scratch?

908
00:42:11,450 --> 00:42:13,300
Что он позволял делать?

909
00:42:13,300 --> 00:42:14,260
ЗАЛ: Это переменная.

910
00:42:14,260 --> 00:42:16,000
DAVID MALAN: Это был
пример переменной.

911
00:42:16,000 --> 00:42:18,167
И эта переменная, в данном случае,
называлась counter (счётчик).

912
00:42:18,167 --> 00:42:21,130
Мы инициализировали её-- то есть,
установили её равной-- нулём.

913
00:42:21,130 --> 00:42:24,220
В Си (справа на экране), чтобы
добиться того же результата,

914
00:42:24,220 --> 00:42:27,190
нужно написать буквально следующее:
переменная (например,

915
00:42:27,190 --> 00:42:30,490
counter, но в целом это может быть
любое имя) равна нулю.

916
00:42:30,490 --> 00:42:33,198
Как мы помним, знак равенства —
это оператор присваивания.

917
00:42:33,198 --> 00:42:34,990
Поэтому то, что находится справа
от него, будет

918
00:42:34,990 --> 00:42:37,210
скопировано в то, что находится слева.

919
00:42:37,210 --> 00:42:41,200
Однако этого недостаточно, потому что
когда вы объявляете переменную

920
00:42:41,200 --> 00:42:44,230
и говорите: "Эй, компьютер, мне нужно
немного места для кое-какого значения",

921
00:42:44,230 --> 00:42:47,950
вы должны явно указать компьютеру
тип этой переменной.

922
00:42:47,950 --> 00:42:52,000
Мы знаем, что строки — это переменные,
хранящие набор слов.

923
00:42:52,000 --> 00:42:55,000
Но в данном случае мы хотим
хранить число.

924
00:42:55,000 --> 00:42:58,390
Поэтому в Си такой тип чисел называется
int или integer.

925
00:42:58,390 --> 00:43:00,070
I-N-T — для краткости.

926
00:43:00,070 --> 00:43:02,147
Кстати, в этой строке кода
кое-чего не хватает.

927
00:43:02,147 --> 00:43:02,980
ЗАЛ: Точки с запятой.

928
00:43:02,980 --> 00:43:03,610
DAVID MALAN: Да, точки с запятой.

929
00:43:03,610 --> 00:43:04,840
Иначе мысль не завершена.

930
00:43:04,840 --> 00:43:05,830
Что это всё значит?

931
00:43:05,830 --> 00:43:10,270
Эй, компьютер, дай мне переменную
с целочисленным типом (типом int).

932
00:43:10,270 --> 00:43:15,280
Назови её counter и помести в неё
нулевое значение

933
00:43:15,280 --> 00:43:19,970
по умолчанию. Оказывается, мы можем
делать и другие вещи с переменными.

934
00:43:19,970 --> 00:43:23,460
Например, вот так в Scratch
у нас реализовано приращение.

935
00:43:23,460 --> 00:43:27,080
Мы изменяем значение счётчика на единицу,
прибавляя 1 к переменной.

936
00:43:27,080 --> 00:43:28,510
А как сделать это в Си?

937
00:43:28,510 --> 00:43:30,800
В Си это выглядело бы примерно так.

938
00:43:30,800 --> 00:43:35,110
С точки зрения алгебры выглядит
немного парадоксально,

939
00:43:35,110 --> 00:43:38,110
потому что как может значение counter
быть равным counter + 1?

940
00:43:38,110 --> 00:43:39,560
Только вот это не равенство.

941
00:43:39,560 --> 00:43:41,780
Это присваивание справа налево.

942
00:43:41,780 --> 00:43:43,780
То есть, с левой стороны у нас counter.

943
00:43:43,780 --> 00:43:45,190
Имя переменной.

944
00:43:45,190 --> 00:43:47,500
С правой стороны — counter + 1,

945
00:43:47,500 --> 00:43:49,390
чему бы это выражение ни было равно.

946
00:43:49,390 --> 00:43:53,260
И мы копируем значение counter + 1
в переменную counter.

947
00:43:53,260 --> 00:43:56,420
У меня тут опять чего-то не хватает.
Точки с запятой.

948
00:43:56,420 --> 00:44:00,580
Но в этом примере мне уже
не нужно писать int.

949
00:44:00,580 --> 00:44:05,200
На этом этапе предполагается,
что counter существует

950
00:44:05,200 --> 00:44:08,020
и что я использовал подобную
предыдущей строку кода

951
00:44:08,020 --> 00:44:10,270
в каком-то другом месте программы.

952
00:44:10,270 --> 00:44:13,330
Ведь это разовое указание для компьютера:
"дай мне переменную с именем counter

953
00:44:13,330 --> 00:44:14,950
и позволь мне хранить в ней значения int".

954
00:44:14,950 --> 00:44:17,110
Данная строка кода предполагает,
что counter уже существует

955
00:44:17,110 --> 00:44:20,410
и что нам больше не нужно
ничего говорить про int.

956
00:44:20,410 --> 00:44:22,060
Мы это указываем всего один раз.

957
00:44:22,060 --> 00:44:24,040
Так, нам всё ещё нужна точка с запятой.

958
00:44:24,040 --> 00:44:26,680
Но если честно, это крайне типичная
операция в программировании.

959
00:44:26,680 --> 00:44:28,930
В смысле, приращение значения переменной.

960
00:44:28,930 --> 00:44:31,280
И оказывается, что сделать это можно
разными способами.

961
00:44:31,280 --> 00:44:33,520
Можно вместо этого сделать вот так--

962
00:44:33,520 --> 00:44:36,250
counter плюс-равно 1, точка с запятой.

963
00:44:36,250 --> 00:44:37,800
Это буквально то же самое.

964
00:44:37,800 --> 00:44:39,550
А если и это для вас слишком длинно,

965
00:44:39,550 --> 00:44:42,910
вы можете написать так:
counter плюс-плюс, точка с запятой,

966
00:44:42,910 --> 00:44:44,500
и это по-прежнему всё та же операция.

967
00:44:44,500 --> 00:44:47,650
В программировании такие вещи
называются синтаксическим сахаром.

968
00:44:47,650 --> 00:44:51,110
Они не добавляют уникального функционала,
который нельзя было бы реализовать иначе.

969
00:44:51,110 --> 00:44:53,800
Но они зачастую делают код более
красивым и лаконичным.

970
00:44:53,800 --> 00:44:56,680
Поэтому чаще пишут именно так.

971
00:44:56,680 --> 00:44:58,430
Хорошо, давайте рассмотрим
другой пример.

972
00:44:58,430 --> 00:45:01,750
Как это называлось в Scratch?

973
00:45:01,750 --> 00:45:03,980
Точно, условие. Решение,
которое нужно принять.

974
00:45:03,980 --> 00:45:06,310
Если что-то истинно — сделай это.

975
00:45:06,310 --> 00:45:08,720
В Си это выглядит следующим образом.

976
00:45:08,720 --> 00:45:11,260
Если x меньше y (в скобках)--

977
00:45:11,260 --> 00:45:15,300
да, они не очень похожи на вот эту
зелёную угловатую фигуру, но в Си

978
00:45:15,300 --> 00:45:16,780
мы используем скобки.

979
00:45:16,780 --> 00:45:20,380
Итак, если x меньше y (скобка
открывается, скобка закрывается),

980
00:45:20,380 --> 00:45:21,970
то — выполнить следующее.

981
00:45:21,970 --> 00:45:25,720
И так же, как этот жёлто-оранжевый
кусочек паззла как будто

982
00:45:25,720 --> 00:45:29,920
обнимает фиолетовый кусочек,
эта открывающая фигурная скобка

983
00:45:29,920 --> 00:45:32,830
и эта закрывающая фигурная скобка,
так сказать,

984
00:45:32,830 --> 00:45:36,050
готовы "обнять" или инкапсулировать
одну или несколько строк кода.

985
00:45:36,050 --> 00:45:37,090
Что это может быть за строка?

986
00:45:37,090 --> 00:45:42,640
Например, что-то такое--
printf, x меньше y, обратная косая черта, n.

987
00:45:42,640 --> 00:45:47,080
И снова новый синтаксис, но
фигурные скобки мы уже видели

988
00:45:47,080 --> 00:45:48,490
в контексте функции main.

989
00:45:48,490 --> 00:45:52,280
А круглые скобки мы видели,
когда говорили про входные значения.

990
00:45:52,280 --> 00:45:54,520
Так что это просто своего рода
шаблон языка Си, который

991
00:45:54,520 --> 00:45:58,530
мы будем использовать при каждой
операции с условием.

992
00:45:58,530 --> 00:46:01,000
Ладно, в Scratch мы видели вот такое--

993
00:46:01,000 --> 00:46:04,300
если x меньше y, то
вывести на экран "x меньше, чем y".

994
00:46:04,300 --> 00:46:06,730
Иначе вывести "x не меньше, чем y".

995
00:46:06,730 --> 00:46:11,380
В Си такая конструкция выглядит почти
так же, разве что добавляется блок else,

996
00:46:11,380 --> 00:46:15,010
и в итоге у нас два набора фигурных скобок,
готовых "обнять"

997
00:46:15,010 --> 00:46:16,600
код между ними.

998
00:46:16,600 --> 00:46:19,660
А затем нам остаётся буквально
"вставить" наши переводы в printf,

999
00:46:19,660 --> 00:46:25,060
написав printf, "x меньше, чем y", или же
printf, "x не меньше, чем y".

1000
00:46:25,060 --> 00:46:28,450
Now, notice, there's only two
semicolons in this example.

1001
00:46:28,450 --> 00:46:33,430
You generally do not end things
like conditions with semicolons.

1002
00:46:33,430 --> 00:46:37,690
You end functions or lines
involving functions with semicolons.

1003
00:46:37,690 --> 00:46:39,850
And that's not a hard,
fast rule, but you

1004
00:46:39,850 --> 00:46:42,490
don't want lines of code--
you don't want semicolons

1005
00:46:42,490 --> 00:46:43,870
after every line of code.

1006
00:46:43,870 --> 00:46:45,855
You generally want it after some action.

1007
00:46:45,855 --> 00:46:48,730
And you'll start to notice this
pattern, even though it's perhaps not

1008
00:46:48,730 --> 00:46:50,560
obvious at first.

1009
00:46:50,560 --> 00:46:52,260
All right, how about this one?

1010
00:46:52,260 --> 00:46:55,090
If, else if, else if.

1011
00:46:55,090 --> 00:46:58,900
Now, notice we're just kind of reusing
the if-else if block and then another

1012
00:46:58,900 --> 00:47:00,250
if block down here.

1013
00:47:00,250 --> 00:47:02,500
Turns out in C, it's
almost a little easier.

1014
00:47:02,500 --> 00:47:04,120
You can literally just say this--

1015
00:47:04,120 --> 00:47:07,060
if x is less than y, do
this with curly braces.

1016
00:47:07,060 --> 00:47:10,220
Else, if x is greater than
y, do this in curly braces.

1017
00:47:10,220 --> 00:47:14,160
Else, if x equals equals
y, do this in curly braces.

1018
00:47:14,160 --> 00:47:16,050
And what do you want to do in each case?

1019
00:47:16,050 --> 00:47:20,560
Different printf's based on the say
messages that we want to display.

1020
00:47:20,560 --> 00:47:23,220
But there's one curiosity here.

1021
00:47:23,220 --> 00:47:26,550
Almost looks like a typo.

1022
00:47:26,550 --> 00:47:28,278
Yeah, the double equal sign.

1023
00:47:28,278 --> 00:47:29,070
But it's not a bug.

1024
00:47:29,070 --> 00:47:29,940
It's not a mistake.

1025
00:47:29,940 --> 00:47:35,070
Why am I perhaps using double equals
here instead of a single equal sign,

1026
00:47:35,070 --> 00:47:36,990
like in Scratch?

1027
00:47:36,990 --> 00:47:37,980
Let me go over here.

1028
00:47:37,980 --> 00:47:38,687
Yeah?

1029
00:47:38,687 --> 00:47:42,335
AUDIENCE: [INAUDIBLE].

1030
00:47:42,335 --> 00:47:43,210
DAVID MALAN: Exactly.

1031
00:47:43,210 --> 00:47:46,420
I said earlier that the single equals
sign is used for assignment from right

1032
00:47:46,420 --> 00:47:47,140
to left.

1033
00:47:47,140 --> 00:47:49,120
And honestly, this is just kind
of a human situation, where

1034
00:47:49,120 --> 00:47:50,590
we painted ourselves into a corner.

1035
00:47:50,590 --> 00:47:53,050
We already use the equals
sign for assignment.

1036
00:47:53,050 --> 00:47:56,570
Then, presumably, some human realized,
oh, shoot, how do we ask the question,

1037
00:47:56,570 --> 00:47:57,808
is this equal to that?

1038
00:47:57,808 --> 00:47:59,350
Well, we've already used that symbol.

1039
00:47:59,350 --> 00:48:01,510
So humans, decades ago,
decided, all right,

1040
00:48:01,510 --> 00:48:05,200
we'll solve that problem by just
using two equals signs back to back.

1041
00:48:05,200 --> 00:48:07,690
So this is the so-called
equality operator.

1042
00:48:07,690 --> 00:48:09,633
A single equals sign
is just the assignment.

1043
00:48:09,633 --> 00:48:12,550
This is, hands down, one of the most
common mistakes to make early on,

1044
00:48:12,550 --> 00:48:15,730
especially if you use Scratch
or other languages beforehand.

1045
00:48:15,730 --> 00:48:18,880
And you just get to develop
the muscle memory over time.

1046
00:48:18,880 --> 00:48:22,030
Once you make that mistake
a few times, it'll go away.

1047
00:48:22,030 --> 00:48:24,010
All right, but it turns
out that this program,

1048
00:48:24,010 --> 00:48:26,530
while arguably correct-- or
this code, while correct,

1049
00:48:26,530 --> 00:48:30,340
in that it's going to do this or
this or that-- and I do think those

1050
00:48:30,340 --> 00:48:31,960
are the three possible situations.

1051
00:48:31,960 --> 00:48:37,090
If you've got two integers, x and y, x
is either less than y, greater than y,

1052
00:48:37,090 --> 00:48:38,530
or equal to y.

1053
00:48:38,530 --> 00:48:42,490
But one of these questions
technically doesn't need to be asked.

1054
00:48:42,490 --> 00:48:45,400
There's technically three
Boolean expressions here, right--

1055
00:48:45,400 --> 00:48:49,098
x less than y, x greater
than y, x equals equals y.

1056
00:48:49,098 --> 00:48:50,890
A Boolean expression,
recall, is a question

1057
00:48:50,890 --> 00:48:56,170
that it has a yes/no answer or a
true/false answer or a 1/0 answer.

1058
00:48:56,170 --> 00:48:59,560
But I don't need to ask
three questions here, do I?

1059
00:48:59,560 --> 00:49:00,920
I think I saw your hand.

1060
00:49:00,920 --> 00:49:01,654
Why not?

1061
00:49:01,654 --> 00:49:05,920
AUDIENCE: Well, because if
x is less than [INAUDIBLE]..

1062
00:49:05,920 --> 00:49:09,975


1063
00:49:09,975 --> 00:49:10,850
DAVID MALAN: Exactly.

1064
00:49:10,850 --> 00:49:14,570
This third question, this Boolean
expression, does x equal equal y,

1065
00:49:14,570 --> 00:49:16,700
goes without saying logically.

1066
00:49:16,700 --> 00:49:19,655
Because if x is not less than
and it's not greater than,

1067
00:49:19,655 --> 00:49:22,280
if it's just [INAUDIBLE] the only
other scenario I can think of

1068
00:49:22,280 --> 00:49:24,020
is that it equals y.

1069
00:49:24,020 --> 00:49:28,550
So we can actually simplify both
the Scratch code and the C code

1070
00:49:28,550 --> 00:49:31,978
by just having this else
condition down below, as well.

1071
00:49:31,978 --> 00:49:33,770
So we'll talk, over
the next several weeks,

1072
00:49:33,770 --> 00:49:36,230
about different qualities of code.

1073
00:49:36,230 --> 00:49:38,480
Correctness, like does it
do what it's supposed to do,

1074
00:49:38,480 --> 00:49:42,770
but also the quality of design, like did
you write this code as efficiently as

1075
00:49:42,770 --> 00:49:45,530
possible, as quickly as
possible, in a way that

1076
00:49:45,530 --> 00:49:49,160
uses the least amount of memory
and the least amount of CPU,

1077
00:49:49,160 --> 00:49:50,420
the brains of the computer?

1078
00:49:50,420 --> 00:49:54,047
And this is just an allusion
to that kind of capability.

1079
00:49:54,047 --> 00:49:55,880
All right, just a couple
of more comparisons

1080
00:49:55,880 --> 00:49:58,070
before we go back to writing some code.

1081
00:49:58,070 --> 00:49:59,397
How about something like this?

1082
00:49:59,397 --> 00:50:02,480
In Scratch, we, of course, called this
a loop-- a cycle that happens again

1083
00:50:02,480 --> 00:50:03,740
and again and again.

1084
00:50:03,740 --> 00:50:08,120
And a loop like this can be implemented
in C not quite in the same way,

1085
00:50:08,120 --> 00:50:09,080
but like this.

1086
00:50:09,080 --> 00:50:11,480
It turns out the
closest word to the word

1087
00:50:11,480 --> 00:50:14,820
forever in Scratch is the word while.

1088
00:50:14,820 --> 00:50:17,900
It kind of suggests the idea of
doing something again and again.

1089
00:50:17,900 --> 00:50:20,330
This was the word that
humans chose years ago.

1090
00:50:20,330 --> 00:50:22,280
But you don't just say while.

1091
00:50:22,280 --> 00:50:26,090
You have to say not only
what you want to do forever,

1092
00:50:26,090 --> 00:50:29,910
but you need to answer
a Boolean expression.

1093
00:50:29,910 --> 00:50:32,540
So in C, if you want
to implement a loop,

1094
00:50:32,540 --> 00:50:36,090
you need to literally be able
to say while something is true.

1095
00:50:36,090 --> 00:50:40,850
You need to ask a question to which
the answer is yes or true or one.

1096
00:50:40,850 --> 00:50:42,980
All of those are
equivalent to a programmer.

1097
00:50:42,980 --> 00:50:46,130
So what's an example of an
expression, a Boolean expression,

1098
00:50:46,130 --> 00:50:49,990
that is always true, if my goal
is to do something forever?

1099
00:50:49,990 --> 00:50:51,173
AUDIENCE: Five equals five.

1100
00:50:51,173 --> 00:50:53,340
DAVID MALAN: Is five equal
equal to five, all right.

1101
00:50:53,340 --> 00:50:55,220
I could do is four equal equal to four.

1102
00:50:55,220 --> 00:50:56,930
I could do is two greater than one.

1103
00:50:56,930 --> 00:50:59,030
I could do is one less than two.

1104
00:50:59,030 --> 00:51:01,640
I could come up with an infinite
number of Boolean expressions

1105
00:51:01,640 --> 00:51:03,800
that just logically are always true.

1106
00:51:03,800 --> 00:51:07,070
But the simplest way is
just to say literally true.

1107
00:51:07,070 --> 00:51:09,050
So it's a little hackish,
but this is perhaps

1108
00:51:09,050 --> 00:51:12,440
the simplest question you can
ask, because true, by definition,

1109
00:51:12,440 --> 00:51:16,520
it turns out, is always true,
just as false is always false.

1110
00:51:16,520 --> 00:51:19,310
And so I can literally just
say while true in order

1111
00:51:19,310 --> 00:51:24,008
to induce a infinite loop, so to
speak, that does something forever.

1112
00:51:24,008 --> 00:51:26,300
All right, let's try another
type of looping construct.

1113
00:51:26,300 --> 00:51:28,192
This was a loop that
did something 50 times.

1114
00:51:28,192 --> 00:51:30,275
This one, now we have to
get a little more clever,

1115
00:51:30,275 --> 00:51:32,360
and we have to kind of wire things up.

1116
00:51:32,360 --> 00:51:35,120
So if I want to do something
50 times, here's one way.

1117
00:51:35,120 --> 00:51:37,850
Why don't I give myself a
variable and call it counter.

1118
00:51:37,850 --> 00:51:40,760
But I could call it anything I
want and initialize it to zero.

1119
00:51:40,760 --> 00:51:42,980
Then, let me go ahead-- you know what?

1120
00:51:42,980 --> 00:51:44,510
Counter is actually pretty verbose.

1121
00:51:44,510 --> 00:51:46,490
Most programmers, when
they're just counting,

1122
00:51:46,490 --> 00:51:49,557
they, by convention, just use
the letter i, i for integer.

1123
00:51:49,557 --> 00:51:51,140
But you can call it anything you want.

1124
00:51:51,140 --> 00:51:53,810
So I'm going to call
it int i equals zero.

1125
00:51:53,810 --> 00:51:56,990
Then I'm going to go ahead
and do the following.

1126
00:51:56,990 --> 00:51:59,840
While the following expression
is true, let me just

1127
00:51:59,840 --> 00:52:01,790
ask a question again and again.

1128
00:52:01,790 --> 00:52:06,170
While i is less than 50, let me
go ahead and say, hello world.

1129
00:52:06,170 --> 00:52:09,300
So I can just print out, hello world.

1130
00:52:09,300 --> 00:52:12,260
But I'm not quite done sort
of building this logic.

1131
00:52:12,260 --> 00:52:14,330
I've initialized a variable to zero.

1132
00:52:14,330 --> 00:52:18,380
I'm going to, again and again, ask
the question, is i less than 50?

1133
00:52:18,380 --> 00:52:21,530
But for this to work out logically,
what other piece of logic

1134
00:52:21,530 --> 00:52:24,360
do I need to add to the code?

1135
00:52:24,360 --> 00:52:25,916
Yeah?

1136
00:52:25,916 --> 00:52:27,810
AUDIENCE: You have to
increment i by one.

1137
00:52:27,810 --> 00:52:29,530
DAVID MALAN: Yeah, I have
to increment i, right?

1138
00:52:29,530 --> 00:52:30,770
So even if you don't recall--

1139
00:52:30,770 --> 00:52:33,130
and that's fine-- the syntax
for doing that, you do

1140
00:52:33,130 --> 00:52:35,090
need a line of code like this.

1141
00:52:35,090 --> 00:52:38,710
So that, logically, you're going to do
the following-- set i equal to zero,

1142
00:52:38,710 --> 00:52:41,120
and then do the following
while i is less than 50.

1143
00:52:41,120 --> 00:52:42,430
Well, is i less than 50?

1144
00:52:42,430 --> 00:52:45,200
Obviously, because 0 is less than 50.

1145
00:52:45,200 --> 00:52:46,660
So you print out, hello world.

1146
00:52:46,660 --> 00:52:48,820
And then, as you propose,
we need to increment i.

1147
00:52:48,820 --> 00:52:51,290
So now i equals i plus 1.

1148
00:52:51,290 --> 00:52:53,980
So at this point in
the story, i equals 1.

1149
00:52:53,980 --> 00:52:57,430
And now the way the code works,
much like our pseudo code last week,

1150
00:52:57,430 --> 00:53:00,220
is you sort of implicitly
go back to this line.

1151
00:53:00,220 --> 00:53:04,010
Last week, in pseudocode, I
literally said, go back to line 3.

1152
00:53:04,010 --> 00:53:09,460
Here, it happens automatically by nature
of how C interprets these lines of code

1153
00:53:09,460 --> 00:53:10,720
in these curly braces.

1154
00:53:10,720 --> 00:53:12,980
And I can actually
simplify this as follows.

1155
00:53:12,980 --> 00:53:14,568
I can say i plus plus.

1156
00:53:14,568 --> 00:53:17,110
Now, it's not quite as pretty
as Scratch, where you just say,

1157
00:53:17,110 --> 00:53:18,760
repeat the following 50 times.

1158
00:53:18,760 --> 00:53:22,630
But using the principles of
last week now translated to C,

1159
00:53:22,630 --> 00:53:24,760
you can kind of wire
together your own logic that

1160
00:53:24,760 --> 00:53:27,610
does something any number of times.

1161
00:53:27,610 --> 00:53:30,430
And there's one other way to do
this, just so you've seen it here.

1162
00:53:30,430 --> 00:53:33,850
It turns out that a more common way to
do something a fixed number of times

1163
00:53:33,850 --> 00:53:36,430
is using a different
preposition-- the word for.

1164
00:53:36,430 --> 00:53:38,710
And a for loop looks like this.

1165
00:53:38,710 --> 00:53:43,180
A for loop does something, like print
out hello world, again and again,

1166
00:53:43,180 --> 00:53:44,740
but it's even more mechanical.

1167
00:53:44,740 --> 00:53:48,580
But it automates into one line
of code the exact same logic

1168
00:53:48,580 --> 00:53:50,020
we just implemented.

1169
00:53:50,020 --> 00:53:52,362
After the word for, you
can put parentheses.

1170
00:53:52,362 --> 00:53:54,070
And then inside of
those parentheses, you

1171
00:53:54,070 --> 00:53:56,740
can say something like, give
me a variable called counter

1172
00:53:56,740 --> 00:53:58,180
and initialize it to zero.

1173
00:53:58,180 --> 00:53:59,410
Or that's a little wordy.

1174
00:53:59,410 --> 00:54:00,760
Let's just use i.

1175
00:54:00,760 --> 00:54:04,540
So that is identical, logically,
to what we did a moment ago.

1176
00:54:04,540 --> 00:54:09,190
But the for loop actually takes
one, two, three inputs inside

1177
00:54:09,190 --> 00:54:10,000
of its parentheses.

1178
00:54:10,000 --> 00:54:12,520
It's a little funky in
terms of its syntax.

1179
00:54:12,520 --> 00:54:15,790
The second input to the for
loop is the Boolean expression

1180
00:54:15,790 --> 00:54:20,380
you want to ask again and again
and again, so is i less than 50?

1181
00:54:20,380 --> 00:54:22,900
And the last thing that
you can do in a for loop

1182
00:54:22,900 --> 00:54:27,410
is this third input, where you can do
your update of one or more variables.

1183
00:54:27,410 --> 00:54:32,830
So if I do i equals i plus 1 or,
more succinctly, i plus equals 1,

1184
00:54:32,830 --> 00:54:36,700
or even more so tersely,
i plus plus, I have now

1185
00:54:36,700 --> 00:54:40,210
whittled down to just four
lines of code what I previously

1186
00:54:40,210 --> 00:54:42,440
did in a few more lines of code.

1187
00:54:42,440 --> 00:54:43,660
These are both correct.

1188
00:54:43,660 --> 00:54:45,800
They both do exactly the same thing.

1189
00:54:45,800 --> 00:54:49,580
And even though the for loop is a little
non-obvious-- because this is step one,

1190
00:54:49,580 --> 00:54:52,090
this is step two, this
is step three, then

1191
00:54:52,090 --> 00:54:54,265
in increments-- it
achieves the same result.

1192
00:54:54,265 --> 00:54:56,890
And you'll play with this over
time in the next couple of weeks

1193
00:54:56,890 --> 00:54:58,510
when doing something again and again.

1194
00:54:58,510 --> 00:55:02,830
But it's just a more succinct
way of achieving that same goal.

1195
00:55:02,830 --> 00:55:06,940
Any questions, then, on while
loops or for loops here?

1196
00:55:06,940 --> 00:55:09,990


1197
00:55:09,990 --> 00:55:15,180
All right, so let's look at
one final set of definitions.

1198
00:55:15,180 --> 00:55:18,510
It turns out that in C, we
have a whole list of data types

1199
00:55:18,510 --> 00:55:20,210
besides just strings and besides ints.

1200
00:55:20,210 --> 00:55:22,260
And we'll see these and
use these over time.

1201
00:55:22,260 --> 00:55:26,320
You can have a bool, so to speak, which
is literally the value true or false.

1202
00:55:26,320 --> 00:55:29,620
And we use that implicitly earlier
when I just said while true.

1203
00:55:29,620 --> 00:55:34,140
You can have a char, or character, which
is a single character, not two or more

1204
00:55:34,140 --> 00:55:34,920
or a phrase.

1205
00:55:34,920 --> 00:55:39,390
It's just like the letter Y or N if
you're asking the question yes or no.

1206
00:55:39,390 --> 00:55:42,720
You can have an int, of course,
which is an integer, a string, which

1207
00:55:42,720 --> 00:55:44,940
is one or more characters
inside of double quotes.

1208
00:55:44,940 --> 00:55:47,670
So it's bigger than an
individual char, typically.

1209
00:55:47,670 --> 00:55:49,650
And then there's a
few other data types--

1210
00:55:49,650 --> 00:55:50,700
int and long.

1211
00:55:50,700 --> 00:55:52,890
So int is typically a certain size.

1212
00:55:52,890 --> 00:55:55,260
You can only count so high with an int.

1213
00:55:55,260 --> 00:55:58,110
Typically, you can count as
high as 4 billion with an int,

1214
00:55:58,110 --> 00:56:00,610
and that's not big enough
for certain applications.

1215
00:56:00,610 --> 00:56:03,330
Today's biggest companies like
Facebook and Microsoft and Google

1216
00:56:03,330 --> 00:56:06,240
have many more pieces
of data than 4 billion.

1217
00:56:06,240 --> 00:56:10,030
So there exist things called long,
which actually use more bits.

1218
00:56:10,030 --> 00:56:12,640
They're wider values, so
they can count even higher.

1219
00:56:12,640 --> 00:56:14,940
A float is a floating
point value, which is

1220
00:56:14,940 --> 00:56:18,390
a fancy way of saying a real number,
something that has a decimal point.

1221
00:56:18,390 --> 00:56:23,130
And a double is just a real number
that can have even more digits

1222
00:56:23,130 --> 00:56:24,790
after the decimal point.

1223
00:56:24,790 --> 00:56:26,370
So we'll see those before long.

1224
00:56:26,370 --> 00:56:28,950
Well, what other features does
the CS50 the library provide?

1225
00:56:28,950 --> 00:56:31,320
It gives you not only
the function get_string,

1226
00:56:31,320 --> 00:56:35,567
we'll see a few others like get_int or
get_float or get_double or get_char.

1227
00:56:35,567 --> 00:56:37,650
These are all functions
that will prompt the human

1228
00:56:37,650 --> 00:56:42,360
with the blinking prompt for certain
values that they might want to provide.

1229
00:56:42,360 --> 00:56:44,540
And then for placeholders,
let's round this out.

1230
00:56:44,540 --> 00:56:48,090
Printf, recall, had a placeholder
for percent s for a string.

1231
00:56:48,090 --> 00:56:50,580
Turns out there's a few
other placeholders, as well.

1232
00:56:50,580 --> 00:56:53,520
If you want to plug in an int, we're
going to start using percent i.

1233
00:56:53,520 --> 00:56:55,920
If you want to plug in a
float-- that is, a real number--

1234
00:56:55,920 --> 00:56:57,350
you're going to use percent f.

1235
00:56:57,350 --> 00:57:00,390
And there's a couple of
other format codes, as well.

1236
00:57:00,390 --> 00:57:02,430
But we've seen just
one of those thus far.

1237
00:57:02,430 --> 00:57:05,010
And then in terms of
arithmetic operations,

1238
00:57:05,010 --> 00:57:07,290
you can do a lot of
mathematics very simply.

1239
00:57:07,290 --> 00:57:09,540
And we'll do just a couple
of examples, literally just

1240
00:57:09,540 --> 00:57:13,320
by using the characters that you might
be inclined to type on the screen.

1241
00:57:13,320 --> 00:57:18,603
So, in short, suppose that we want to go
ahead and write one program of our own.

1242
00:57:18,603 --> 00:57:21,270
We can use any number of these
functions-- get_int and get_float

1243
00:57:21,270 --> 00:57:22,240
and get_more.

1244
00:57:22,240 --> 00:57:24,990
But before that, let's go ahead
and take a five-minute break here,

1245
00:57:24,990 --> 00:57:26,865
because that was quite
the fire hose, indeed.

1246
00:57:26,865 --> 00:57:30,570
Cookies await in the lobby outside,
and we'll resume in five minutes.

1247
00:57:30,570 --> 00:57:36,420
So we are back, and now we begin
focusing not just on comparisons

1248
00:57:36,420 --> 00:57:39,090
of C with Scratch, but
on actually writing

1249
00:57:39,090 --> 00:57:42,960
some code from Scratch but
in C. And the goal at hand

1250
00:57:42,960 --> 00:57:46,050
really is to begin to develop
the muscle memory via which

1251
00:57:46,050 --> 00:57:49,860
you can start with literally
empty files and start to fill it

1252
00:57:49,860 --> 00:57:54,090
with C implementations of your ideas.

1253
00:57:54,090 --> 00:57:57,660
So rest assured that all of the
examples we're about to do live

1254
00:57:57,660 --> 00:57:59,670
are already pre-baked
online, so you'll be

1255
00:57:59,670 --> 00:58:02,580
able to download all of these
examples from the course's website.

1256
00:58:02,580 --> 00:58:05,632
In Brian's super section will you be
able to explore them in more detail.

1257
00:58:05,632 --> 00:58:07,590
And later this week will
you have opportunities

1258
00:58:07,590 --> 00:58:11,020
hands-on to work on these same
types of programs, as well.

1259
00:58:11,020 --> 00:58:16,140
For now, the overarching goal is
exposure and concepts and the beginning

1260
00:58:16,140 --> 00:58:18,270
of developing that muscle memory.

1261
00:58:18,270 --> 00:58:21,947
So with that said, let me go ahead
and create a new file called int.c,

1262
00:58:21,947 --> 00:58:24,780
the purpose of which is going to
be to get an integer from the user,

1263
00:58:24,780 --> 00:58:28,530
much like a bit ago I got
a string from the user.

1264
00:58:28,530 --> 00:58:30,630
I'm going to go ahead
and, as before, I'm

1265
00:58:30,630 --> 00:58:32,410
going to include some familiar files.

1266
00:58:32,410 --> 00:58:35,012
So I'm going to go ahead and
include preemptively CS50.h

1267
00:58:35,012 --> 00:58:37,830
so that have I access to
strings and get_string

1268
00:58:37,830 --> 00:58:40,800
and get_int and get_float
and other features, as well.

1269
00:58:40,800 --> 00:58:43,890
I'm going to include stdio.h
so that I have access to printf

1270
00:58:43,890 --> 00:58:45,780
so I can actually see what we're doing.

1271
00:58:45,780 --> 00:58:48,600
Then I'm going to do this, which
again, for today's purposes

1272
00:58:48,600 --> 00:58:51,150
and for a couple of weeks,
is just kind of copy/paste.

1273
00:58:51,150 --> 00:58:54,090
This is the equivalent of
when green flag clicked,

1274
00:58:54,090 --> 00:58:57,240
but we'll explain, in a couple of
weeks, exactly why you're writing int

1275
00:58:57,240 --> 00:58:59,235
and why you're writing void.

1276
00:58:59,235 --> 00:59:01,110
In here, I'm going to
do something like this.

1277
00:59:01,110 --> 00:59:03,360
This time, I want to get
not a string but an int.

1278
00:59:03,360 --> 00:59:08,320
So let's do in age get
get_int, what's your age?

1279
00:59:08,320 --> 00:59:10,860
Now, to be fair, I can probably
type that pretty quickly,

1280
00:59:10,860 --> 00:59:13,650
because I have the muscle memory
already for programming in C.

1281
00:59:13,650 --> 00:59:16,150
But if we look at it real
methodically for a moment,

1282
00:59:16,150 --> 00:59:19,540
this is just another function,
get_int, from the CS50 library that's

1283
00:59:19,540 --> 00:59:20,800
going to get an integer.

1284
00:59:20,800 --> 00:59:22,550
This is the prompt
that the human is going

1285
00:59:22,550 --> 00:59:25,862
to see with their cursor moving to a
new line because of the backslash n.

1286
00:59:25,862 --> 00:59:27,570
And whatever they type
in is going to get

1287
00:59:27,570 --> 00:59:31,350
copied from right to left into a
variable called age, the type of which,

1288
00:59:31,350 --> 00:59:34,140
so to speak, is int, or integer.

1289
00:59:34,140 --> 00:59:37,717
Now let me go ahead and compute, like,
how many days old this person is.

1290
00:59:37,717 --> 00:59:40,050
So if I want to do that, I
could do something like this.

1291
00:59:40,050 --> 00:59:41,490
Well, give me an integer.

1292
00:59:41,490 --> 00:59:42,780
Call it days.

1293
00:59:42,780 --> 00:59:45,602
And then just do age times 365.

1294
00:59:45,602 --> 00:59:47,310
I proposed a bit ago
that there's a bunch

1295
00:59:47,310 --> 00:59:49,830
of arithmetic operators
like plus and minus

1296
00:59:49,830 --> 00:59:53,850
and multiplication and subtraction
and even the remainder operator.

1297
00:59:53,850 --> 00:59:58,680
So this line, 7, just
says multiply age by 365.

1298
00:59:58,680 --> 01:00:02,800
Copy that value, from right to left,
into a new variable called days.

1299
01:00:02,800 --> 01:00:04,800
And now I can go ahead
and print this if I want.

1300
01:00:04,800 --> 01:00:09,090
Выведем что-нибудь такое: printf,
"ваш возраст — не менее", символ %--

1301
01:00:09,090 --> 01:00:13,620
тут не s, потому что это не строка,
а i — для целого числа--

1302
01:00:13,620 --> 01:00:15,900
дней, обратная косая черта, n.

1303
01:00:15,900 --> 01:00:18,190
Это ещё не всё, потому что
у нас тут заполнитель.

1304
01:00:18,190 --> 01:00:23,580
Что ещё мне нужно поместить в скобки
на восьмой строке?

1305
01:00:23,580 --> 01:00:27,990
Именно. Поэтому: запятая, days, если мне
нужно использовать именно это значение.

1306
01:00:27,990 --> 01:00:29,377
И я ещё кое-что пропустил.

1307
01:00:29,377 --> 01:00:30,210
ЗАЛ: Точку с запятой.

1308
01:00:30,210 --> 01:00:32,127
DAVID MALAN: Точку с запятой
в конце строки.

1309
01:00:32,127 --> 01:00:33,503
Надеюсь, теперь всё верно.

1310
01:00:33,503 --> 01:00:35,670
Но скорее всего, поначалу
в своих программах

1311
01:00:35,670 --> 01:00:37,150
вы будете видеть море ошибок.

1312
01:00:37,150 --> 01:00:41,040
Так, make int — самый быстрый
способ компиляции этого кода.

1313
01:00:41,040 --> 01:00:41,850
Жмём Enter.

1314
01:00:41,850 --> 01:00:43,860
Отлично, длинная белая надпись —
это хорошо.

1315
01:00:43,860 --> 01:00:47,490
Пока в выводе отсутствуют красный,
жёлтый или другие цвета, означающие

1316
01:00:47,490 --> 01:00:49,590
предупреждения или ошибки, всё в порядке.

1317
01:00:49,590 --> 01:00:53,910
Я очищу экран и просто запущу
эту программу: ./int.

1318
01:00:53,910 --> 01:00:56,150
Предположим, ваш возраст — 50.

1319
01:00:56,150 --> 01:01:00,422
Ну, в днях это будет как минимум 18,250.

1320
01:01:00,422 --> 01:01:03,630
Но позвольте мне использовать эту возможность
для создания не только правильного, каким,

1321
01:01:03,630 --> 01:01:06,690
я полагаю, этот код и является,
но ещё и хорошего кода.

1322
01:01:06,690 --> 01:01:11,580
Вполне нормально хранить значение
возраста в переменной age.

1323
01:01:11,580 --> 01:01:13,950
И так же нормально иметь
вторую переменную с именем

1324
01:01:13,950 --> 01:01:19,300
days, где хранится значение,
равное age, умноженному на 365.

1325
01:01:19,300 --> 01:01:22,530
Но строго говоря, мне не нужна
эта дополнительная строка кода.

1326
01:01:22,530 --> 01:01:26,520
Я мог бы написать age * 365 прямо здесь.

1327
01:01:26,520 --> 01:01:27,660
Этим Си и хорош.

1328
01:01:27,660 --> 01:01:32,370
Как и в Scratch, здесь можно составлять
большие идеи из нескольких маленьких

1329
01:01:32,370 --> 01:01:33,090
кусочков.

1330
01:01:33,090 --> 01:01:35,550
А если уж совсем сходить с ума,

1331
01:01:35,550 --> 01:01:38,040
заметьте, что я могу выделить
весь этот вызов

1332
01:01:38,040 --> 01:01:42,000
функции, так сказать, полностью
избавиться от переменной age,

1333
01:01:42,000 --> 01:01:49,330
и просто вставить его сюда,
умножив на 365.

1334
01:01:49,330 --> 01:01:53,190
Но таким образом мы начинаем
перегибать палку.

1335
01:01:53,190 --> 01:01:55,342
Да, всё написанное верно, потому что мне,
строго говоря,

1336
01:01:55,342 --> 01:01:56,550
не нужна переменная, так?

1337
01:01:56,550 --> 01:01:58,020
Я могу передавать-- как мы видели
на прошлой неделе--

1338
01:01:58,020 --> 01:02:00,870
выход одной функции на вход другой,

1339
01:02:00,870 --> 01:02:02,540
просто вкладывая их друг в друга.

1340
01:02:02,540 --> 01:02:05,040
Но если подумать, в данный момент
эта строка кода

1341
01:02:05,040 --> 01:02:08,080
стала настолько длинной, что
её очень трудно читать.

1342
01:02:08,080 --> 01:02:10,830
И вот это как раз пример того,
когда из соображений читаемости

1343
01:02:10,830 --> 01:02:13,210
лучше вернуть предыдущий вариант,

1344
01:02:13,210 --> 01:02:16,950
потому что он позволяет читать код
скорее сверху вниз, чем слева направо.

1345
01:02:16,950 --> 01:02:18,900
Это проектное решение.

1346
01:02:18,900 --> 01:02:21,000
Вы можете быть согласны или несогласны,

1347
01:02:21,000 --> 01:02:24,420
в том числе и с вашим наставником.

1348
01:02:24,420 --> 01:02:28,770
Выбор здесь стоит между написанем
хорошего и плохого кода,

1349
01:02:28,770 --> 01:02:30,300
ну или хорошего и более хорошего кода.

1350
01:02:30,300 --> 01:02:33,000
Почти как в сочинении по английскому
или любому другому языку:

1351
01:02:33,000 --> 01:02:36,030
работа одного человека может
понравиться вам больше,

1352
01:02:36,030 --> 01:02:36,730
чем работа другого.

1353
01:02:36,730 --> 01:02:40,140
Так что со временем мы начнём
ценить эти нюансы.

1354
01:02:40,140 --> 01:02:41,310
А что насчёт действительных чисел?

1355
01:02:41,310 --> 01:02:45,758
Давайте я быстренько напишу другую
программу под названием float.c.

1356
01:02:45,758 --> 01:02:47,550
И в ней мы будем использовать дробные

1357
01:02:47,550 --> 01:02:50,800
значения, соответствующие
действительным числам.

1358
01:02:50,800 --> 01:02:54,150
Так, теперь заголовочные файлы:
include CS50.h, include stdio.h.

1359
01:02:54,150 --> 01:02:57,840


1360
01:02:57,840 --> 01:03:02,003
Затем int main void и фигурные скобки.

1361
01:03:02,003 --> 01:03:02,920
А теперь сделаем вот что.

1362
01:03:02,920 --> 01:03:04,680
Давайте посчитаем стоимость чего-нибудь.

1363
01:03:04,680 --> 01:03:10,290
Пишем: int price, равно, get float,
какова цена, например.

1364
01:03:10,290 --> 01:03:11,450
Точка с запятой.

1365
01:03:11,450 --> 01:03:13,660
А теперь применим кое-какие вычисления.

1366
01:03:13,660 --> 01:03:18,120
Напишем, например: "общая сумма составляет".

1367
01:03:18,120 --> 01:03:21,330
И далее посчитаем, например, общую
стоимость с учётом налогов.

1368
01:03:21,330 --> 01:03:24,353
В штате Массачусетс налог с продаж
составляет 6.25%.

1369
01:03:24,353 --> 01:03:26,520
Напишем небольшую программу,
учитывающую его.

1370
01:03:26,520 --> 01:03:30,540
Общая сумма составляет-- не %s,
потому что это не строка.

1371
01:03:30,540 --> 01:03:33,190
И не %i, потому что это не целое число.

1372
01:03:33,190 --> 01:03:37,990
Для действительного числа это будет %f.

1373
01:03:37,990 --> 01:03:39,350
Кстати, я тут облажался.

1374
01:03:39,350 --> 01:03:41,860
Случайно сделал эту ошибку.

1375
01:03:41,860 --> 01:03:44,997
Я не хочу хранить цену в переменной
типа int, если вычисляю её как float.

1376
01:03:44,997 --> 01:03:47,080
Если я получаю действительное число
с десятичной точкой,

1377
01:03:47,080 --> 01:03:49,310
то мне и хранить его следует
как действительное число.

1378
01:03:49,310 --> 01:03:52,480
Опять же, каждому формату соответствует
свой заполнитель

1379
01:03:52,480 --> 01:03:53,787
в зависимости от контекста.

1380
01:03:53,787 --> 01:03:55,120
Теперь я сделаю следующее.

1381
01:03:55,120 --> 01:03:56,995
Если я хочу подставить переменную
price, мне нужно

1382
01:03:56,995 --> 01:04:05,230
написать price * 1.0625, что соответствует
добавлению 106.25%--

1383
01:04:05,230 --> 01:04:08,770
или, иначе говоря, умножению цены
на 106.25%,

1384
01:04:08,770 --> 01:04:11,203
и теперь мы видим общую сумму
с налогом.

1385
01:04:11,203 --> 01:04:13,120
Хорошо, давайте скомпилируем
этот код.

1386
01:04:13,120 --> 01:04:14,980
Make float, Enter.

1387
01:04:14,980 --> 01:04:17,320
Сообщений об ошибках нет,
уже неплохо.

1388
01:04:17,320 --> 01:04:18,730
./float.

1389
01:04:18,730 --> 01:04:19,990
"Какова цена"?

1390
01:04:19,990 --> 01:04:23,170
Ну, как насчёт $100?

1391
01:04:23,170 --> 01:04:25,180
Кажется, результат чересчур точный.

1392
01:04:25,180 --> 01:04:29,932
Общая сумма составляет $106.250000.

1393
01:04:29,932 --> 01:04:33,130
Это всё потому, что компьютер,
как мы помним,

1394
01:04:33,130 --> 01:04:35,440
использует определённое количество бит
для хранения значений.

1395
01:04:35,440 --> 01:04:40,120
И он, оказывается, способен
показывать вот столько знаков

1396
01:04:40,120 --> 01:04:41,140
после десятичной точки.

1397
01:04:41,140 --> 01:04:42,830
Но что если нам столько не нужно?

1398
01:04:42,830 --> 01:04:46,660
Оказывается, для этого существуют
кое-какие хитрости.

1399
01:04:46,660 --> 01:04:48,910
Instead of doing percent
f, I can actually

1400
01:04:48,910 --> 01:04:52,360
сделать процент точка 2f, которую,
опять же, вы могли знать только

1401
01:04:52,360 --> 01:04:55,570
если встречали раньше,
или видели ее в книжке или справке.

1402
01:04:55,570 --> 01:04:59,150
Это покажет мне две цифры после
точки.

1403
01:04:59,150 --> 01:05:02,560
Так что, если я рекомпилирую код
и сделаю ./float,

1404
01:05:02,560 --> 01:05:07,720
заметьте, если цена 100 долларов, теперь
моя сумма немного более читаема--

1405
01:05:07,720 --> 01:05:09,790
106.25.

1406
01:05:09,790 --> 01:05:11,953
Если кратко, это f в printf
So in short, this is the f in printf.

1407
01:05:11,953 --> 01:05:13,870
Так же как вы можете
что то напечатать на экране,

1408
01:05:13,870 --> 01:05:19,380
вы можете форматировать это,
сказав printf сколько символов после точки
показать.

1409
01:05:19,380 --> 01:05:20,810
Давайте я попробую кое что еще.

1410
01:05:20,810 --> 01:05:23,470
Давайте я скопирую начало
этого кода,

1411
01:05:23,470 --> 01:05:24,940
просто чтобы ускориться.

1412
01:05:24,940 --> 01:05:27,190
Чтобы я смог сделать программу
которая называется parity.c.

1413
01:05:27,190 --> 01:05:30,343
"Parity" это прикольный способ
сказать четное ли число.

1414
01:05:30,343 --> 01:05:32,260
И я просто скопировал и
вставил

1415
01:05:32,260 --> 01:05:35,708
подготовительный код, но не
главную функцию.

1416
01:05:35,708 --> 01:05:38,500
Но давайте спросим число у пользователя.

1417
01:05:38,500 --> 01:05:39,540
И назовем его n.

1418
01:05:39,540 --> 01:05:41,620
И мы используем get_int чтобы получить значение.

1419
01:05:41,620 --> 01:05:44,620
И мы просто спросим человека,
каково значение n?

1420
01:05:44,620 --> 01:05:49,540
И я просто скажу n двоеточие пробел
чтобы запросить какое нибудь число.

1421
01:05:49,540 --> 01:05:51,460
Потом я задам вопрос.

1422
01:05:51,460 --> 01:05:55,570
И я хочу написать "even" если
число четное или "odd"
I want to ultimately print out
even if the number is even or odd

1423
01:05:55,570 --> 01:05:56,830
если нечетное.

1424
01:05:56,830 --> 01:06:02,650
Вы можете представить как это сделать
очень утомительным образом, например
если n = 1,

1425
01:06:02,650 --> 01:06:06,130
я напишу "odd".

1426
01:06:06,130 --> 01:06:12,340
И если n = 2, я могу написать "even".

1427
01:06:12,340 --> 01:06:16,190
И потом если я хочу поддерживать
номер три, тогде если n--

1428
01:06:16,190 --> 01:06:17,440
это довольно глупо, не так ли?

1429
01:06:17,440 --> 01:06:18,880
Я могу делать это вечно.

1430
01:06:18,880 --> 01:06:21,632
Но по крайней мере
мы видим паттерн, верно?

1431
01:06:21,632 --> 01:06:24,340
Один, потом три, потом пять,
конечно, будут нечетными,

1432
01:06:24,340 --> 01:06:26,990
а два, четыре и шесть будут
четными, и так далее.

1433
01:06:26,990 --> 01:06:29,240
Выглядит так, как будто можно
это вычислить математически.

1434
01:06:29,240 --> 01:06:30,970
И есть очень распространенный
способ это сделать--

1435
01:06:30,970 --> 01:06:32,500
мы можем щас его воспроизвести.

1436
01:06:32,500 --> 01:06:39,070
Если n делится на 2, и остаток,
например, 0,

1437
01:06:39,070 --> 01:06:42,850
мы сделаем вывод что номер
четный.

1438
01:06:42,850 --> 01:06:45,430
Вот этот значок процента -
это новая конструкция.

1439
01:06:45,430 --> 01:06:46,090
Это не плюс.

1440
01:06:46,090 --> 01:06:47,440
Это не минус.

1441
01:06:47,440 --> 01:06:49,240
Не умножение и не деление.

1442
01:06:49,240 --> 01:06:53,150
Это операция остатка от деления.

1443
01:06:53,150 --> 01:06:59,470
И это значит поделить на 2, и
если у ответа остаток 0,

1444
01:06:59,470 --> 01:07:02,670
вы можете заключить, по определению
четности, что номер четный.

1445
01:07:02,670 --> 01:07:04,100
И я выведу это на экран.

1446
01:07:04,100 --> 01:07:08,320
В противном случае-- Я могу сделать else if
n процент 2 равно равно 1

1447
01:07:08,320 --> 01:07:11,380
а значит имеет остаток 1,
и сказать нечетное.

1448
01:07:11,380 --> 01:07:15,405
Но как вы заметили раньше,
это не нужно.

1449
01:07:15,405 --> 01:07:18,280
Что я могу сделать вмето этого -
структурировать программу чуть лучше,

1450
01:07:18,280 --> 01:07:19,600
более эффективной?

1451
01:07:19,600 --> 01:07:20,248
Да?

1452
01:07:20,248 --> 01:07:22,440
АУДИТОРИЯ: Ты можешь просто
использовать else и все будет отлично.

1453
01:07:22,440 --> 01:07:22,770
DAVID MALAN: Да.

1454
01:07:22,770 --> 01:07:24,687
Поэтому если мы говорим о
целых числах, я могу

1455
01:07:24,687 --> 01:07:28,360
заключить, что, если это не четное,
это нечетное, по определению.

1456
01:07:28,360 --> 01:07:30,510
И здесь, мы можем
просто сделать четные и нечетные.

1457
01:07:30,510 --> 01:07:33,510
Так что эта программа, будет
выглядеть вот так при запуске.

1458
01:07:33,510 --> 01:07:35,400
Make parity.

1459
01:07:35,400 --> 01:07:36,630
Скомпилировалось нормально.

1460
01:07:36,630 --> 01:07:38,880
И я запускаю ее с помощью ./parity.

1461
01:07:38,880 --> 01:07:40,290
Вводим 50.

1462
01:07:40,290 --> 01:07:40,950
Четное.

1463
01:07:40,950 --> 01:07:42,510
Вводим 49.

1464
01:07:42,510 --> 01:07:43,380
Нечетное.

1465
01:07:43,380 --> 01:07:44,850
Доказательство на примере.

1466
01:07:44,850 --> 01:07:48,060
Не то чтобы железно доказано, но я могу
предположить что будет работать верно,

1467
01:07:48,060 --> 01:07:49,480
основываясь на этих двух примерах.

1468
01:07:49,480 --> 01:07:49,980
Верно?

1469
01:07:49,980 --> 01:07:52,938
АУДИТОРИЯ: [НЕРАЗБОРЧИВО] пользователь
не понял наш комментарий что ответ

1470
01:07:52,938 --> 01:07:54,332
float а не целое число?

1471
01:07:54,332 --> 01:07:55,790
DAVID MALAN: Извините, еще раз?

1472
01:07:55,790 --> 01:07:58,207
АУДИТОРИЯ: Что если пользователь
не понимает, что ему надо сделать?

1473
01:07:58,207 --> 01:08:02,783
Например просто введу что
нибудь, 1 и 1/2 [НЕРАЗБОРЧИВО].

1474
01:08:02,783 --> 01:08:04,200
DAVID MALAN: Очень хороший вопрос.

1475
01:08:04,200 --> 01:08:06,950
Одна из причин почему мы показываем
в первые недели курса

1476
01:08:06,950 --> 01:08:10,700
функции в библиотеке CS50 типа
get_string и get_int и get_float

1477
01:08:10,700 --> 01:08:14,960
потому что они заставляют пользователя
действовать как вы этого ожиадете и ваше приложение

1478
01:08:14,960 --> 01:08:17,149
не падает от неправильно введенных данных.

1479
01:08:17,149 --> 01:08:20,180
Так что, предположим пользователь
немного тормозит и вводит,

1480
01:08:20,180 --> 01:08:22,939
мой номер это 1.5.

1481
01:08:22,939 --> 01:08:27,854
Get_int задаст им тот же вопрос
еще раз и еще раз и еще раз

1482
01:08:27,854 --> 01:08:28,729
пока до них не дойдет.

1483
01:08:28,729 --> 01:08:31,819
Если вы введете "apple", он
спросит вас снова.

1484
01:08:31,819 --> 01:08:34,880
И когда вы введете целое число,
только тогда оно заработает.

1485
01:08:34,880 --> 01:08:37,540
Это одна из вещей которые идут
с бибилотекой CS50,

1486
01:08:37,540 --> 01:08:39,410
чтобы мы могли сосредоточиться
на идеях, а не

1487
01:08:39,410 --> 01:08:44,270
на проверках на ошибки, или подозрительных
действиях пользователя.

1488
01:08:44,270 --> 01:08:46,670
Окей, что еще
мы можем сделать, с

1489
01:08:46,670 --> 01:08:49,279
возможностью выражать условия?

1490
01:08:49,279 --> 01:08:52,010
Так, давайте я открою исходники,
которые принес с собой.

1491
01:08:52,010 --> 01:08:54,109
Вместо того чтобы печатать
все с нуля,

1492
01:08:54,109 --> 01:08:56,618
я просто открою conditions1.c.

1493
01:08:56,618 --> 01:08:58,660
Это приложение которое
уже было написано.

1494
01:08:58,660 --> 01:09:00,920
И видите, у нас есть
какие другие строчки там,

1495
01:09:00,920 --> 01:09:03,643
эти серые линии,
которые начинаются со слеш слеш.

1496
01:09:03,643 --> 01:09:05,810
Вы могли не заметить, но в Scratch,
у вас была штука,

1497
01:09:05,810 --> 01:09:06,979
которая называлась "комментарии".

1498
01:09:06,979 --> 01:09:09,050
Они как будто маленькие липкие
бумажки которые вы можете добавить

1499
01:09:09,050 --> 01:09:10,550
и не делают ничего функционально.

1500
01:09:10,550 --> 01:09:13,825
It's just like notes to self or notes
to your friend or notes to your TF.

1501
01:09:13,825 --> 01:09:15,950
That's what a comment is
in a programming language.

1502
01:09:15,950 --> 01:09:19,310
So anything starting with a
slash slash is a note to self.

1503
01:09:19,310 --> 01:09:21,873
And it's a reminder to me
what this line of code does.

1504
01:09:21,873 --> 01:09:24,040
It's a reminder to your
colleagues in the real world

1505
01:09:24,040 --> 01:09:27,380
or your TF in a class to explain
to them what this line of code

1506
01:09:27,380 --> 01:09:30,520
is supposed to be doing,
even if maybe you have a bug

1507
01:09:30,520 --> 01:09:32,090
and it's not actually doing that.

1508
01:09:32,090 --> 01:09:35,840
So I've begun, in these pre-created
examples, to comment my code,

1509
01:09:35,840 --> 01:09:37,580
but the lines are essentially the same.

1510
01:09:37,580 --> 01:09:40,250
Go ahead and give me
access to the CS50 library.

1511
01:09:40,250 --> 01:09:43,010
And a library, again,
is just a file of code

1512
01:09:43,010 --> 01:09:45,080
that someone else
wrote that we're using.

1513
01:09:45,080 --> 01:09:47,960
And give me access to the standard
I/O library, which contains

1514
01:09:47,960 --> 01:09:50,430
printf and some other things, as well.

1515
01:09:50,430 --> 01:09:54,170
Notice here, I have x
equals get_int in order

1516
01:09:54,170 --> 01:09:56,390
to get one integer
from the user called x.

1517
01:09:56,390 --> 01:09:59,840
Now I'm going to ask them for a
second integer by just calling it y

1518
01:09:59,840 --> 01:10:01,400
and calling get_int again.

1519
01:10:01,400 --> 01:10:03,840
And now I can do things
like compare these values.

1520
01:10:03,840 --> 01:10:07,790
So this is now a complete version
of the Scratch-like program

1521
01:10:07,790 --> 01:10:11,450
I pulled up before that allows
us to conclude is x less than y,

1522
01:10:11,450 --> 01:10:15,290
greater than y, or, by
default, equal to y.

1523
01:10:15,290 --> 01:10:19,080
So the only difference is we saw these
lines of code on the screen before.

1524
01:10:19,080 --> 01:10:22,340
Now we see, in context, that,
oh, for those lines to work,

1525
01:10:22,340 --> 01:10:25,640
we need to get the
integers from the user.

1526
01:10:25,640 --> 01:10:28,520
And we need to have the equivalent
of when green flag clicked,

1527
01:10:28,520 --> 01:10:31,115
and we need the equivalent of
these includes so that it's

1528
01:10:31,115 --> 01:10:33,575
a complete self-contained program.

1529
01:10:33,575 --> 01:10:35,450
And just to be clear,
even though I made this

1530
01:10:35,450 --> 01:10:38,710
in advance, if I wanted to run
this program, how could I run it?

1531
01:10:38,710 --> 01:10:41,770
Call conditions.c.

1532
01:10:41,770 --> 01:10:45,030
Yeah, so make conditions first.

1533
01:10:45,030 --> 01:10:45,530
Sorry.

1534
01:10:45,530 --> 01:10:48,140
Oh, this is actually a teachable moment.

1535
01:10:48,140 --> 01:10:49,670
Why did this not work?

1536
01:10:49,670 --> 01:10:54,020
So no rule to make target conditions
stop, which is a little emphatic.

1537
01:10:54,020 --> 01:10:55,130
But what does that mean?

1538
01:10:55,130 --> 01:10:58,700
Well, in advance today, what I did
was I downloaded into my sandbox

1539
01:10:58,700 --> 01:11:02,630
a folder called src1, S-R-C meaning
"source" in programmer speak.

1540
01:11:02,630 --> 01:11:06,140
And I just downloaded this
into the sandbox for me.

1541
01:11:06,140 --> 01:11:08,540
Because in that folder
are all of the examples

1542
01:11:08,540 --> 01:11:12,050
not only that I wrote in live, but also
some others that I brought with me.

1543
01:11:12,050 --> 01:11:15,920
Unfortunately, all of those files
are in a folder called src1.

1544
01:11:15,920 --> 01:11:18,920
Now, on your Mac or PC, if you want
to open a folder, you do what I did.

1545
01:11:18,920 --> 01:11:22,100
You double-double the icon,
and boom, the folder is open.

1546
01:11:22,100 --> 01:11:25,880
But in a terminal window, a text-based
environment, you can't do that.

1547
01:11:25,880 --> 01:11:29,840
If I type ls, we'll see all of the
files that I've created today--

1548
01:11:29,840 --> 01:11:32,120
float and hello and int.

1549
01:11:32,120 --> 01:11:34,520
But notice over here, there's a folder.

1550
01:11:34,520 --> 01:11:36,145
And that's what the trailing slash is.

1551
01:11:36,145 --> 01:11:38,270
That's a forward slash that
just means, hey, human,

1552
01:11:38,270 --> 01:11:40,250
this is a folder, just so it's obvious.

1553
01:11:40,250 --> 01:11:44,150
Just like the asterisk means here's
a machine code that you can run.

1554
01:11:44,150 --> 01:11:47,270
I need to change into that
directory, but I can't double-click.

1555
01:11:47,270 --> 01:11:49,700
Nothing's going to happen if
I double-click on this text.

1556
01:11:49,700 --> 01:11:53,650
But I can type cd space src1.

1557
01:11:53,650 --> 01:11:55,760
cd means change directory.

1558
01:11:55,760 --> 01:11:57,200
And now I hit Enter.

1559
01:11:57,200 --> 01:11:59,990
And now if I hit ls, notice
I see even more files,

1560
01:11:59,990 --> 01:12:03,110
because these are all of the
files from the course's website

1561
01:12:03,110 --> 01:12:05,180
that I brought with me today.

1562
01:12:05,180 --> 01:12:08,037
And if you type a
command like this, pwd,

1563
01:12:08,037 --> 01:12:10,370
this will reveal even more
information about the system,

1564
01:12:10,370 --> 01:12:12,050
but more on this in the weeks to come.

1565
01:12:12,050 --> 01:12:16,160
You're actually inside a src1 folder
that's inside of a sandbox folder

1566
01:12:16,160 --> 01:12:17,840
that's inside of a root folder.

1567
01:12:17,840 --> 01:12:21,140
Now, odds are, at some point, you'll
get confused as to where you are.

1568
01:12:21,140 --> 01:12:23,150
When in doubt, just type cd.

1569
01:12:23,150 --> 01:12:25,950
That will whisk you away to the
default folder where you began,

1570
01:12:25,950 --> 01:12:28,430
no matter where you found yourself to.

1571
01:12:28,430 --> 01:12:30,470
Type ls, and you're
back at the beginning.

1572
01:12:30,470 --> 01:12:32,570
So when in doubt, just
type cd and Enter,

1573
01:12:32,570 --> 01:12:34,430
and you'll be back at the beginning.

1574
01:12:34,430 --> 01:12:37,610
Well, let me go ahead and open up
this program, but run this one first.

1575
01:12:37,610 --> 01:12:40,190
I'm going to go into a
program called agree.c.

1576
01:12:40,190 --> 01:12:44,520
I'm going to hide the code
for a moment and make agree.

1577
01:12:44,520 --> 01:12:47,360
I did it again, cd src1, Enter.

1578
01:12:47,360 --> 01:12:49,800
Now I can do make agree.

1579
01:12:49,800 --> 01:12:51,500
It seems to have compiled the program.

1580
01:12:51,500 --> 01:12:55,700
And if I do ./agree, this program
seems to be asking me a question--

1581
01:12:55,700 --> 01:12:56,523
do you agree?

1582
01:12:56,523 --> 01:12:58,940
Now, it's not obvious from the
program what I should type,

1583
01:12:58,940 --> 01:13:01,220
but my gut tells me, sure, yes.

1584
01:13:01,220 --> 01:13:04,370
So I'm going to go ahead and
type y for yes and Enter.

1585
01:13:04,370 --> 01:13:06,050
And it seems to know that I've agreed.

1586
01:13:06,050 --> 01:13:07,490
If I rerun it again--

1587
01:13:07,490 --> 01:13:11,900
./agree-- and type n
this time, not agreed.

1588
01:13:11,900 --> 01:13:12,650
But you know what?

1589
01:13:12,650 --> 01:13:13,942
It's actually better than that.

1590
01:13:13,942 --> 01:13:18,650
If I do ./agree and maybe do a capital
Y, Enter, that also seems to work.

1591
01:13:18,650 --> 01:13:20,130
So how is this happening?

1592
01:13:20,130 --> 01:13:21,770
Well, let me look at the code here.

1593
01:13:21,770 --> 01:13:25,190
The top of the file is almost
identical to everything thus far.

1594
01:13:25,190 --> 01:13:27,650
Include those two files, int main void.

1595
01:13:27,650 --> 01:13:30,320
But now I'm using get_char,
and I'm storing my answer

1596
01:13:30,320 --> 01:13:33,710
in a variable called c, but I
could store it in anything I want.

1597
01:13:33,710 --> 01:13:36,350
And now notice the slightly new syntax.

1598
01:13:36,350 --> 01:13:41,300
What's clearly new about
what I'm doing here?

1599
01:13:41,300 --> 01:13:43,910
What symbols jump out?

1600
01:13:43,910 --> 01:13:45,200
Yeah, the vertical bar.

1601
01:13:45,200 --> 01:13:48,020
So this is a way of saying a logical or.

1602
01:13:48,020 --> 01:13:50,630
So in Python and a few other
languages these days, you

1603
01:13:50,630 --> 01:13:52,280
might literally write the word "or."

1604
01:13:52,280 --> 01:13:57,500
That doesn't work in C. If you want
to ask this question or this question

1605
01:13:57,500 --> 01:14:00,740
and just take either
answer as a valid answer,

1606
01:14:00,740 --> 01:14:03,020
you just use two vertical
bars, which are typically

1607
01:14:03,020 --> 01:14:05,720
above your Enter key on an
American keyboard, at least.

1608
01:14:05,720 --> 01:14:07,760
So two vertical bars means or.

1609
01:14:07,760 --> 01:14:10,640
Two ampersands, it turns out, means and.

1610
01:14:10,640 --> 01:14:13,940
But this is just a way of asking
two questions in the same breath

1611
01:14:13,940 --> 01:14:16,800
and accepting either
answer as potentially true.

1612
01:14:16,800 --> 01:14:21,650
So if c is capital Y or c is lowercase
y, assume that the human has agreed.

1613
01:14:21,650 --> 01:14:26,090
Else, if c equals capital N or lowercase
n, assume that they've not agreed.

1614
01:14:26,090 --> 01:14:28,970
And suppose I type in some
other letter all together,

1615
01:14:28,970 --> 01:14:32,220
what's the program going to do?

1616
01:14:32,220 --> 01:14:32,720
Say again?

1617
01:14:32,720 --> 01:14:33,740
AUDIENCE: Ask you again.

1618
01:14:33,740 --> 01:14:35,000
DAVID MALAN: It's not
going to ask me again,

1619
01:14:35,000 --> 01:14:36,950
because there's no loop here, right?

1620
01:14:36,950 --> 01:14:41,360
There's no evidence
of while or for loop.

1621
01:14:41,360 --> 01:14:46,190
And get_char is literally going to get a
char, but it doesn't specify what char.

1622
01:14:46,190 --> 01:14:50,900
What happens if I don't type
y or n, capital or lowercase?

1623
01:14:50,900 --> 01:14:52,103
It seems nothing.

1624
01:14:52,103 --> 01:14:54,020
Just nothing's going to
happen, and that's OK.

1625
01:14:54,020 --> 01:14:56,210
Your program doesn't
have to print something.

1626
01:14:56,210 --> 01:15:01,060
And indeed, if I run
this again and ./agree x.

1627
01:15:01,060 --> 01:15:02,130
It doesn't do anything.

1628
01:15:02,130 --> 01:15:03,860
So I've neither agreed nor disagreed.

1629
01:15:03,860 --> 01:15:07,910
However, you could imagine writing
a loop that somehow forces the human

1630
01:15:07,910 --> 01:15:10,117
to cooperate in some way or another.

1631
01:15:10,117 --> 01:15:12,200
All right, let's do a
different example, this time

1632
01:15:12,200 --> 01:15:15,800
based on an idea from last
time-- that of abstraction.

1633
01:15:15,800 --> 01:15:18,980
Recall that in Scratch, there
was no puzzle piece for coughing,

1634
01:15:18,980 --> 01:15:21,620
to make the cat [COUGHS] on the screen.

1635
01:15:21,620 --> 01:15:25,070
And so we implemented this, really,
with our own custom puzzle piece,

1636
01:15:25,070 --> 01:15:25,850
ultimately.

1637
01:15:25,850 --> 01:15:30,080
So let me create a program
that's called cough0.c.

1638
01:15:30,080 --> 01:15:33,140
That's a generous definition
of inactivity, but OK.

1639
01:15:33,140 --> 01:15:35,960
Let me reload the screen.

1640
01:15:35,960 --> 01:15:38,420
When in doubt in CS50,
as in life, reload.

1641
01:15:38,420 --> 01:15:39,920
That will probably fix.

1642
01:15:39,920 --> 01:15:43,248
Unfortunately, with programming and
the internet, that sometimes happens.

1643
01:15:43,248 --> 01:15:45,290
So in a moment, what I'm
going to go ahead and do

1644
01:15:45,290 --> 01:15:49,730
is translate that idea from Scratch of
implementing the notion of coughing.

1645
01:15:49,730 --> 01:15:54,060
But instead of the say block, I'm going
to use the printf block, or the printf

1646
01:15:54,060 --> 01:15:54,990
function.

1647
01:15:54,990 --> 01:15:58,700
And then I'm going to go ahead and
design this version of code slightly

1648
01:15:58,700 --> 01:16:01,920
better and slightly better each time.

1649
01:16:01,920 --> 01:16:07,010
So I'm going to go ahead
and open up a file cough0.c.

1650
01:16:07,010 --> 01:16:11,900
And I'm going to go ahead and
include, let's say, stdio.h.

1651
01:16:11,900 --> 01:16:16,180
I'm going to go ahead and do int main
void, which again, is just our boiler

1652
01:16:16,180 --> 01:16:18,080
plate or copy/paste for today.

1653
01:16:18,080 --> 01:16:21,080
I'm going to go ahead, then,
and say printf, quote unquote,

1654
01:16:21,080 --> 01:16:22,580
cough with a new line.

1655
01:16:22,580 --> 01:16:25,050
And recall, in Scratch I wanted
this to happen three times,

1656
01:16:25,050 --> 01:16:27,300
so I'm going to do it like
this-- cough, cough, cough.

1657
01:16:27,300 --> 01:16:31,520
All right, I'm going to give myself
a terminal window here at the bottom

1658
01:16:31,520 --> 01:16:35,330
so that I can now go ahead
and say make cough0, Enter.

1659
01:16:35,330 --> 01:16:39,470
Nothing bad seems to happen.
./cough0 and cough, cough, cough.

1660
01:16:39,470 --> 01:16:42,950
So last week, I claimed that, eh,
you can design this better, right?

1661
01:16:42,950 --> 01:16:44,960
Anytime you're copying
and pasting, odds are

1662
01:16:44,960 --> 01:16:46,850
you should start to
resist that temptation,

1663
01:16:46,850 --> 01:16:49,933
because it's going to lead to messy
code, longer code than it needs to be.

1664
01:16:49,933 --> 01:16:52,133
What's the solution to this
problem from last week?

1665
01:16:52,133 --> 01:16:52,920
AUDIENCE: A loop.

1666
01:16:52,920 --> 01:16:54,390
DAVID MALAN: Yeah, a loop, a for loop.

1667
01:16:54,390 --> 01:16:55,682
So let me go ahead and do that.

1668
01:16:55,682 --> 01:16:57,693
Let me create another version, cough1.c.

1669
01:16:57,693 --> 01:17:00,360
And I'm going to copy/paste this
code, just as a starting point.

1670
01:17:00,360 --> 01:17:02,400
But now I'm going to go
ahead and clean it up.

1671
01:17:02,400 --> 01:17:04,960
So I'm going to go ahead
and instead do a for loop.

1672
01:17:04,960 --> 01:17:07,460
And I don't quite remember what
goes in the parentheses yet,

1673
01:17:07,460 --> 01:17:08,690
but we'll come back to that.

1674
01:17:08,690 --> 01:17:12,530
I do know that what I want to do
some number of times is just cough.

1675
01:17:12,530 --> 01:17:15,333
So the only question at hand
is, what was the syntax here?

1676
01:17:15,333 --> 01:17:17,250
Well, we can write this
in any number of ways,

1677
01:17:17,250 --> 01:17:18,890
and we could even use a while loop.

1678
01:17:18,890 --> 01:17:22,520
But I do recall saying int and
then the name of a variable.

1679
01:17:22,520 --> 01:17:24,960
I could say counter,
or I could just say i

1680
01:17:24,960 --> 01:17:28,970
to keep it succinct,
equals 0 by default.

1681
01:17:28,970 --> 01:17:32,540
I could do this so long as i
is less than 3, for instance.

1682
01:17:32,540 --> 01:17:38,070
And then on each iteration, I can say
i equals i plus 1 or, more succinctly,

1683
01:17:38,070 --> 01:17:39,710
i plus plus.

1684
01:17:39,710 --> 01:17:41,223
So, again, it's a lot of new syntax.

1685
01:17:41,223 --> 01:17:43,140
And there's semicolons
all over the place now.

1686
01:17:43,140 --> 01:17:46,700
But if I go ahead now
and do make cough1,

1687
01:17:46,700 --> 01:17:48,410
nothing bad seems to have happened.

1688
01:17:48,410 --> 01:17:51,020
./cough1, cough, cough, cough.

1689
01:17:51,020 --> 01:17:53,180
It seems to be slightly better designed.

1690
01:17:53,180 --> 01:17:55,460
Unfortunately, there is
this paradigm in programming

1691
01:17:55,460 --> 01:18:00,110
where humans, programmers, tend to think
or tend to count starting from zero.

1692
01:18:00,110 --> 01:18:02,240
However, if you don't like
that, at least early on,

1693
01:18:02,240 --> 01:18:05,210
there's nothing stopping
me from initializing i to 1

1694
01:18:05,210 --> 01:18:08,420
and then doing i is less than
4 or, even more explicitly,

1695
01:18:08,420 --> 01:18:10,655
i is less than or equal to 3.

1696
01:18:10,655 --> 01:18:13,280
There's no less than or equal
sign on your keyboard, typically,

1697
01:18:13,280 --> 01:18:17,390
so you can mimic it by doing a less than
and then an equal sign, two characters.

1698
01:18:17,390 --> 01:18:18,800
This is logically the same.

1699
01:18:18,800 --> 01:18:20,240
Set i equal to 1.

1700
01:18:20,240 --> 01:18:23,450
Then go ahead and print cough, and
then make sure to increment it.

1701
01:18:23,450 --> 01:18:26,150
And then make sure it's
still less than 3, and 2 is.

1702
01:18:26,150 --> 01:18:28,850
Make sure it's still less than
or equal to 3, and it still is.

1703
01:18:28,850 --> 01:18:31,620
So that 2 is, logically,
going to have the same effect.

1704
01:18:31,620 --> 01:18:36,590
However, in the interests of convention,
this would be the more common approach.

1705
01:18:36,590 --> 01:18:42,768
Do this while i equals 0 and then 1
and then 2, for a total of 3 times.

1706
01:18:42,768 --> 01:18:44,810
All right, but recall what
we did last time, too,

1707
01:18:44,810 --> 01:18:47,540
is that if I'm writing a lot
of code, for some reason, that

1708
01:18:47,540 --> 01:18:51,800
involves programs coughing, it would
be nice to give myself my own custom

1709
01:18:51,800 --> 01:18:52,920
function.

1710
01:18:52,920 --> 01:18:54,450
So let me go ahead and do that.

1711
01:18:54,450 --> 01:18:58,430
Let me go ahead and write my
own first brand-new function.

1712
01:18:58,430 --> 01:19:00,570
And I'm going to do this as follows.

1713
01:19:00,570 --> 01:19:04,220
I'm going to go ahead and type void,
then the name of the function I want.

1714
01:19:04,220 --> 01:19:07,160
Then I'm going to say void here,
for reasons we'll come back to.

1715
01:19:07,160 --> 01:19:10,160
And then I'm going to literally
just go ahead and say cough.

1716
01:19:10,160 --> 01:19:14,120
So there are functions we've used
today-- printf, get_int, get_string,

1717
01:19:14,120 --> 01:19:18,650
get_float-- none of which we showed you
the implementation of, because people,

1718
01:19:18,650 --> 01:19:21,270
years ago, both in the
staff and in the real world,

1719
01:19:21,270 --> 01:19:23,000
implemented those functions for us.

1720
01:19:23,000 --> 01:19:26,270
You, too, can implement your own
custom functions or, in Scratch,

1721
01:19:26,270 --> 01:19:29,690
those puzzle pieces that we
made in those pink blocks.

1722
01:19:29,690 --> 01:19:31,940
So if you want to make your
own function whose name is

1723
01:19:31,940 --> 01:19:35,960
cough, whose purpose in life
is to say cough on the screen,

1724
01:19:35,960 --> 01:19:37,010
this is the syntax.

1725
01:19:37,010 --> 01:19:40,880
For today's purposes, you say void and
void here, but the name of the function

1726
01:19:40,880 --> 01:19:41,690
is important.

1727
01:19:41,690 --> 01:19:43,040
I'll call it cough.

1728
01:19:43,040 --> 01:19:45,000
And then I can use it as follows.

1729
01:19:45,000 --> 01:19:50,750
I can say cough, cough, cough now
in order to cough three times.

1730
01:19:50,750 --> 01:19:53,150
Or again, we already
decided that was bad design.

1731
01:19:53,150 --> 01:19:57,770
For int i get 0, i less
than 3, i plus plus.

1732
01:19:57,770 --> 01:20:00,230
I can now do something like cough.

1733
01:20:00,230 --> 01:20:03,290
And so now, again, out
of sight, out of mind.

1734
01:20:03,290 --> 01:20:07,460
I don't need to know or care how
the cough function is implemented.

1735
01:20:07,460 --> 01:20:10,850
I can care that my code just
tells the computer what to do.

1736
01:20:10,850 --> 01:20:15,260
For i from 0 on up to
3, cough, cough, cough.

1737
01:20:15,260 --> 01:20:16,480
And this is an abstraction.

1738
01:20:16,480 --> 01:20:18,950
I don't care that cough is
implemented with printf.

1739
01:20:18,950 --> 01:20:22,070
I just care that there's
a function called cough.

1740
01:20:22,070 --> 01:20:25,490
So let me go ahead and run
this and see what happens.

1741
01:20:25,490 --> 01:20:28,710
Let me scroll down to the
bottom, do make cough1.

1742
01:20:28,710 --> 01:20:29,750
OK, amazing.

1743
01:20:29,750 --> 01:20:30,830
No red errors now.

1744
01:20:30,830 --> 01:20:34,550
So ./cough1, cough, cough, cough.

1745
01:20:34,550 --> 01:20:38,553
But notice that this is a little
bad design, I would claim,

1746
01:20:38,553 --> 01:20:39,470
because you know what?

1747
01:20:39,470 --> 01:20:42,890
If you keep writing custom
functions up here, up here, up here,

1748
01:20:42,890 --> 01:20:46,145
the main part of your program is
going to get pushed pretty far down.

1749
01:20:46,145 --> 01:20:48,770
And it's a human convention to
generally have the main function

1750
01:20:48,770 --> 01:20:49,790
at the top of your file.

1751
01:20:49,790 --> 01:20:50,790
Seems pretty reasonable.

1752
01:20:50,790 --> 01:20:53,420
So you open the file, boom, the
main function's right there.

1753
01:20:53,420 --> 01:20:54,620
So let's keep it there.

1754
01:20:54,620 --> 01:20:58,448
So let me actually move the
cough function down below just so

1755
01:20:58,448 --> 01:21:01,490
that, again, the first thing I see is
indeed the main part of my program.

1756
01:21:01,490 --> 01:21:03,020
And wherever cough is, I don't care.

1757
01:21:03,020 --> 01:21:05,090
That was the whole point
of implementing it.

1758
01:21:05,090 --> 01:21:08,990
Let me go now to my terminal
window and do make cough1.

1759
01:21:08,990 --> 01:21:12,500
Oh my god, some red errors flew by.

1760
01:21:12,500 --> 01:21:14,030
What's wrong here?

1761
01:21:14,030 --> 01:21:19,130
So error, implicit declaration of
function cough is invalid in C '99.

1762
01:21:19,130 --> 01:21:22,610
C '99 means the version
of C invented in 1999.

1763
01:21:22,610 --> 01:21:23,690
What's going on?

1764
01:21:23,690 --> 01:21:25,100
Implicit declaration?

1765
01:21:25,100 --> 01:21:27,500
So this is where C differs
from Scratch again.

1766
01:21:27,500 --> 01:21:29,840
C is old, and it's kind of dumb.

1767
01:21:29,840 --> 01:21:32,840
It only knows what you
tell it, and it only

1768
01:21:32,840 --> 01:21:36,290
knows what you tell it in order
top to bottom, left to right.

1769
01:21:36,290 --> 01:21:41,480
So in this program right now, I
have included stdio.h, as before.

1770
01:21:41,480 --> 01:21:43,700
I've included the beginning of main.

1771
01:21:43,700 --> 01:21:45,480
I've started a for loop.

1772
01:21:45,480 --> 01:21:48,320
And then I'm using a function
that's apparently called cough.

1773
01:21:48,320 --> 01:21:52,640
However, where is cough
now actually implemented?

1774
01:21:52,640 --> 01:21:54,880
Way down here on line 11 onwards.

1775
01:21:54,880 --> 01:21:56,600
C is not that smart.

1776
01:21:56,600 --> 01:21:59,510
It's not going to presume to
look later in your file to see,

1777
01:21:59,510 --> 01:22:02,150
maybe they put the
function cough down below.

1778
01:22:02,150 --> 01:22:04,070
It's only going to do what you tell it.

1779
01:22:04,070 --> 01:22:05,503
So there's a fix for this.

1780
01:22:05,503 --> 01:22:07,670
You can either do what I
did initially, which is put

1781
01:22:07,670 --> 01:22:09,268
all of your custom functions up top.

1782
01:22:09,268 --> 01:22:11,810
But that's kind of a vicious
cycle, because you can't forever

1783
01:22:11,810 --> 01:22:13,107
put the new functions up top.

1784
01:22:13,107 --> 01:22:15,690
Eventually, you're going to run
into some kind of constraints.

1785
01:22:15,690 --> 01:22:19,070
And my god, you want the main
function, by convention, to be up top.

1786
01:22:19,070 --> 01:22:20,880
So there's another solution here.

1787
01:22:20,880 --> 01:22:23,900
And this is the only time
where copy/paste is compelling.

1788
01:22:23,900 --> 01:22:29,210
You literally copy the first line of
your function's code on line 11 there.

1789
01:22:29,210 --> 01:22:33,660
And you go ahead and paste it at the
top of your file with a semicolon.

1790
01:22:33,660 --> 01:22:38,113
So this is a way of sort of tricking C
into, oh, you have seen cough before.

1791
01:22:38,113 --> 01:22:40,530
You haven't seen all of it,
but you've seen enough of it--

1792
01:22:40,530 --> 01:22:41,720
you've seen its name--

1793
01:22:41,720 --> 01:22:45,870
to now tolerate its appearance
in my main function.

1794
01:22:45,870 --> 01:22:49,130
So let me go ahead and
recompile this code.

1795
01:22:49,130 --> 01:22:51,770
I'm going to go ahead and
run make cough1 enter.

1796
01:22:51,770 --> 01:22:53,510
OK, now it compiled.

1797
01:22:53,510 --> 01:22:59,370
./cough1, and viola, we're
back in business there.

1798
01:22:59,370 --> 01:23:00,740
But let me make one refinement.

1799
01:23:00,740 --> 01:23:05,810
And I'm going to jump ahead to what I
called in the online examples cough3.c.

1800
01:23:05,810 --> 01:23:08,600
It turns out your own custom
functions can take input.

1801
01:23:08,600 --> 01:23:11,610
This word void means
that it takes no input.

1802
01:23:11,610 --> 01:23:15,938
And this word void means it returns no
value, like get_int and get_string hand

1803
01:23:15,938 --> 01:23:16,730
you back something.

1804
01:23:16,730 --> 01:23:18,647
That's not applicable
now, but we'll come back

1805
01:23:18,647 --> 01:23:20,450
to that in a week or two's time.

1806
01:23:20,450 --> 01:23:24,770
Suppose that you wanted to make
the cough function more versatile

1807
01:23:24,770 --> 01:23:28,190
such that it will cough any
number of times for you.

1808
01:23:28,190 --> 01:23:29,660
You know what you can do, is this.

1809
01:23:29,660 --> 01:23:34,670
You can change the input to cough
function to be some value like n,

1810
01:23:34,670 --> 01:23:38,840
and you can then do something
like this-- for int i get 0.

1811
01:23:38,840 --> 01:23:43,730
i is less than n, so not
hardcoded anymore. i plus plus.

1812
01:23:43,730 --> 01:23:48,650
And then inside of your curly braces,
you can print this cough line.

1813
01:23:48,650 --> 01:23:52,520
So now, notice, cough
has been parameterized.

1814
01:23:52,520 --> 01:23:55,430
It now takes input of
integer called n, and it

1815
01:23:55,430 --> 01:23:58,220
uses that input, n, just
like you could have done

1816
01:23:58,220 --> 01:24:00,740
in Scratch, to do something n times--

1817
01:24:00,740 --> 01:24:04,010
not once, not three times, but
a variable number of times.

1818
01:24:04,010 --> 01:24:06,360
I have to change my first line here.

1819
01:24:06,360 --> 01:24:07,520
This is called a prototype.

1820
01:24:07,520 --> 01:24:09,860
This one-liner is what's
called a prototype,

1821
01:24:09,860 --> 01:24:12,140
and it's just copy/paste
from your actual function.

1822
01:24:12,140 --> 01:24:13,700
But now notice what I can do.

1823
01:24:13,700 --> 01:24:16,550
My main function, again, is
the essence of my program.

1824
01:24:16,550 --> 01:24:19,190
It's a little convoluted right now.

1825
01:24:19,190 --> 01:24:23,150
Wouldn't it be nicer if I could
just say cough three times?

1826
01:24:23,150 --> 01:24:28,040
And indeed, now I don't need to know
or care how coughing is implemented.

1827
01:24:28,040 --> 01:24:30,950
That's a well-designed
program, arguably.

1828
01:24:30,950 --> 01:24:32,300
It's one line of code.

1829
01:24:32,300 --> 01:24:33,137
It's descriptive.

1830
01:24:33,137 --> 01:24:33,720
It says cough.

1831
01:24:33,720 --> 01:24:35,990
It takes an input, which
means it costs three times.

1832
01:24:35,990 --> 01:24:38,823
And what's down below in the file,
though I could certainly bring it

1833
01:24:38,823 --> 01:24:40,770
back up, is just what
a computer scientist

1834
01:24:40,770 --> 01:24:43,250
would call an implementation detail.

1835
01:24:43,250 --> 01:24:45,620
Someone cares how you
implement coughing,

1836
01:24:45,620 --> 01:24:48,200
but you don't have to care
how you implement coughing.

1837
01:24:48,200 --> 01:24:50,530
You don't have to how we get integers.

1838
01:24:50,530 --> 01:24:52,930
You don't have to care
about how you printf.

1839
01:24:52,930 --> 01:24:56,140
You just care that someone else
has implemented that functionality

1840
01:24:56,140 --> 01:25:00,280
so you can stand on their shoulders and
build more interesting programs that

1841
01:25:00,280 --> 01:25:03,310
are actually interesting to you.

1842
01:25:03,310 --> 01:25:06,235
Let me go ahead and open up an
example that builds on this same idea.

1843
01:25:06,235 --> 01:25:08,740


1844
01:25:08,740 --> 01:25:14,030
In, let's see, positive.c,
we have this example here,

1845
01:25:14,030 --> 01:25:16,040
which makes this all the more clear.

1846
01:25:16,040 --> 01:25:20,100
So here's a program that uses our
two libraries, CS50 in standard I/O.

1847
01:25:20,100 --> 01:25:22,330
It turns out that the
CS50 library does not

1848
01:25:22,330 --> 01:25:24,730
come with a function
called get_positive_int.

1849
01:25:24,730 --> 01:25:25,772
It comes with get_int.

1850
01:25:25,772 --> 01:25:27,730
And you could imagine
programs where you really

1851
01:25:27,730 --> 01:25:31,450
want a positive integer from the human,
because negative numbers for a game

1852
01:25:31,450 --> 01:25:33,820
or for some program just
would make no sense.

1853
01:25:33,820 --> 01:25:35,380
So how can we implement that?

1854
01:25:35,380 --> 01:25:38,350
Well, it would be nice to
create it so that you can simply

1855
01:25:38,350 --> 01:25:40,930
write a two-line program
like this where you call

1856
01:25:40,930 --> 01:25:42,820
a function called get_positive_int.

1857
01:25:42,820 --> 01:25:46,720
And if I scroll down, notice
there's actually a new feature

1858
01:25:46,720 --> 01:25:49,810
here that we've not seen yet,
but it's an interesting example

1859
01:25:49,810 --> 01:25:52,600
of another feature of C.
What I've highlighted here

1860
01:25:52,600 --> 01:25:56,350
between lines 15 and 24 is this logic.

1861
01:25:56,350 --> 01:25:58,510
Here's a function
called get_positive_int.

1862
01:25:58,510 --> 01:26:01,690
It takes no inputs, so I don't have
to pass anything in parentheses.

1863
01:26:01,690 --> 01:26:03,850
I just want to get any old positive int.

1864
01:26:03,850 --> 01:26:06,670
But I do want this function
to hand me back something,

1865
01:26:06,670 --> 01:26:09,850
just like get_int handed me back a
value that I could put in a variable,

1866
01:26:09,850 --> 01:26:11,170
just like get_string does.

1867
01:26:11,170 --> 01:26:13,030
So this is not void.

1868
01:26:13,030 --> 01:26:13,990
This is int.

1869
01:26:13,990 --> 01:26:17,290
So this word to the left of a
function is the type of its output.

1870
01:26:17,290 --> 01:26:20,920
This word in parentheses is
the type of its input, if any.

1871
01:26:20,920 --> 01:26:24,640
And if there is nothing, you just
say void in either or both place.

1872
01:26:24,640 --> 01:26:26,190
Now, here's a curiosity--

1873
01:26:26,190 --> 01:26:30,280
on line 17, we've not seen this before,
but this is just a hint to the computer

1874
01:26:30,280 --> 01:26:32,425
saying give me a variable called n.

1875
01:26:32,425 --> 01:26:34,300
I'm not sure what I'm
going to put in it yet.

1876
01:26:34,300 --> 01:26:36,580
So you literally just
say int n semicolon.

1877
01:26:36,580 --> 01:26:38,405
You don't need to
assign it anything yet.

1878
01:26:38,405 --> 01:26:40,030
It has what we'll call a garbage value.

1879
01:26:40,030 --> 01:26:42,322
You have no idea what's in
it, but that doesn't matter.

1880
01:26:42,322 --> 01:26:43,730
You'll put something in it later.

1881
01:26:43,730 --> 01:26:45,820
Then there's this loop,
which we haven't seen yet,

1882
01:26:45,820 --> 01:26:47,800
but in C, it's called a do-while loop.

1883
01:26:47,800 --> 01:26:52,120
It literally says do the following
while this Boolean expression is true.

1884
01:26:52,120 --> 01:26:53,320
So what do I want to do?

1885
01:26:53,320 --> 01:26:55,330
I want to get an int
from the user, prompting

1886
01:26:55,330 --> 01:26:58,540
the human for a positive
integer, and store it in n.

1887
01:26:58,540 --> 01:27:03,010
However, I want to keep doing
this while n is less than 1.

1888
01:27:03,010 --> 01:27:06,370
Because if the human types in
0 or negative 1 or negative 50

1889
01:27:06,370 --> 01:27:12,040
or anything non-positive, I do want to
prompt them again and again and again.

1890
01:27:12,040 --> 01:27:14,530
So a do-while loop is
kind of neat, because it

1891
01:27:14,530 --> 01:27:17,090
will do this first thing at least once.

1892
01:27:17,090 --> 01:27:20,200
Then it will check the condition
and potentially do it again

1893
01:27:20,200 --> 01:27:22,450
if the human has not cooperated.

1894
01:27:22,450 --> 01:27:25,900
A while loop, if you think back,
actually checked the condition first.

1895
01:27:25,900 --> 01:27:29,590
It was while some Boolean expression
is true, do the following.

1896
01:27:29,590 --> 01:27:34,210
This one gives you one such
iteration, one pass for free,

1897
01:27:34,210 --> 01:27:35,767
and then it checks the condition.

1898
01:27:35,767 --> 01:27:37,600
So it's just a different
way of programming,

1899
01:27:37,600 --> 01:27:40,090
but we could do everything
we've done thus far using

1900
01:27:40,090 --> 01:27:46,550
while loops or even for loops, as well.

1901
01:27:46,550 --> 01:27:50,080
All right, well let's go ahead now and
make this a little more user friendly.

1902
01:27:50,080 --> 01:27:54,790
Let me go ahead and pull up some
examples here of some screens that

1903
01:27:54,790 --> 01:27:56,060
might look familiar.

1904
01:27:56,060 --> 01:27:58,488
So if I go ahead and
open up, for instance,

1905
01:27:58,488 --> 01:28:00,280
this slide here, you
might recall this game

1906
01:28:00,280 --> 01:28:04,000
from yesteryear, Super Mario Brothers
1, from the very original Nintendo.

1907
01:28:04,000 --> 01:28:07,510
And there's some screens in that game
that look a little something like this.

1908
01:28:07,510 --> 01:28:09,100
For instance, these are
little bricks in the air

1909
01:28:09,100 --> 01:28:11,200
that if Mario or Luigi
hits their head up against,

1910
01:28:11,200 --> 01:28:13,450
like a coin or something else pops out.

1911
01:28:13,450 --> 01:28:16,810
But this is kind of a nice idea, because
it lends itself to actually doing

1912
01:28:16,810 --> 01:28:18,535
something a little programmatically.

1913
01:28:18,535 --> 01:28:21,160
For instance, how might I go
about writing a program that quite

1914
01:28:21,160 --> 01:28:23,800
simply prints out four question marks?

1915
01:28:23,800 --> 01:28:26,920
Well, let me go ahead and open
up, for instance, in code,

1916
01:28:26,920 --> 01:28:30,100
an example called mario0.c.

1917
01:28:30,100 --> 01:28:33,087
And I claim that this could be one
way of implementing this program.

1918
01:28:33,087 --> 01:28:35,170
It's very simple, and it
really doesn't do justice

1919
01:28:35,170 --> 01:28:39,400
to the other graphics on the screen,
but it does implement that one idea.

1920
01:28:39,400 --> 01:28:41,800
And indeed, somewhere
in the code for Mario,

1921
01:28:41,800 --> 01:28:43,600
there was probably
some line of code that

1922
01:28:43,600 --> 01:28:47,950
told the console game to print
question mark, question mark, question

1923
01:28:47,950 --> 01:28:48,970
mark, question mark.

1924
01:28:48,970 --> 01:28:51,760
In C, we could certainly do
this with four question marks.

1925
01:28:51,760 --> 01:28:55,048
Or how else could we do
something that many times?

1926
01:28:55,048 --> 01:28:55,840
AUDIENCE: For loop.

1927
01:28:55,840 --> 01:28:57,465
DAVID MALAN: Something like a for loop.

1928
01:28:57,465 --> 01:29:00,310
So let me go ahead and jump
ahead a couple of iterations

1929
01:29:00,310 --> 01:29:05,200
to an example I'll call mario2.c,
which just does all of this.

1930
01:29:05,200 --> 01:29:08,500
So this is actually pretty involved,
but notice what it's doing.

1931
01:29:08,500 --> 01:29:12,010
In main, I'm saying, hey,
give me an integer called n.

1932
01:29:12,010 --> 01:29:14,630
Do the following while n is less than 1.

1933
01:29:14,630 --> 01:29:18,820
So this is just a way of asking,
what is the width of the blocks

1934
01:29:18,820 --> 01:29:20,140
that you want to print?

1935
01:29:20,140 --> 01:29:24,190
Then, once I have that answer, I
can go ahead and, just as before,

1936
01:29:24,190 --> 01:29:28,940
print that many question
marks n times, one at a time.

1937
01:29:28,940 --> 01:29:32,080
And at the very end, I'll
print just a new line.

1938
01:29:32,080 --> 01:29:35,470
So in short, if you want to
create a program, albeit in text,

1939
01:29:35,470 --> 01:29:37,760
that does something like
this, and I make mario2--

1940
01:29:37,760 --> 01:29:38,410
whoops.

1941
01:29:38,410 --> 01:29:43,510
And I make mario2,
Enter, and type ./mario2,

1942
01:29:43,510 --> 01:29:46,510
I can do a width of four
and get four question marks.

1943
01:29:46,510 --> 01:29:49,730
Or I can do 50 and get many
more on the screen, all

1944
01:29:49,730 --> 01:29:51,480
by just using these
basic building blocks.

1945
01:29:51,480 --> 01:29:54,660
But notice, because of that
do-while loop, if I don't cooperate

1946
01:29:54,660 --> 01:29:58,110
and I do something like 0 or
negative 1 or negative 50,

1947
01:29:58,110 --> 01:30:02,160
I just keep getting prompted again
and again, because n is less than 1.

1948
01:30:02,160 --> 01:30:05,130
That's the kind of logic
that you can impose there.

1949
01:30:05,130 --> 01:30:10,018
But let's go ahead and skip ahead,
say, to something like this in Mario,

1950
01:30:10,018 --> 01:30:12,060
where you have a whole
lot of bricks underground.

1951
01:30:12,060 --> 01:30:16,000
And this time, it's not just
a column or a row of bricks.

1952
01:30:16,000 --> 01:30:17,755
This time, it's kind of two dimensions.

1953
01:30:17,755 --> 01:30:20,130
Well, this is kind of interesting,
because now how do you

1954
01:30:20,130 --> 01:30:23,200
go about printing block, block, block,
block, block, block, block, block,

1955
01:30:23,200 --> 01:30:25,158
block, block, block,
block, and actually making

1956
01:30:25,158 --> 01:30:26,700
a two-dimensional structure instead?

1957
01:30:26,700 --> 01:30:30,090
Well, there's nothing stopping
us in C, as in Scratch,

1958
01:30:30,090 --> 01:30:33,540
from doing something,
for instance, with loops.

1959
01:30:33,540 --> 01:30:35,650
So let me show this example here.

1960
01:30:35,650 --> 01:30:38,070
So suppose that with
these first lines of code,

1961
01:30:38,070 --> 01:30:41,938
I've asked the user for
the size of this block.

1962
01:30:41,938 --> 01:30:44,730
So I want to create something that's
square-like like this-- block,

1963
01:30:44,730 --> 01:30:47,710
block, block, block, block, block,
block, block, block, and so forth.

1964
01:30:47,710 --> 01:30:51,270
Well, I can go ahead and prompt
them for an int again and again

1965
01:30:51,270 --> 01:30:53,500
and again until I know that size.

1966
01:30:53,500 --> 01:30:54,930
And then notice this.

1967
01:30:54,930 --> 01:30:58,770
This is starting to escalate
again, but consider the logic.

1968
01:30:58,770 --> 01:31:02,520
This now is for int i get 0,
i less than n, i plus plus.

1969
01:31:02,520 --> 01:31:04,500
So do the following n times, right?

1970
01:31:04,500 --> 01:31:08,220
This is a very cryptic, C-like way
of saying, do the following n times.

1971
01:31:08,220 --> 01:31:10,170
What about line 16?

1972
01:31:10,170 --> 01:31:13,740
What is line 16 saying?

1973
01:31:13,740 --> 01:31:16,710
Even though it's using
a different variable.

1974
01:31:16,710 --> 01:31:18,869
I'm using j just because instead of i.

1975
01:31:18,869 --> 01:31:19,744
AUDIENCE: Same thing.

1976
01:31:19,744 --> 01:31:20,786
Do the following n times.

1977
01:31:20,786 --> 01:31:24,180
DAVID MALAN: Yeah, it says the exact
same thing-- do the following n times.

1978
01:31:24,180 --> 01:31:26,880
However, it's counting
using j instead of i,

1979
01:31:26,880 --> 01:31:30,100
just so that my math doesn't
kind of commingle incorrectly.

1980
01:31:30,100 --> 01:31:32,580
So if you think about
what this Mario block is,

1981
01:31:32,580 --> 01:31:35,318
this is like printing rows and columns.

1982
01:31:35,318 --> 01:31:37,860
Kind of like an old school
typewriter that's got to move from

1983
01:31:37,860 --> 01:31:41,250
left to right and then top to
bottom, top to bottom, left to right,

1984
01:31:41,250 --> 01:31:44,610
and so forth just to print
different blocks on different lines.

1985
01:31:44,610 --> 01:31:47,010
So the effect here--
if I open up mario8--

1986
01:31:47,010 --> 01:31:48,730
might be this, make-- oops.

1987
01:31:48,730 --> 01:31:53,193
Let me go ahead and
make mario8, ./mario8.

1988
01:31:53,193 --> 01:31:54,360
What's the size going to be?

1989
01:31:54,360 --> 01:31:55,680
Well, maybe three.

1990
01:31:55,680 --> 01:32:00,030
And now I've printed out
three rows and three columns.

1991
01:32:00,030 --> 01:32:03,930
These essentially
represent each of my rows.

1992
01:32:03,930 --> 01:32:05,830
I'm counting from i up to--

1993
01:32:05,830 --> 01:32:07,450
oh.

1994
01:32:07,450 --> 01:32:10,980
I'm teaching myself now only, OK.

1995
01:32:10,980 --> 01:32:11,760
Let's rewind.

1996
01:32:11,760 --> 01:32:13,950
Here is what was
amazing me a moment ago.

1997
01:32:13,950 --> 01:32:16,770
When I was running what's
the size of this program,

1998
01:32:16,770 --> 01:32:19,140
I saw a three-by-three grid of blocks.

1999
01:32:19,140 --> 01:32:21,450
And if I run it again,
maybe with 10, I now

2000
01:32:21,450 --> 01:32:24,003
see an even bigger grid
of 10-by-10 bricks.

2001
01:32:24,003 --> 01:32:26,670
It's a little taller than it is
wide, because the hash marks are

2002
01:32:26,670 --> 01:32:27,960
taller than they are wide.

2003
01:32:27,960 --> 01:32:30,390
And you'll see that now
this program is dynamic.

2004
01:32:30,390 --> 01:32:31,950
So how is that working?

2005
01:32:31,950 --> 01:32:33,950
Well, if I actually
look at the code here,

2006
01:32:33,950 --> 01:32:36,750
notice that, effectively,
what line 14 is doing

2007
01:32:36,750 --> 01:32:39,030
is it's doing one row at a time.

2008
01:32:39,030 --> 01:32:43,170
It's giving me n rows, and each of those
rows I'm thinking of this is i at 0,

2009
01:32:43,170 --> 01:32:46,020
i1, i2, and so forth.

2010
01:32:46,020 --> 01:32:50,650
Meanwhile, within each row,
I'm using this inner loop,

2011
01:32:50,650 --> 01:32:54,900
which is deliberately nested inside,
to kind of do each of the characters

2012
01:32:54,900 --> 01:32:55,990
from left to right.

2013
01:32:55,990 --> 01:32:58,680
So within each row, I want
hash, hash, hash, hash.

2014
01:32:58,680 --> 01:33:00,750
Within each row--
hash, hash, hash, hash.

2015
01:33:00,750 --> 01:33:03,670
So it's like implementing
this two-dimensional process.

2016
01:33:03,670 --> 01:33:06,900
But again, using the
same fundamental ideas.

2017
01:33:06,900 --> 01:33:11,370
Just a for loop that's very
carefully counting from zero on up

2018
01:33:11,370 --> 01:33:16,032
to some value to do something
again and again and again.

2019
01:33:16,032 --> 01:33:18,240
And so if you think about
really any of today's games

2020
01:33:18,240 --> 01:33:21,150
or graphics or programs,
anytime you see redundancy,

2021
01:33:21,150 --> 01:33:24,600
whether it's this in two dimensions--
maybe it's this vertically in one

2022
01:33:24,600 --> 01:33:26,712
dimension or this
horizontally in another.

2023
01:33:26,712 --> 01:33:29,670
Odds are, there's just some repetition
that's happening again and again

2024
01:33:29,670 --> 01:33:33,510
and again that can be reduced in C
or in Scratch or some other language

2025
01:33:33,510 --> 01:33:36,780
to ultimately just lines of code.

2026
01:33:36,780 --> 01:33:39,270
And indeed, this is an allusion
to one of the first things

2027
01:33:39,270 --> 01:33:41,760
you'll do for the first
problem set, problem set 1.

2028
01:33:41,760 --> 01:33:45,180
You'll use CS50 Lab, which is
identical to CS50 Sandbox, which

2029
01:33:45,180 --> 01:33:48,090
I've been using thus far,
but which adds instructions,

2030
01:33:48,090 --> 01:33:52,170
the actual problems to solve,
alongside of your sandbox.

2031
01:33:52,170 --> 01:33:55,470
But before we tease you
with that, let's just

2032
01:33:55,470 --> 01:34:00,720
consider now that there are a bunch of
little assumptions I've been making.

2033
01:34:00,720 --> 01:34:03,060
Like thus far, all of
the mistakes in my code

2034
01:34:03,060 --> 01:34:06,990
have been my own-- some intentional, but
several unintentional, as well, today.

2035
01:34:06,990 --> 01:34:10,560
But it turns out that computers
themselves do have limitations.

2036
01:34:10,560 --> 01:34:12,810
Inside of your Mac or PC is
generally stuff like this.

2037
01:34:12,810 --> 01:34:14,372
This is called memory, or RAM.

2038
01:34:14,372 --> 01:34:16,080
And you don't typically
see it unless you

2039
01:34:16,080 --> 01:34:18,900
remove the cover from your
phone or your laptop or desktop.

2040
01:34:18,900 --> 01:34:22,680
RAM is where all of your programs
are stored while they're running.

2041
01:34:22,680 --> 01:34:26,190
RAM is where all of your programs--
where all of your files are

2042
01:34:26,190 --> 01:34:27,540
stored while they're open.

2043
01:34:27,540 --> 01:34:30,930
It's what your computer uses
to do multiple things at once

2044
01:34:30,930 --> 01:34:32,440
and keep things in memory.

2045
01:34:32,440 --> 01:34:35,430
However, it is, by nature
of hardware, finite.

2046
01:34:35,430 --> 01:34:38,610
You have maybe one gigabyte,
one billion bytes, of memory.

2047
01:34:38,610 --> 01:34:41,400
Maybe you have four gigabytes,
or four billion bytes, of memory.

2048
01:34:41,400 --> 01:34:44,280
You have fixed amount of
memory in your computer,

2049
01:34:44,280 --> 01:34:48,040
which means there is some fundamental
limitation on what your computer can

2050
01:34:48,040 --> 01:34:48,540
do.

2051
01:34:48,540 --> 01:34:52,350
It cannot necessarily count to infinity,
because how could it count to infinity

2052
01:34:52,350 --> 01:34:57,020
if it can't store all possible numbers
using a finite amount of space?

2053
01:34:57,020 --> 01:34:59,370
Indeed, there are some
limits of computation

2054
01:34:59,370 --> 01:35:01,230
that we've only just begun to see.

2055
01:35:01,230 --> 01:35:02,890
In fact, let me go ahead and do this.

2056
01:35:02,890 --> 01:35:06,445
Let me write a program that I'm
going to go ahead and call float.c.

2057
01:35:06,445 --> 01:35:09,570
And this is just going to be a program
that gets a couple of floating point

2058
01:35:09,570 --> 01:35:11,980
values from the user.

2059
01:35:11,980 --> 01:35:15,000
Let me go ahead and
include the CS50 library.

2060
01:35:15,000 --> 01:35:19,420
Let's go ahead and include
stdio.h, int main void, as before.

2061
01:35:19,420 --> 01:35:22,488
And all I want to do here with this
program is get a couple of floats.

2062
01:35:22,488 --> 01:35:23,280
So give me a float.

2063
01:35:23,280 --> 01:35:24,420
We'll call it x.

2064
01:35:24,420 --> 01:35:26,808
Get_float, and I'll
prompt the human for x.

2065
01:35:26,808 --> 01:35:28,350
Then let me go ahead and get another.

2066
01:35:28,350 --> 01:35:29,370
I'll call it y.

2067
01:35:29,370 --> 01:35:31,380
Get_float, quote unquote y.

2068
01:35:31,380 --> 01:35:34,110
And recall that a float
is just a number that

2069
01:35:34,110 --> 01:35:36,475
has a decimal point in it,
a so-called real number.

2070
01:35:36,475 --> 01:35:38,100
Now let's just do some simple division.

2071
01:35:38,100 --> 01:35:40,990
I claim that computers can do
addition, subtraction, and so forth.

2072
01:35:40,990 --> 01:35:41,920
So let's do that.

2073
01:35:41,920 --> 01:35:46,410
Let's just tell it that x divided by
y is going to equal the following--

2074
01:35:46,410 --> 01:35:52,150
percent f backslash n x
divided by y semicolon.

2075
01:35:52,150 --> 01:35:55,110
So that's just sort of a
very simplistic calculator

2076
01:35:55,110 --> 01:35:57,510
that I've implemented that
only supports division.

2077
01:35:57,510 --> 01:36:04,170
Let me go ahead and compile this
by going and typing make floats.

2078
01:36:04,170 --> 01:36:05,820
And you'll see that it did compile.

2079
01:36:05,820 --> 01:36:07,980
So floats with dot slash.

2080
01:36:07,980 --> 01:36:09,570
x is going to be, say, 1.

2081
01:36:09,570 --> 01:36:10,960
y is going to be 10.

2082
01:36:10,960 --> 01:36:12,120
OK, viola.

2083
01:36:12,120 --> 01:36:15,501
x divided by y equals 0.10000.

2084
01:36:15,501 --> 01:36:16,440
That's pretty nice.

2085
01:36:16,440 --> 01:36:19,570
And recall, if you don't want to see
all those zeros, you can just say,

2086
01:36:19,570 --> 01:36:23,160
show me one decimal point by adding 0.1.

2087
01:36:23,160 --> 01:36:25,950
Recompile and then rerun it.

2088
01:36:25,950 --> 01:36:27,790
And now do 1, 10.

2089
01:36:27,790 --> 01:36:29,820
OK, so now it's 1/10.

2090
01:36:29,820 --> 01:36:30,930
Or is it?

2091
01:36:30,930 --> 01:36:33,660
Now that I have this ability
to look past the decimal point,

2092
01:36:33,660 --> 01:36:36,900
why don't I look not a
few places or one place.

2093
01:36:36,900 --> 01:36:40,440
Let me go ahead and look maybe 10
places after the decimal point.

2094
01:36:40,440 --> 01:36:48,210
Let me rerun this as make
floats, ./floats, 1, 10.

2095
01:36:48,210 --> 01:36:49,920
Interesting.

2096
01:36:49,920 --> 01:36:51,627
All right, that seems a little strange.

2097
01:36:51,627 --> 01:36:52,710
Maybe it was just a fluke.

2098
01:36:52,710 --> 01:36:54,043
Let's look out a little further.

2099
01:36:54,043 --> 01:36:56,080
Let's look 50 decimal places out.

2100
01:36:56,080 --> 01:36:57,887
Давайте я пересоберу.

2101
01:36:57,887 --> 01:36:59,970
Кстати, здесь есть некоторые
горячие клавиши
And it turns out, there's
some keyboard shortcuts.

2102
01:36:59,970 --> 01:37:02,100
я сейчас жму вверх и вниз
на моей клавиатуре, это

2103
01:37:02,100 --> 01:37:04,302
позволяет мне ходить
по всей моей истории команд

2104
01:37:04,302 --> 01:37:06,010
поэтому вам не надо ничего
запоминать.

2105
01:37:06,010 --> 01:37:08,130
Итак, чтобы сэкономить время,
я просто переключаюсь вверх и вниз.

2106
01:37:08,130 --> 01:37:11,85
Давайте я сделаю
./floats теперь, 1, 10.

2107
01:37:11,850 --> 01:37:14,820
Боже мой, деление это ложь.

2108
01:37:14,820 --> 01:37:18,660
Так что если ваш школьный учитель,
или кто бы то ни был учил вас что 1 деленное на 10

2109
01:37:18,660 --> 01:37:24,690
это 1/10, или 0.1, с бесконечными нулями,
это очевидно неправда.

2110
01:37:24,690 --> 01:37:28,810
В компьютере 1/10 это вот
это значение.

2111
01:37:28,810 --> 01:37:31,500
Так на чем мы остановимся?

2112
01:37:31,500 --> 01:37:36,180
Кто прав, начальная школа
или компьютеры?

2113
01:37:36,180 --> 01:37:39,150
Кто может обьяснить?

2114
01:37:39,150 --> 01:37:40,860
Есть какие-то мысли?

2115
01:37:40,860 --> 01:37:41,850
Да?

2116
01:37:41,850 --> 01:37:45,550
АУДИТОРИЯ: Компьютер может сохранить
только ограниченное количество символов,

2117
01:37:45,550 --> 01:37:47,300
так что непонятно что происходит
с тем что не получилось сохранить.

2118
01:37:47,300 --> 01:37:48,800
DAVID MALAN: Да, хорошее обьяснение

2119
01:37:48,800 --> 01:37:51,200
Компьютеры могут только хранить
ограниченный обьем информации,

2120
01:37:51,200 --> 01:37:52,908
поэтому в какой то момент
непонятно что происходит дальше.

2121
01:37:52,908 --> 01:37:53,480
Мне оно нравится.

2122
01:37:53,480 --> 01:37:54,710
Потому что оно очень верное.

2123
01:37:54,710 --> 01:37:57,120
Если у вас ограниченное количество
оборудования,

2124
01:37:57,120 --> 01:38:00,830
например ограниченный обьем памяти,
в какой то момент компьютер решит:

2125
01:38:00,830 --> 01:38:02,780
"я не могу хранить больше чем это значение".

2126
01:38:02,780 --> 01:38:06,890
Или "я не могу хранить больше
чем вот столько знаков после точки".

2127
01:38:06,890 --> 01:38:09,290
Мы используем 32 бита,
которые представлены типом float.

2128
01:38:09,290 --> 01:38:12,470
Вы можете использовать больше бит, как,
например double, который я описывал раньше,

2129
01:38:12,470 --> 01:38:14,720
он использует буквально
в два раза больше битов, 64.

2130
01:38:14,720 --> 01:38:19,580
Что значит мы можем пойти дальше от
точки, прежде чем увидим неточности.

2131
01:38:19,580 --> 01:38:20,870
Но вы их обязательно увидите.

2132
01:38:20,870 --> 01:38:24,440
Компьютеры не идеальны,
в этом плане.

2133
01:38:24,440 --> 01:38:26,780
Они могут хранить только
ограниченный обьем информации.

2134
01:38:26,780 --> 01:38:31,190
И в этом смысле, компьютер
хранит настолько точное значение

2135
01:38:31,190 --> 01:38:34,190
для 1 деленного на 10, насколько может.

2136
01:38:34,190 --> 01:38:38,090
Потому что вы вероятно не можете
хранить бесконечное число цифр

2137
01:38:38,090 --> 01:38:42,080
со 100% точностью, используя
ограниченный обьем информации.

2138
01:38:42,080 --> 01:38:44,060
И мы еще увидим это в
другом контексте.

2139
01:38:44,060 --> 01:38:48,530
Давайте я напишу еще одну
программу по имени overflow.c.

2140
01:38:48,530 --> 01:38:50,990
И мы увидим ту же проблему
в другом свете.

2141
01:38:50,990 --> 01:38:54,350
Я включаю stdio.h.

2142
01:38:54,350 --> 01:38:57,410
Пишу int main void.

2143
01:38:57,410 --> 01:39:01,190
int i равен единице.

2144
01:39:01,190 --> 01:39:07,478
Тааак, нет условия, потом делать i раз
умноженное на 2.

2145
01:39:07,478 --> 01:39:09,020
И затем я просто напишу.

2146
01:39:09,020 --> 01:39:11,840
Напечатать значение i.

2147
01:39:11,840 --> 01:39:15,440
Да, я пишу быстро, но
я только что написал программу, которая

2148
01:39:15,440 --> 01:39:17,510
начнет считать в нуле.

2149
01:39:17,510 --> 01:39:19,430
Она умножит i.

2150
01:39:19,430 --> 01:39:22,562
Звездочка равно значит на два
снова и снова.

2151
01:39:22,562 --> 01:39:25,520
И я буду это делать вечно, потому что,
я намеренно

2152
01:39:25,520 --> 01:39:27,380
не задал булево условие здесь.

2153
01:39:27,380 --> 01:39:29,352
Я мог написать что то типа
true,

2154
01:39:29,352 --> 01:39:30,810
но я также могу оставить его пустым.

2155
01:39:30,810 --> 01:39:32,310
Это значит делать вечно.

2156
01:39:32,310 --> 01:39:33,590
Это бесконечный цикл.

2157
01:39:33,590 --> 01:39:36,950
Оно очень быстро пролетит на этом экране.

2158
01:39:36,950 --> 01:39:40,190
Поэтому я скажу ему спать
одну секунду между выполнениями.

2159
01:39:40,190 --> 01:39:43,010
И это функция в C, по имени sleep.

2160
01:39:43,010 --> 01:39:45,230
Но чтобы ее использовать, вам
нужно подключить

2161
01:39:45,230 --> 01:39:50,092
другой файл по имени unistandard.h.

2162
01:39:50,092 --> 01:39:52,550
Вы можете узнать об этом только
прочтя документацию,

2163
01:39:52,550 --> 01:39:55,820
но это удобная функция, которая
позволит мне спать одну секунду.

2164
01:39:55,820 --> 01:39:57,920
Давайте сделаем переполнение.

2165
01:39:57,920 --> 01:39:58,650
No errors.

2166
01:39:58,650 --> 01:40:00,650
Я увеличу экран.

2167
01:40:00,650 --> 01:40:02,600
И запущу переполнение.

2168
01:40:02,600 --> 01:40:06,530
И мы увидим, что каждую секунду оно
печатает значение начинающееся с одного,

2169
01:40:06,530 --> 01:40:08,780
потом удваивает,
и удваивает,

2170
01:40:08,780 --> 01:40:10,760
и удваивает снова.

2171
01:40:10,760 --> 01:40:13,220
Вы можете вспомнить некоторые
из этих значений с прошлой недели,

2172
01:40:13,220 --> 01:40:16,620
где я предположил что в телефонной
книге 1024 страницы, а потом

2173
01:40:16,620 --> 01:40:18,893
их число становилось меньше и
меньше и меньше.

2174
01:40:18,893 --> 01:40:20,310
Теперь мы делаем это в обратную сторону.

2175
01:40:20,310 --> 01:40:22,970
Мы умножаем на два, на два, на два.

2176
01:40:22,970 --> 01:40:26,090
Мы теперь за миллионом,
2 миллиона, 4 миллиона, 8 миллионов,

2177
01:40:26,090 --> 01:40:27,077
16 миллионов.

2178
01:40:27,077 --> 01:40:28,160
И все еще растет.

2179
01:40:28,160 --> 01:40:30,770
Так что получается
integerы достаточно большие.

2180
01:40:30,770 --> 01:40:35,720
Они используют 32 бита в компьютере,
что очевидно--

2181
01:40:35,720 --> 01:40:38,150
что только что произошло?

2182
01:40:38,150 --> 01:40:39,170
Еще одна ложь.

2183
01:40:39,170 --> 01:40:44,360
Если вы постоянно умножаете какой нибудь
integer на два, он в итоге становится нулем,

2184
01:40:44,360 --> 01:40:46,310
получается так.

2185
01:40:46,310 --> 01:40:48,153
Это как то не очень верно.

2186
01:40:48,153 --> 01:40:49,070
Но что случилось?

2187
01:40:49,070 --> 01:40:51,770
Тут есть некоторый трюк, и в имени
моей программы

2188
01:40:51,770 --> 01:40:53,240
и в этой красной ошибке.

2189
01:40:53,240 --> 01:40:56,750
В какой то момент у вас есть
вот столько бит

2190
01:40:56,750 --> 01:40:59,840
после которых если продолжать
увеличивать,

2191
01:40:59,840 --> 01:41:02,600
у вас уже нет столько битов, чтобы
продолжать увеличение, чтобы

2192
01:41:02,600 --> 01:41:04,580
запомнить еще большие значения.

2193
01:41:04,580 --> 01:41:08,000
В итоге, если мы вернемся к некоторым
вещам, которые мы обсуждали

2194
01:41:08,000 --> 01:41:12,240
это называется неточностью плавающей точки
или вот теперь переполнением integer,

2195
01:41:12,240 --> 01:41:14,720
что значит floatы могут быть
лишь настолько точными

2196
01:41:14,720 --> 01:41:16,830
и integerы лишь настолько большими.

2197
01:41:16,830 --> 01:41:18,670
Так что у вас есть следующий сценарий.

2198
01:41:18,670 --> 01:41:21,253
123 десятичная, в нашем человеческом мире--

2199
01:41:21,253 --> 01:41:23,170
вы конечно можете продолжать
добавлять единицы к нему.

2200
01:41:23,170 --> 01:41:26,630
And as soon as you hit
nine, it rolls over to zero.

2201
01:41:26,630 --> 01:41:29,240
You then carry the
one, and you have 130.

2202
01:41:29,240 --> 01:41:30,380
That works great.

2203
01:41:30,380 --> 01:41:36,050
But of course, even in decimal, if
you're at 999 using only three digits

2204
01:41:36,050 --> 01:41:39,440
and you try to add one more, you
carry the one, you carry the one,

2205
01:41:39,440 --> 01:41:41,000
you lose the one.

2206
01:41:41,000 --> 01:41:41,840
Sorry.

2207
01:41:41,840 --> 01:41:43,110
What happens next?

2208
01:41:43,110 --> 01:41:47,030
This becomes 1, 0, 0, 0.

2209
01:41:47,030 --> 01:41:50,420
But if you only have three
digits, you lose that initial one,

2210
01:41:50,420 --> 01:41:51,890
and you're left with just zero.

2211
01:41:51,890 --> 01:41:53,150
Same thing happens in binary.

2212
01:41:53,150 --> 01:41:54,690
Now if you context switch--

2213
01:41:54,690 --> 01:41:58,860
and this is, in binary, what number?

2214
01:41:58,860 --> 01:42:01,580
This is the fours
place, twos place, ones.

2215
01:42:01,580 --> 01:42:02,420
So it's seven.

2216
01:42:02,420 --> 01:42:04,280
4 plus 2 plus 1, this is 7.

2217
01:42:04,280 --> 01:42:06,230
So of course, if you
add 1 to 7, you'd like

2218
01:42:06,230 --> 01:42:10,010
to get 8, which would give you 1, 0, 0.

2219
01:42:10,010 --> 01:42:13,370
But if you only have
three bits, three digits,

2220
01:42:13,370 --> 01:42:15,740
you're going to overflow, so to speak.

2221
01:42:15,740 --> 01:42:19,400
You're going to lose the carried one so
that the value you're actually storing

2222
01:42:19,400 --> 01:42:20,600
is just zero.

2223
01:42:20,600 --> 01:42:23,600
That's why if I count high enough
with an integer in a program,

2224
01:42:23,600 --> 01:42:28,010
once I hit the billions, eventually
that one has gotten carried too far.

2225
01:42:28,010 --> 01:42:30,620
It's only 32 bits large.

2226
01:42:30,620 --> 01:42:33,530
We can't fit a number
even bigger than that.

2227
01:42:33,530 --> 01:42:35,240
That's what's called integer overflow.

2228
01:42:35,240 --> 01:42:38,340
And if you ever heard
of the Y2K problem,

2229
01:42:38,340 --> 01:42:43,340
this was a horrible, very simple problem
that humans created for themselves

2230
01:42:43,340 --> 01:42:46,960
back in the day when computers were
invented in the mid 1900s, really.

2231
01:42:46,960 --> 01:42:50,410
Humans decided to save space, very
reasonable, because space was expensive

2232
01:42:50,410 --> 01:42:51,260
early on.

2233
01:42:51,260 --> 01:42:58,452
So instead of storing the year as 1999
or 1970 for 1970, what did they do?

2234
01:42:58,452 --> 01:43:00,160
Yeah, they just stored
two digits, right?

2235
01:43:00,160 --> 01:43:01,480
Like oh my god, we're
not going to be using

2236
01:43:01,480 --> 01:43:03,190
these computers 50 years from now.

2237
01:43:03,190 --> 01:43:04,570
Let's just store two digits.

2238
01:43:04,570 --> 01:43:06,573
Unfortunately, that was not the case.

2239
01:43:06,573 --> 01:43:09,490
And there was a lot of code out there
and a lot of computers out there

2240
01:43:09,490 --> 01:43:12,040
that were still running in 1999.

2241
01:43:12,040 --> 01:43:17,080
But if you're only storing two
digits and you plus plus one value

2242
01:43:17,080 --> 01:43:20,020
to the year, what you'd
like to be 2000 was

2243
01:43:20,020 --> 01:43:25,120
misinterpreted in lots of systems
as 1900, at which point stuff broke.

2244
01:43:25,120 --> 01:43:27,580
And the world spent millions
of dollars, presumably,

2245
01:43:27,580 --> 01:43:30,160
having programmers
start using more memory

2246
01:43:30,160 --> 01:43:32,650
to fix this problem in
anticipation of what was called

2247
01:43:32,650 --> 01:43:35,860
Y2K to get ahead of this problem.

2248
01:43:35,860 --> 01:43:38,890
And in the end, the world did
not end in 1999, which was great.

2249
01:43:38,890 --> 01:43:40,930
But it was a very real
and a very expensive

2250
01:43:40,930 --> 01:43:43,570
problem because of
that lack of foresight.

2251
01:43:43,570 --> 01:43:46,400
It turns out that there's other
examples of this, as well.

2252
01:43:46,400 --> 01:43:50,980
So this one, as an example, will
just about end on Boeing 787.

2253
01:43:50,980 --> 01:43:53,737
So Boeing has not been
getting great press recently.

2254
01:43:53,737 --> 01:43:55,570
And even a few years
ago, did they have what

2255
01:43:55,570 --> 01:43:58,150
appeared to be a very
straightforward software bug.

2256
01:43:58,150 --> 01:44:01,300
Pictured here is a model 787 airplane.

2257
01:44:01,300 --> 01:44:04,210
And the article from The New
York Times explained as follows--

2258
01:44:04,210 --> 01:44:09,130
"A model 787 airplane that has been
powered continuously for 248 days

2259
01:44:09,130 --> 01:44:12,070
can lose all alternating
current, electrical power,

2260
01:44:12,070 --> 01:44:14,380
due to the generator
control units simultaneously

2261
01:44:14,380 --> 01:44:15,940
going into failsafe mode.

2262
01:44:15,940 --> 01:44:17,920
This condition is caused
by a software counter

2263
01:44:17,920 --> 01:44:20,920
internal to the counters
that will overflow

2264
01:44:20,920 --> 01:44:24,550
after 248 days of continuous power.

2265
01:44:24,550 --> 01:44:26,920
Boeing, according to the
statement, is in the process

2266
01:44:26,920 --> 01:44:30,550
of developing a software upgrade
that will remedy the safe condition."

2267
01:44:30,550 --> 01:44:31,578
So what does this mean?

2268
01:44:31,578 --> 01:44:33,370
Well, if you actually
dig into the numbers,

2269
01:44:33,370 --> 01:44:41,560
248 days is roughly the value
of 2 raised to the 32nd power,

2270
01:44:41,560 --> 01:44:44,467
give or take, in 1/100 of a second.

2271
01:44:44,467 --> 01:44:47,050
Which is to say that Boeing, in
some crucial piece of hardware

2272
01:44:47,050 --> 01:44:51,640
in their 787 actual
airplanes, were using integers

2273
01:44:51,640 --> 01:44:56,140
that were counting so high that after
the 248th day of the airplane being

2274
01:44:56,140 --> 01:44:59,230
powered on would actually
overflow, the result of which

2275
01:44:59,230 --> 01:45:01,900
is that the power in the
plane could cut off entirely.

2276
01:45:01,900 --> 01:45:05,140
And so the solution, if you read through
all the technical speak and jargon

2277
01:45:05,140 --> 01:45:09,970
there, is they literally had to
reboot their planes every 248 days

2278
01:45:09,970 --> 01:45:13,270
in order to reset that
variable back to zero.

2279
01:45:13,270 --> 01:45:16,870
This happens even today in the
real world with issues like that.

2280
01:45:16,870 --> 01:45:19,540
And so you'll begin to notice
these trends anytime people talk

2281
01:45:19,540 --> 01:45:21,760
about hardware mistakes
or software mistakes.

2282
01:45:21,760 --> 01:45:24,700
Quite honestly, can you
typically reduce them to problems

2283
01:45:24,700 --> 01:45:26,690
you yourselves have run into.

2284
01:45:26,690 --> 01:45:30,310
And let me go ahead and tease just a
couple of things, a couple of features

2285
01:45:30,310 --> 01:45:31,390
now ahead.

2286
01:45:31,390 --> 01:45:34,450
It turns out that now that we
have the ability to write code,

2287
01:45:34,450 --> 01:45:37,630
our programs, of course, can do any
number of things, saying or printing

2288
01:45:37,630 --> 01:45:38,657
things on the screen.

2289
01:45:38,657 --> 01:45:40,990
We, of course, might do
something like this in a program

2290
01:45:40,990 --> 01:45:43,900
we might call figlet, which
actually comes with some systems.

2291
01:45:43,900 --> 01:45:46,630
And I can say something
like, this is CS50,

2292
01:45:46,630 --> 01:45:49,540
and actually print it out in what's
called ASCII art using characters

2293
01:45:49,540 --> 01:45:51,707
on the screen that kind of
sort of look like letters

2294
01:45:51,707 --> 01:45:55,520
and create fairly beautiful, if
old school, art on the screen.

2295
01:45:55,520 --> 01:45:58,210
Of course, if you write
code and you understand

2296
01:45:58,210 --> 01:46:01,450
not only how numbers and letters
are represented, but also sounds,

2297
01:46:01,450 --> 01:46:04,270
per our chat last week, you can
do even more powerful things,

2298
01:46:04,270 --> 01:46:08,900
such as this note, which we
will literally end on today.

2299
01:46:08,900 --> 01:46:10,217
SPEAKER 2: This is CS50.

2300
01:46:10,217 --> 01:46:11,550
DAVID MALAN: That's it for CS50.

2301
01:46:11,550 --> 01:46:13,210
We will see you next week.

2302
01:46:13,210 --> 01:46:15,060
[APPLAUSE]
